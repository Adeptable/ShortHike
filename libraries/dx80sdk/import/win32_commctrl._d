module win32_commctrl;

import windef;
import winuser;

//
// port to D of the follwoing file
//

/*****************************************************************************\
*                                                                             *
* commctrl.h - - Interface for the Windows Common Controls                    *
*                                                                             *
* Version 1.0                                                                 *
*                                                                             *
* Copyright (c) 1991-1996, Microsoft Corp.      All rights reserved.          *
*                                                                             *
\*****************************************************************************/


//#ifdef _WIN32
//#include <pshpack1.h> all structs are align:1
//#endif

//
// Users of this header may define any number of these constants to avoid
// the definitions of each functional group.
//
//    NOTOOLBAR    Customizable bitmap-button toolbar control.
//    NOUPDOWN     Up and Down arrow increment/decrement control.
//    NOSTATUSBAR  Status bar control.
//    NOMENUHELP   APIs to help manage menus, especially with a status bar.
//    NOTRACKBAR   Customizable column-width tracking control.
//    NODRAGLIST   APIs to make a listbox source and sink drag&drop actions.
//    NOPROGRESS   Progress gas gauge.
//    NOHOTKEY     HotKey control
//    NOHEADER     Header bar control.
//    NOIMAGEAPIS  ImageList apis.
//    NOLISTVIEW   ListView control.
//    NOTREEVIEW   TreeView control.
//    NOTABCONTROL Tab control.
//    NOANIMATE    Animate control.
//
//=============================================================================

//#include <prsht.h>
// property sheet API

extern (Windows)
{


void InitCommonControls();

enum {
ODT_HEADER              =100,
ODT_TAB                 =101,
ODT_LISTVIEW            =102
}


//====== Ranges for control message IDs =======================================
enum {
LVM_FIRST               =0x1000,      // ListView messages
TV_FIRST                =0x1100,      // TreeView messages
HDM_FIRST               =0x1200      // Header messages
}

//====== WM_NOTIFY Macros =====================================================
/*
#define HANDLE_WM_NOTIFY(hwnd, wParam, lParam, fn) \
    (fn)((hwnd), (int)(wParam), (NMHDR *)(lParam))
#define FORWARD_WM_NOTIFY(hwnd, idFrom, pnmhdr, fn) \
    (LRESULT)(fn)((hwnd), WM_NOTIFY, (WPARAM)(int)(idFrom), (LPARAM)(NMHDR *)(pnmhdr))
*/
//====== WM_NOTIFY codes (NMHDR.code values) ==================================
enum : int {
NM_FIRST                =0,       // generic to all controls
NM_LAST                 =-99,
LVN_FIRST               =-100,       // listview
LVN_LAST                =-199,
HDN_FIRST               =-300,       // header
HDN_LAST                =-399,
TVN_FIRST               =-400,       // treeview
TVN_LAST                =-499,
TTN_FIRST               =-520,       // tooltips
TTN_LAST                =-549,
TCN_FIRST               =-550,       // tab control
TCN_LAST                =-580,
// Shell reserved               (0U-580U) -  (0U-589U)
CDN_FIRST               =-601,       // common dialog (new)
CDN_LAST                =-699,
TBN_FIRST               =-700,       // toolbar
TBN_LAST                =-720,
UDN_FIRST               =-721,        // updown
UDN_LAST                =-740
}
//====== Generic WM_NOTIFY notification codes =================================
enum {
NM_OUTOFMEMORY          =(NM_FIRST-1),
NM_CLICK                =(NM_FIRST-2),
NM_DBLCLK               =(NM_FIRST-3),
NM_RETURN               =(NM_FIRST-4),
NM_RCLICK               =(NM_FIRST-5),
NM_RDBLCLK              =(NM_FIRST-6),
NM_SETFOCUS             =(NM_FIRST-7),
NM_KILLFOCUS            =(NM_FIRST-8)
}

enum {
MSGF_COMMCTRL_BEGINDRAG     =0x4200,
MSGF_COMMCTRL_SIZEHEADER    =0x4201,
MSGF_COMMCTRL_DRAGSELECT    =0x4202,
MSGF_COMMCTRL_TOOLBARCUST   =0x4203
}



//====== IMAGE APIS ===========================================================

enum : uint {
CLR_NONE                =0xFFFFFFFF,
CLR_DEFAULT             =0xFF000000
}

struct _IMAGELIST { };
alias _IMAGELIST * HIMAGELIST;

struct IMAGEINFO { align (1):
    HBITMAP hbmImage;
    HBITMAP hbmMask;
    int     Unused1;
    int     Unused2;
    RECT    rcImage;
}

enum {
ILC_MASK                =0x0001,
ILC_COLOR               =0x0000,
ILC_COLORDDB            =0x00FE,
ILC_COLOR4              =0x0004,
ILC_COLOR8              =0x0008,
ILC_COLOR16             =0x0010,
ILC_COLOR24             =0x0018,
ILC_COLOR32             =0x0020,
ILC_PALETTE             =0x0800
}

HIMAGELIST  ImageList_Create(int cx, int cy, UINT flags, int cInitial, int cGrow);
BOOL        ImageList_Destroy(HIMAGELIST himl);
int         ImageList_GetImageCount(HIMAGELIST himl);
int         ImageList_Add(HIMAGELIST himl, HBITMAP hbmImage, HBITMAP hbmMask);
int         ImageList_ReplaceIcon(HIMAGELIST himl, int i, HICON hicon);
COLORREF    ImageList_SetBkColor(HIMAGELIST himl, COLORREF clrBk);
COLORREF    ImageList_GetBkColor(HIMAGELIST himl);
BOOL        ImageList_SetOverlayImage(HIMAGELIST himl, int iImage, int iOverlay);

//#define     ImageList_AddIcon(himl, hicon) ImageList_ReplaceIcon(himl, -1, hicon)

enum : uint {
ILD_NORMAL              =0x0000,
ILD_TRANSPARENT         =0x0001,
ILD_MASK                =0x0010,
ILD_IMAGE               =0x0020,
ILD_BLEND25             =0x0002,
ILD_BLEND50             =0x0004,
ILD_OVERLAYMASK         =0x0F00,
ILD_SELECTED            =ILD_BLEND50,
ILD_FOCUS               =ILD_BLEND25,
ILD_BLEND               =ILD_BLEND50,
CLR_HILIGHT             =CLR_DEFAULT
}
//INDEXTOOVERLAYMASK(i)   ((i) << 8)


BOOL ImageList_Draw( HIMAGELIST himl, int i, HDC hdcDst, int x, int y, UINT fStyle );

BOOL        ImageList_Replace(HIMAGELIST himl, int i, HBITMAP hbmImage, HBITMAP hbmMask);
int         ImageList_AddMasked(HIMAGELIST himl, HBITMAP hbmImage, COLORREF crMask);
BOOL        ImageList_DrawEx(HIMAGELIST himl, int i, HDC hdcDst, int x, int y, int dx, int dy, COLORREF rgbBk, COLORREF rgbFg, UINT fStyle);
BOOL        ImageList_Remove(HIMAGELIST himl, int i);
HICON       ImageList_GetIcon(HIMAGELIST himl, int i, UINT flags);
HIMAGELIST  ImageList_LoadImageA(HINSTANCE hi, LPCSTR lpbmp, int cx, int cGrow, COLORREF crMask, UINT uType, UINT uFlags);
HIMAGELIST  ImageList_LoadImageW(HINSTANCE hi, LPCWSTR lpbmp, int cx, int cGrow, COLORREF crMask, UINT uType, UINT uFlags);

version( UNICODE ) {
alias ImageList_LoadImageW ImageList_LoadImage;
} else {
alias ImageList_LoadImageA ImageList_LoadImage;
}

BOOL        ImageList_BeginDrag(HIMAGELIST himlTrack, int iTrack, int dxHotspot, int dyHotspot);
void        ImageList_EndDrag();
BOOL        ImageList_DragEnter(HWND hwndLock, int x, int y);
BOOL        ImageList_DragLeave(HWND hwndLock);
BOOL        ImageList_DragMove(int x, int y);
BOOL        ImageList_SetDragCursorImage(HIMAGELIST himlDrag, int iDrag, int dxHotspot, int dyHotspot);

BOOL        ImageList_DragShowNolock(BOOL fShow);
HIMAGELIST  ImageList_GetDragImage(POINT * ppt,POINT * pptHotspot);

//#define     ImageList_RemoveAll(himl) ImageList_Remove(himl, -1)
//#define     ImageList_ExtractIcon(hi, himl, i) ImageList_GetIcon(himl, i, 0)
//#define     ImageList_LoadBitmap(hi, lpbmp, cx, cGrow, crMask) ImageList_LoadImage(hi, lpbmp, cx, cGrow, crMask, IMAGE_BITMAP, 0)

//#ifdef __IStream_INTERFACE_DEFINED__
//HIMAGELIST ImageList_Read(LPSTREAM pstm);
//BOOL       ImageList_Write(HIMAGELIST himl, LPSTREAM pstm);
//#endif

BOOL        ImageList_GetIconSize(HIMAGELIST himl, int  *cx, int  *cy);
BOOL        ImageList_SetIconSize(HIMAGELIST himl, int cx, int cy);
BOOL        ImageList_GetImageInfo(HIMAGELIST himl, int i, IMAGEINFO * pImageInfo);
HIMAGELIST  ImageList_Merge(HIMAGELIST himl1, int i1, HIMAGELIST himl2, int i2, int dx, int dy);


//====== HEADER CONTROL =======================================================
//#define WC_HEADER               "SysHeader"
const char[]  WC_HEADERA = "SysHeader32";
const wchar[] WC_HEADERW = "SysHeader32";

version( UNICODE ) {
alias WC_HEADERW WC_HEADER;
} else {
alias WC_HEADERA WC_HEADER;
}

enum {
HDS_HORZ                =0x00000000,
HDS_BUTTONS             =0x00000002,
HDS_HIDDEN              =0x00000008
}

struct HD_ITEMA { align (1):
    UINT    mask;
    int     cxy;
    LPSTR   pszText;
    HBITMAP hbm;
    int     cchTextMax;
    int     fmt;
    LPARAM  lParam;
} 

struct HD_ITEMW { align (1):
    UINT    mask;
    int     cxy;
    LPWSTR   pszText;
    HBITMAP hbm;
    int     cchTextMax;
    int     fmt;
    LPARAM  lParam;
} 

version( UNICODE ) {
alias HD_ITEMW HD_ITEM;
} else {
alias HD_ITEMA HD_ITEM;
}

enum {
HDI_WIDTH               =0x0001,
HDI_HEIGHT              =HDI_WIDTH,
HDI_TEXT                =0x0002,
HDI_FORMAT              =0x0004,
HDI_LPARAM              =0x0008,
HDI_BITMAP              =0x0010
}

enum {
HDF_LEFT                =0x0000,
HDF_RIGHT               =0x0001,
HDF_CENTER              =0x0002,
HDF_JUSTIFYMASK         =0x0003,
HDF_RTLREADING          =0x0004,

HDF_OWNERDRAW           =0x8000,
HDF_STRING              =0x4000,
HDF_BITMAP              =0x2000,

}

//#define Header_GetItemCount(hwndHD) \
//    (int)SNDMSG((hwndHD), HDM_GETITEMCOUNT, 0, 0L)

enum {
HDM_GETITEMCOUNT        = (HDM_FIRST + 0),
HDM_INSERTITEMA         = (HDM_FIRST + 1),
HDM_DELETEITEM          = (HDM_FIRST + 2),
HDM_GETITEMA            = (HDM_FIRST + 3),
HDM_SETITEMA            = (HDM_FIRST + 4),
HDM_LAYOUT              = (HDM_FIRST + 5),
HDM_HITTEST             = (HDM_FIRST + 6),
HDM_INSERTITEMW         = (HDM_FIRST + 10),
HDM_GETITEMW            = (HDM_FIRST + 11),
HDM_SETITEMW            = (HDM_FIRST + 12)
}

version( UNICODE ) {
alias HDM_INSERTITEMW HDM_INSERTITEM;
alias HDM_GETITEMW HDM_GETITEM;
alias HDM_SETITEMW HDM_SETITEM;
} else {
alias HDM_INSERTITEMA HDM_INSERTITEM;
alias HDM_GETITEMA HDM_GETITEM;
alias HDM_SETITEMA HDM_SETITEM;
}

//#define Header_InsertItem(hwndHD, i, phdi) \
//    (int)SNDMSG((hwndHD), HDM_INSERTITEM, (WPARAM)(int)(i), (LPARAM)(const HD_ITEM *)(phdi))
//#define Header_DeleteItem(hwndHD, i) \
//    (BOOL)SNDMSG((hwndHD), HDM_DELETEITEM, (WPARAM)(int)(i), 0L)
//#define Header_GetItem(hwndHD, i, phdi) \
//    (BOOL)SNDMSG((hwndHD), HDM_GETITEM, (WPARAM)(int)(i), (LPARAM)(HD_ITEM *)(phdi))
//#define Header_SetItem(hwndHD, i, phdi) \
//    (BOOL)SNDMSG((hwndHD), HDM_SETITEM, (WPARAM)(int)(i), (LPARAM)(const HD_ITEM *)(phdi))
//#define Header_Layout(hwndHD, playout) \
//    (BOOL)SNDMSG((hwndHD), HDM_LAYOUT, 0, (LPARAM)(HD_LAYOUT *)(playout))

struct HD_LAYOUT { align (1):
    RECT * prc;
    WINDOWPOS * pwpos;
} 

enum {
HHT_NOWHERE             =0x0001,
HHT_ONHEADER            =0x0002,
HHT_ONDIVIDER           =0x0004,
HHT_ONDIVOPEN           =0x0008,
HHT_ABOVE               =0x0100,
HHT_BELOW               =0x0200,
HHT_TORIGHT             =0x0400,
HHT_TOLEFT              =0x0800
}

struct HD_HITTESTINFO { align (1):
    POINT pt;
    UINT flags;
    int iItem;
} 

enum {
HDN_ITEMCHANGINGA       =(HDN_FIRST-0),
HDN_ITEMCHANGINGW       =(HDN_FIRST-20),
HDN_ITEMCHANGEDA        =(HDN_FIRST-1),
HDN_ITEMCHANGEDW        =(HDN_FIRST-21),
HDN_ITEMCLICKA          =(HDN_FIRST-2),
HDN_ITEMCLICKW          =(HDN_FIRST-22),
HDN_ITEMDBLCLICKA       =(HDN_FIRST-3),
HDN_ITEMDBLCLICKW       =(HDN_FIRST-23),
HDN_DIVIDERDBLCLICKA    =(HDN_FIRST-5),
HDN_DIVIDERDBLCLICKW    =(HDN_FIRST-25),
HDN_BEGINTRACKA         =(HDN_FIRST-6),
HDN_BEGINTRACKW         =(HDN_FIRST-26),
HDN_ENDTRACKA           =(HDN_FIRST-7),
HDN_ENDTRACKW           =(HDN_FIRST-27),
HDN_TRACKA              =(HDN_FIRST-8),
HDN_TRACKW              =(HDN_FIRST-28)
}

version ( UNICODE ) {
alias HDN_ITEMCHANGINGW    HDN_ITEMCHANGING;
alias HDN_ITEMCHANGEDW     HDN_ITEMCHANGED;
alias HDN_ITEMCLICKW       HDN_ITEMCLICK;
alias HDN_ITEMDBLCLICKW    HDN_ITEMDBLCLICK;
alias HDN_DIVIDERDBLCLICKW HDN_DIVIDERDBLCLICK;
alias HDN_BEGINTRACKW      HDN_BEGINTRACK;
alias HDN_ENDTRACKW        HDN_ENDTRACK;
alias HDN_TRACKW           HDN_TRACK;
} else {
alias HDN_ITEMCHANGINGA    HDN_ITEMCHANGING;
alias HDN_ITEMCHANGEDA     HDN_ITEMCHANGED;
alias HDN_ITEMCLICKA       HDN_ITEMCLICK;
alias HDN_ITEMDBLCLICKA    HDN_ITEMDBLCLICK;
alias HDN_DIVIDERDBLCLICKA HDN_DIVIDERDBLCLICK;
alias HDN_BEGINTRACKA      HDN_BEGINTRACK;
alias HDN_ENDTRACKA        HDN_ENDTRACK;
alias HDN_TRACKA           HDN_TRACK;
}

struct HD_NOTIFYA { align (1):
    NMHDR   hdr;
    int     iItem;
    int     iButton;
    HD_ITEMA * pitem;
}

struct HD_NOTIFYW { align (1):
    NMHDR   hdr;
    int     iItem;
    int     iButton;
    HD_ITEMW * pitem;
} 

version ( UNICODE ) {
alias HD_NOTIFYW HD_NOTIFY;
} else {
alias HD_NOTIFYA HD_NOTIFY;
}


//====== TOOLBAR CONTROL ======================================================

//#define TOOLBARCLASSNAME        "ToolbarWindow"
const char[]  TOOLBARCLASSNAMEA = "ToolbarWindow32";
const wchar[] TOOLBARCLASSNAMEW = "ToolbarWindow32";

version ( UNICODE ) {
alias TOOLBARCLASSNAMEW TOOLBARCLASSNAME;
} else {
alias TOOLBARCLASSNAMEA TOOLBARCLASSNAME;
}

struct TBBUTTON { align (1):
    int iBitmap;
    int idCommand;
    BYTE fsState;
    BYTE fsStyle;
    BYTE bReserved[2];
    DWORD dwData;
    int iString;
} 
alias TBBUTTON * PTBBUTTON,LPTBBUTTON;
alias TBBUTTON * LPCTBBUTTON;

struct COLORMAP {  align (1):
    COLORREF from;
    COLORREF to;
} 
alias COLORMAP * LPCOLORMAP;

HWND CreateToolbarEx(HWND hwnd, DWORD ws, UINT wID, int nBitmaps,
                        HINSTANCE hBMInst, UINT wBMID, LPCTBBUTTON lpButtons,
                        int iNumButtons, int dxButton, int dyButton,
                        int dxBitmap, int dyBitmap, UINT uStructSize);

HBITMAP CreateMappedBitmap(HINSTANCE hInstance, int idBitmap,
                                  UINT wFlags, LPCOLORMAP lpColorMap,
                                  int iNumMaps);
enum {CMB_MASKED              =0x02}

enum {
TBSTATE_CHECKED         =0x01,
TBSTATE_PRESSED         =0x02,
TBSTATE_ENABLED         =0x04,
TBSTATE_HIDDEN          =0x08,
TBSTATE_INDETERMINATE   =0x10,
TBSTATE_WRAP            =0x20
}

enum {
TBSTYLE_BUTTON          =0x00,
TBSTYLE_SEP             =0x01,
TBSTYLE_CHECK           =0x02,
TBSTYLE_GROUP           =0x04,
TBSTYLE_CHECKGROUP      =(TBSTYLE_GROUP | TBSTYLE_CHECK),

TBSTYLE_TOOLTIPS        =0x0100,
TBSTYLE_WRAPABLE        =0x0200,
TBSTYLE_ALTDRAG         =0x0400,
}

enum {
TB_ENABLEBUTTON         =(WM_USER + 1),
TB_CHECKBUTTON          =(WM_USER + 2),
TB_PRESSBUTTON          =(WM_USER + 3),
TB_HIDEBUTTON           =(WM_USER + 4),
TB_INDETERMINATE       = (WM_USER + 5),
TB_ISBUTTONENABLED      =(WM_USER + 9),
TB_ISBUTTONCHECKED      =(WM_USER + 10),
TB_ISBUTTONPRESSED      =(WM_USER + 11),
TB_ISBUTTONHIDDEN       =(WM_USER + 12),
TB_ISBUTTONINDETERMINATE =(WM_USER + 13),
TB_SETSTATE             =(WM_USER + 17),
TB_GETSTATE             =(WM_USER + 18),
TB_ADDBITMAP            =(WM_USER + 19)
}

struct TBADDBITMAP { align (1):
        HINSTANCE       hInst;
        UINT            nID;
} 
alias TBADDBITMAP * LPTBADDBITMAP;

const HINSTANCE HINST_COMMCTRL          = ((HINSTANCE)-1);

enum {
IDB_STD_SMALL_COLOR     =0,
IDB_STD_LARGE_COLOR     =1,
IDB_VIEW_SMALL_COLOR    =4,
IDB_VIEW_LARGE_COLOR    =5
}

enum {
// icon indexes for standard bitmap
STD_CUT                 =0,
STD_COPY                =1,
STD_PASTE               =2,
STD_UNDO                =3,
STD_REDOW               =4,
STD_DELETE              =5,
STD_FILENEW             =6,
STD_FILEOPEN            =7,
STD_FILESAVE            =8,
STD_PRINTPRE            =9,
STD_PROPERTIES          =10,
STD_HELP                =11,
STD_FIND                =12,
STD_REPLACE             =13,
STD_PRINT               =14
}

enum {
// icon indexes for standard view bitmap
VIEW_LARGEICONS         =0,
VIEW_SMALLICONS         =1,
VIEW_LIST               =2,
VIEW_DETAILS            =3,
VIEW_SORTNAME           =4,
VIEW_SORTSIZE           =5,
VIEW_SORTDATE           =6,
VIEW_SORTTYPE           =7,
VIEW_PARENTFOLDER       =8,
VIEW_NETCONNECT         =9,
VIEW_NETDISCONNECT      =10,
VIEW_NEWFOLDER          =11
}

enum {
TB_ADDBUTTONS           =(WM_USER + 20),
TB_INSERTBUTTON         =(WM_USER + 21),
TB_DELETEBUTTON         =(WM_USER + 22),
TB_GETBUTTON            =(WM_USER + 23),
TB_BUTTONCOUNT          =(WM_USER + 24),
TB_COMMANDTOINDEX       =(WM_USER + 25),
TB_SAVERESTOREA         =(WM_USER + 26),
TB_SAVERESTOREW         =(WM_USER + 76),
TB_CUSTOMIZE            =(WM_USER + 27),
TB_ADDSTRINGA           =(WM_USER + 28),
TB_ADDSTRINGW           =(WM_USER + 77),
TB_GETITEMRECT          =(WM_USER + 29),
TB_BUTTONSTRUCTSIZE     =(WM_USER + 30),
TB_SETBUTTONSIZE        =(WM_USER + 31),
TB_SETBITMAPSIZE        =(WM_USER + 32),
TB_AUTOSIZE             =(WM_USER + 33),
TB_GETTOOLTIPS          =(WM_USER + 35),
TB_SETTOOLTIPS          =(WM_USER + 36),
TB_SETPARENT            =(WM_USER + 37),
TB_SETROWS              =(WM_USER + 39),
TB_GETROWS              =(WM_USER + 40),
TB_GETBITMAPFLAGS       =(WM_USER + 41),
TB_SETCMDID             =(WM_USER + 42),
TB_CHANGEBITMAP         =(WM_USER + 43),
TB_GETBITMAP            =(WM_USER + 44),
TB_GETBUTTONTEXTA       =(WM_USER + 45),
TB_GETBUTTONTEXTW       =(WM_USER + 75),
TB_REPLACEBITMAP        =(WM_USER + 46),
TB_SETINDENT            =(WM_USER + 47)
}

struct TBSAVEPARAMSA { align (1):
    HKEY hkr;
    LPCSTR pszSubKey;
    LPCSTR pszValueName;
}

struct tagTBSAVEPARAMSW { align (1):
    HKEY hkr;
    LPCWSTR pszSubKey;
    LPCWSTR pszValueName;
}

version (UNICODE) {
alias TBSAVEPARAMSW TBSAVEPARAMS;
alias TB_GETBUTTONTEXTW TB_GETBUTTONTEXT;
alias TB_SAVERESTOREW TB_SAVERESTORE;
alias TB_ADDSTRINGW TB_ADDSTRING;
} else {
alias TBSAVEPARAMSA TBSAVEPARAMS;
alias TB_GETBUTTONTEXTA TB_GETBUTTONTEXT;
alias TB_SAVERESTOREA TB_SAVERESTORE;
alias TB_ADDSTRINGA TB_ADDSTRING;
}

struct TBREPLACEBITMAP { align (1):
        HINSTANCE       hInstOld;
        UINT            nIDOld;
        HINSTANCE       hInstNew;
        UINT            nIDNew;
        int             nButtons;
} 
alias TBREPLACEBITMAP * LPTBREPLACEBITMAP;
enum { TBBF_LARGE               = 0x0001 }

enum : uint {
TBN_GETBUTTONINFOA      =(TBN_FIRST-0),
TBN_GETBUTTONINFOW      =(TBN_FIRST-20),
TBN_BEGINDRAG           =(TBN_FIRST-1),
TBN_ENDDRAG             =(TBN_FIRST-2),
TBN_BEGINADJUST         =(TBN_FIRST-3),
TBN_ENDADJUST           =(TBN_FIRST-4),
TBN_RESET               =(TBN_FIRST-5),
TBN_QUERYINSERT         =(TBN_FIRST-6),
TBN_QUERYDELETE         =(TBN_FIRST-7),
TBN_TOOLBARCHANGE       =(TBN_FIRST-8),
TBN_CUSTHELP            =(TBN_FIRST-9)
}

version (UNICODE) {
alias TBN_GETBUTTONINFOW TBN_GETBUTTONINFO;
} else {
alias TBN_GETBUTTONINFOA TBN_GETBUTTONINFO;
}

struct TBNOTIFYA { align (1):
    NMHDR   hdr;
    int     iItem;
    TBBUTTON tbButton;
    int     cchText;
    LPSTR   pszText;
} 
alias TBNOTIFYA * LPTBNOTIFYA;

struct TBNOTIFYW { align (1):
    NMHDR   hdr;
    int     iItem;
    TBBUTTON tbButton;
    int     cchText;
    LPWSTR   pszText;
} 
alias TBNOTIFYW * LPTBNOTIFYW;

version (UNICODE) {
alias TBNOTIFYW TBNOTIFY;
alias LPTBNOTIFYW LPTBNOTIFY;
} else {
alias TBNOTIFYA TBNOTIFY;
alias LPTBNOTIFYA LPTBNOTIFY;
}

//====== TOOLTIPS CONTROL =====================================================

//#define TOOLTIPS_CLASS          "tooltips_class"
const char[]  TOOLTIPS_CLASSA = "tooltips_class32";
const wchar[] TOOLTIPS_CLASSW = "tooltips_class32";

version( UNICODE ) {
alias TOOLTIPS_CLASSW TOOLTIPS_CLASS;
} else {
alias TOOLTIPS_CLASSA TOOLTIPS_CLASS;
}

struct TOOLINFOA { align (1):
    UINT cbSize;
    UINT uFlags;
    HWND hwnd;
    UINT uId;
    RECT rect;
    HINSTANCE hinst;
    LPSTR lpszText;
} 
alias TOOLINFOA * PTOOLINFOA,LPTOOLINFOA;

struct TOOLINFOW { align (1):
    UINT cbSize;
    UINT uFlags;
    HWND hwnd;
    UINT uId;
    RECT rect;
    HINSTANCE hinst;
    LPWSTR lpszText;
} 
alias TOOLINFOW * PTOOLINFOW,LPTOOLINFOW;

version ( UNICODE ) {
alias TOOLINFOW TOOLINFO;
alias PTOOLINFOW PTOOLINFO;
alias LPTOOLINFOW LPTOOLINFO;
} else {
alias TOOLINFOA TOOLINFO;
alias PTOOLINFOA PTOOLINFO;
alias LPTOOLINFOA LPTOOLINFO;
}

enum {
TTS_ALWAYSTIP           =0x01,
TTS_NOPREFIX            =0x02
}

enum {
TTF_IDISHWND            =0x0001,
TTF_CENTERTIP           =0x0002,
TTF_RTLREADING          =0x0004,
TTF_SUBCLASS            =0x0010
}

enum {
TTDT_AUTOMATIC          =0,
TTDT_RESHOW             =1,
TTDT_AUTOPOP            =2,
TTDT_INITIAL            =3
}

enum {
TTM_ACTIVATE            =(WM_USER + 1),
TTM_SETDELAYTIME        =(WM_USER + 3),
TTM_ADDTOOLA            =(WM_USER + 4),
TTM_ADDTOOLW            =(WM_USER + 50),
TTM_DELTOOLA            =(WM_USER + 5),
TTM_DELTOOLW            =(WM_USER + 51),
TTM_NEWTOOLRECTA        =(WM_USER + 6),
TTM_NEWTOOLRECTW        =(WM_USER + 52),
TTM_RELAYEVENT          =(WM_USER + 7)  ,                         

TTM_GETTOOLINFOA        =(WM_USER + 8),
TTM_GETTOOLINFOW        =(WM_USER + 53),

TTM_SETTOOLINFOA        =(WM_USER + 9),
TTM_SETTOOLINFOW        =(WM_USER + 54),

TTM_HITTESTA            =(WM_USER +10),
TTM_HITTESTW            =(WM_USER +55),
TTM_GETTEXTA            =(WM_USER +11),
TTM_GETTEXTW            =(WM_USER +56),
TTM_UPDATETIPTEXTA      =(WM_USER +12),
TTM_UPDATETIPTEXTW      =(WM_USER +57),
TTM_GETTOOLCOUNT        =(WM_USER +13),
TTM_ENUMTOOLSA          =(WM_USER +14),
TTM_ENUMTOOLSW          =(WM_USER +58),
TTM_GETCURRENTTOOLA     =(WM_USER + 15),
TTM_GETCURRENTTOOLW     =(WM_USER + 59),
TTM_WINDOWFROMPOINT     =(WM_USER + 16)
}

version (UNICODE) {
alias TTM_ADDTOOLW TTM_ADDTOOL;
alias TTM_DELTOOLW TTM_DELTOOL;
alias TTM_NEWTOOLRECTW TTM_NEWTOOLRECT;
alias TTM_GETTOOLINFOW TTM_GETTOOLINFO;
alias TTM_SETTOOLINFOW TTM_SETTOOLINFO;
alias TTM_HITTESTW TTM_HITTEST;
alias TTM_GETTEXTW TTM_GETTEXT;
alias TTM_UPDATETIPTEXTW TTM_UPDATETIPTEXT;
alias TTM_ENUMTOOLSW TTM_ENUMTOOLS;
alias TTM_GETCURRENTTOOLW TTM_GETCURRENTTOOL;
} else {
alias TTM_ADDTOOLA TTM_ADDTOOL;
alias TTM_DELTOOLA TTM_DELTOOL;
alias TTM_NEWTOOLRECTA TTM_NEWTOOLRECT;
alias TTM_GETTOOLINFOA TTM_GETTOOLINFO;
alias TTM_SETTOOLINFOA TTM_SETTOOLINFO;
alias TTM_HITTESTA TTM_HITTEST;
alias TTM_GETTEXTA TTM_GETTEXT;
alias TTM_UPDATETIPTEXTA TTM_UPDATETIPTEXT;
alias TTM_ENUMTOOLSA TTM_ENUMTOOLS;
alias TTM_GETCURRENTTOOLA TTM_GETCURRENTTOOL;
}

struct TTHITTESTINFOA { align (1):
    HWND hwnd;
    POINT pt;
    TOOLINFOA ti;
} 
alias TTHITTESTINFOA * LPHITTESTINFOA;

struct TTHITTESTINFOW { align (1):
    HWND hwnd;
    POINT pt;
    TOOLINFOW ti;
} 
alias TTHITTESTINFOW * LPHITTESTINFOW;


version (UNICODE) {
alias TTHITTESTINFOW TTHITTESTINFO;
alias LPHITTESTINFOW LPHITTESTINFO;
} else {
alias TTHITTESTINFOA TTHITTESTINFO;
alias LPHITTESTINFOA LPHITTESTINFO;
}

enum {
TTN_NEEDTEXTA           =(TTN_FIRST - 0),
TTN_NEEDTEXTW           =(TTN_FIRST - 10),
TTN_SHOW                =(TTN_FIRST - 1),
TTN_POP                 =(TTN_FIRST - 2)
}

version (UNICODE) {
alias TTN_NEEDTEXTW TTN_NEEDTEXT;
} else {
alias TTN_NEEDTEXTA TTN_NEEDTEXT;
}

struct TOOLTIPTEXTA { align (1):
    NMHDR hdr;
    LPSTR lpszText;
    char szText[80];
    HINSTANCE hinst;
    UINT uFlags;
} 
alias TOOLTIPTEXTA * LPTOOLTIPTEXTA;

struct TOOLTIPTEXTW { align (1):
    NMHDR hdr;
    LPWSTR lpszText;
    WCHAR szText[80];
    HINSTANCE hinst;
    UINT uFlags;
} 
alias TOOLTIPTEXTW * LPTOOLTIPTEXTW;

version (UNICODE) {
alias TOOLTIPTEXTW TOOLTIPTEXT;
alias LPTOOLTIPTEXTW LPTOOLTIPTEXT;
} else {
alias TOOLTIPTEXTA TOOLTIPTEXT;
alias LPTOOLTIPTEXTA LPTOOLTIPTEXT;
}

//====== STATUS BAR CONTROL ===================================================


enum { SBARS_SIZEGRIP          = 0x0100 }


void DrawStatusTextA(HDC hDC, LPRECT lprc, LPCSTR pszText, UINT uFlags);
void DrawStatusTextW(HDC hDC, LPRECT lprc, LPCWSTR pszText, UINT uFlags);

HWND CreateStatusWindowA(LONG style, LPCSTR lpszText, HWND hwndParent, UINT wID);
HWND CreateStatusWindowW(LONG style, LPCWSTR lpszText, HWND hwndParent, UINT wID);

version(UNICODE) {
alias CreateStatusWindowW CreateStatusWindow;
alias DrawStatusTextW DrawStatusText;
} else {
alias CreateStatusWindowA CreateStatusWindow;
alias DrawStatusTextA DrawStatusText;
}

//#define STATUSCLASSNAME         "msctls_statusbar"
const wchar[] STATUSCLASSNAMEW = "msctls_statusbar32";
const char[]  STATUSCLASSNAMEA = "msctls_statusbar32";

version (UNICODE) {
alias STATUSCLASSNAMEW STATUSCLASSNAME;
} else {
alias STATUSCLASSNAMEA STATUSCLASSNAME;
}

enum {
SB_SETTEXTA             =(WM_USER+1),
SB_SETTEXTW             =(WM_USER+11),
SB_GETTEXTA             =(WM_USER+2),
SB_GETTEXTW             =(WM_USER+13),
SB_GETTEXTLENGTHA       =(WM_USER+3),
SB_GETTEXTLENGTHW       =(WM_USER+12),
SB_SETPARTS             =(WM_USER+4),
SB_GETPARTS             =(WM_USER+6),
SB_GETBORDERS           =(WM_USER+7),
SB_SETMINHEIGHT         =(WM_USER+8),
SB_SIMPLE               =(WM_USER+9),
SB_GETRECT              =(WM_USER+10)
}

version (UNICODE) {
alias SB_GETTEXTW SB_GETTEXT;
alias SB_SETTEXTW SB_SETTEXT;
alias SB_GETTEXTLENGTHW SB_GETTEXTLENGTH;
} else {
alias SB_GETTEXTA SB_GETTEXT;
alias SB_SETTEXTA SB_SETTEXT;
alias SB_GETTEXTLENGTHA SB_GETTEXTLENGTH;
}

enum {
SBT_OWNERDRAW            =0x1000,
SBT_NOBORDERS            =0x0100,
SBT_POPOUT               =0x0200,
SBT_RTLREADING           =0x0400
}

//====== MENU HELP ============================================================

void MenuHelp(UINT uMsg, WPARAM wParam, LPARAM lParam, HMENU hMainMenu, HINSTANCE hInst, HWND hwndStatus, UINT  *lpwIDs);
BOOL ShowHideMenuCtl(HWND hWnd, UINT uFlags, LPINT lpInfo);
void GetEffectiveClientRect(HWND hWnd, LPRECT lprc, LPINT lpInfo);

enum { MINSYSCOMMAND   = SC_SIZE }

//====== TRACKBAR CONTROL =====================================================

//#define TRACKBAR_CLASS          "msctls_trackbar"
const char[]  TRACKBAR_CLASSA = "msctls_trackbar32";
const wchar[] TRACKBAR_CLASSW = "msctls_trackbar32";

version (UNICODE) {
alias TRACKBAR_CLASSW TRACKBAR_CLASS;
} else {
alias TRACKBAR_CLASSA TRACKBAR_CLASS;
}

enum {
TBS_AUTOTICKS           =0x0001,
TBS_VERT                =0x0002,
TBS_HORZ                =0x0000,
TBS_TOP                 =0x0004,
TBS_BOTTOM              =0x0000,
TBS_LEFT                =0x0004,
TBS_RIGHT               =0x0000,
TBS_BOTH                =0x0008,
TBS_NOTICKS             =0x0010,
TBS_ENABLESELRANGE      =0x0020,
TBS_FIXEDLENGTH         =0x0040,
TBS_NOTHUMB             =0x0080
}

enum {
TBM_GETPOS              =(WM_USER),
TBM_GETRANGEMIN         =(WM_USER+1),
TBM_GETRANGEMAX         =(WM_USER+2),
TBM_GETTIC              =(WM_USER+3),
TBM_SETTIC              =(WM_USER+4),
TBM_SETPOS              =(WM_USER+5),
TBM_SETRANGE            =(WM_USER+6),
TBM_SETRANGEMIN         =(WM_USER+7),
TBM_SETRANGEMAX         =(WM_USER+8),
TBM_CLEARTICS           =(WM_USER+9),
TBM_SETSEL              =(WM_USER+10),
TBM_SETSELSTART         =(WM_USER+11),
TBM_SETSELEND           =(WM_USER+12),
TBM_GETPTICS            =(WM_USER+14),
TBM_GETTICPOS           =(WM_USER+15),
TBM_GETNUMTICS          =(WM_USER+16),
TBM_GETSELSTART         =(WM_USER+17),
TBM_GETSELEND           =(WM_USER+18),
TBM_CLEARSEL            =(WM_USER+19),
TBM_SETTICFREQ          =(WM_USER+20),
TBM_SETPAGESIZE         =(WM_USER+21),
TBM_GETPAGESIZE         =(WM_USER+22),
TBM_SETLINESIZE         =(WM_USER+23),
TBM_GETLINESIZE         =(WM_USER+24),
TBM_GETTHUMBRECT        =(WM_USER+25),
TBM_GETCHANNELRECT      =(WM_USER+26),
TBM_SETTHUMBLENGTH      =(WM_USER+27),
TBM_GETTHUMBLENGTH      =(WM_USER+28)
}

enum {
TB_LINEUP               =0,
TB_LINEDOWN             =1,
TB_PAGEUP               =2,
TB_PAGEDOWN             =3,
TB_THUMBPOSITION        =4,
TB_THUMBTRACK           =5,
TB_TOP                  =6,
TB_BOTTOM               =7,
TB_ENDTRACK             =8
}


//====== DRAG LIST CONTROL ====================================================

struct DRAGLISTINFO { align (1):
    UINT uNotification;
    HWND hWnd;
    POINT ptCursor;
} 
alias DRAGLISTINFO * LPDRAGLISTINFO;

enum {
DL_BEGINDRAG            =(WM_USER+133),
DL_DRAGGING             =(WM_USER+134),
DL_DROPPED              =(WM_USER+135),
DL_CANCELDRAG           =(WM_USER+136)
}

enum {
DL_CURSORSET            =0,
DL_STOPCURSOR           =1,
DL_COPYCURSOR           =2,
DL_MOVECURSOR           =3
}

version (UNICODE) {
const wchar[] DRAGLISTMSGSTRING       ="commctrl_DragListMsg";
} else {
const char[] DRAGLISTMSGSTRING       ="commctrl_DragListMsg";
}

BOOL MakeDragList(HWND hLB);
void DrawInsert(HWND handParent, HWND hLB, int nItem);
int LBItemFromPt(HWND hLB, POINT pt, BOOL bAutoScroll);


//#define UPDOWN_CLASS            "msctls_updown"
const char[]  UPDOWN_CLASSA = "msctls_updown32";
const wchar[] UPDOWN_CLASSW = "msctls_updown32";

version(UNICODE) {
alias UPDOWN_CLASSW UPDOWN_CLASS;
}else{
alias UPDOWN_CLASSA UPDOWN_CLASS;
}

struct UDACCEL { align (1):
    UINT nSec;
    UINT nInc;
} 
alias UDACCEL * LPUDACCEL;

enum {
UD_MAXVAL               =0x7fff,
UD_MINVAL               =(-UD_MAXVAL)
}

enum {
UDS_WRAP                =0x0001,
UDS_SETBUDDYINT         =0x0002,
UDS_ALIGNRIGHT          =0x0004,
UDS_ALIGNLEFT           =0x0008,
UDS_AUTOBUDDY           =0x0010,
UDS_ARROWKEYS           =0x0020,
UDS_HORZ                =0x0040,
UDS_NOTHOUSANDS         =0x0080
}

enum {
UDM_SETRANGE            =(WM_USER+101),
UDM_GETRANGE            =(WM_USER+102),
UDM_SETPOS              =(WM_USER+103),
UDM_GETPOS              =(WM_USER+104),
UDM_SETBUDDY            =(WM_USER+105),
UDM_GETBUDDY            =(WM_USER+106),
UDM_SETACCEL            =(WM_USER+107),
UDM_GETACCEL            =(WM_USER+108),
UDM_SETBASE             =(WM_USER+109),
UDM_GETBASE             =(WM_USER+110)
}


HWND CreateUpDownControl(DWORD dwStyle, int x, int y, int cx, int cy,
                                HWND hParent, int nID, HINSTANCE hInst,
                                HWND hBuddy,
                                int nUpper, int nLower, int nPos);

struct NM_UPDOWN { align (1):
    NMHDR hdr;
    int iPos;
    int iDelta;
} 
alias NM_UPDOWN * LPNM_UPDOWN;

enum { UDN_DELTAPOS = (UDN_FIRST - 1) }


//====== PROGRESS CONTROL =====================================================

//#define PROGRESS_CLASS          "msctls_progress"
const char[]  PROGRESS_CLASSA = "msctls_progress32";
const wchar[] PROGRESS_CLASSW = "msctls_progress32";

version(UNICODE) {
alias PROGRESS_CLASSW PROGRESS_CLASS;
} else {
alias PROGRESS_CLASSA PROGRESS_CLASS;
}

enum {
PBM_SETRANGE            =(WM_USER+1),
PBM_SETPOS              =(WM_USER+2),
PBM_DELTAPOS            =(WM_USER+3),
PBM_SETSTEP             =(WM_USER+4),
PBM_STEPIT              =(WM_USER+5)
}


//====== HOTKEY CONTROL =======================================================

//#define HOTKEY_CLASS            "msctls_hotkey"
const char[]  HOTKEY_CLASSA = "msctls_hotkey32";
const wchar[] HOTKEY_CLASSW = "msctls_hotkey32";

version(UNICODE) {
alias HOTKEY_CLASSW HOTKEY_CLASS;
} else {
alias HOTKEY_CLASSA HOTKEY_CLASS;
}

enum {
HOTKEYF_SHIFT           =0x01,
HOTKEYF_CONTROL         =0x02,
HOTKEYF_ALT             =0x04,
HOTKEYF_EXT             =0x08
}

enum {
HKCOMB_NONE             =0x0001,
HKCOMB_S                =0x0002,
HKCOMB_C                =0x0004,
HKCOMB_A                =0x0008,
HKCOMB_SC               =0x0010,
HKCOMB_SA               =0x0020,
HKCOMB_CA               =0x0040,
HKCOMB_SCA              =0x0080
}

enum {
HKM_SETHOTKEY           =(WM_USER+1),
HKM_GETHOTKEY           =(WM_USER+2),
HKM_SETRULES            =(WM_USER+3)
}



//====== COMMON CONTROL STYLES ================================================
enum : uint {
CCS_TOP                 =0x00000001,
CCS_NOMOVEY             =0x00000002,
CCS_BOTTOM              =0x00000003,
CCS_NORESIZE            =0x00000004,
CCS_NOPARENTALIGN       =0x00000008,
CCS_ADJUSTABLE          =0x00000020,
CCS_NODIVIDER           =0x00000040
}


//====== LISTVIEW CONTROL =====================================================
//#define WC_LISTVIEW             "SysListView"
const char[]  WC_LISTVIEWA = "SysListView32";
const wchar[] WC_LISTVIEWW = "SysListView32";

version (UNICODE) {
alias WC_LISTVIEWW WC_LISTVIEW;
} else {
alias WC_LISTVIEWA WC_LISTVIEW;
}

enum {
LVS_ICON                =0x0000,
LVS_REPORT              =0x0001,
LVS_SMALLICON           =0x0002,
LVS_LIST                =0x0003,
LVS_TYPEMASK            =0x0003,
LVS_SINGLESEL           =0x0004,
LVS_SHOWSELALWAYS       =0x0008,
LVS_SORTASCENDING       =0x0010,
LVS_SORTDESCENDING      =0x0020,
LVS_SHAREIMAGELISTS     =0x0040,
LVS_NOLABELWRAP         =0x0080,
LVS_AUTOARRANGE         =0x0100,
LVS_EDITLABELS          =0x0200,
LVS_OWNERDATA           =0x1000,
LVS_NOSCROLL            =0x2000
}

enum {
LVS_TYPESTYLEMASK       = 0xfc00
}

enum {
LVS_ALIGNTOP            =0x0000,
LVS_ALIGNLEFT           =0x0800,
LVS_ALIGNMASK           =0x0c00,
LVS_OWNERDRAWFIXED      =0x0400,
LVS_NOCOLUMNHEADER      =0x4000,
LVS_NOSORTHEADER        =0x8000
}

enum : uint { 
	LVM_GETBKCOLOR          = (LVM_FIRST + 0), 
	LVM_SETBKCOLOR          = (LVM_FIRST + 1),
	LVM_GETIMAGELIST        = (LVM_FIRST + 2),
	LVM_SETIMAGELIST        = (LVM_FIRST + 3),
	LVM_GETITEMCOUNT        = (LVM_FIRST + 4),
	LVM_GETITEMA            = (LVM_FIRST + 5),
	LVM_GETITEMW            = (LVM_FIRST + 75),
	LVM_SETITEMA            = (LVM_FIRST + 6),
	LVM_SETITEMW            = (LVM_FIRST + 76),
	LVM_INSERTITEMA         = (LVM_FIRST + 7),
	LVM_INSERTITEMW         = (LVM_FIRST + 77),
	LVM_DELETEITEM          = (LVM_FIRST + 8),
	LVM_DELETEALLITEMS      = (LVM_FIRST + 9),
	LVM_GETCALLBACKMASK     = (LVM_FIRST + 10),
	LVM_SETCALLBACKMASK     = (LVM_FIRST + 11),
	LVM_GETNEXTITEM         = (LVM_FIRST + 12),
	LVM_FINDITEMA           = (LVM_FIRST + 13),
	LVM_FINDITEMW           = (LVM_FIRST + 83),
	LVM_GETITEMRECT         = (LVM_FIRST + 14),
	LVM_SETITEMPOSITION     = (LVM_FIRST + 15),
	LVM_GETITEMPOSITION     = (LVM_FIRST + 16),
	LVM_GETSTRINGWIDTHA     = (LVM_FIRST + 17),
	LVM_HITTEST             = (LVM_FIRST + 18),
	LVM_GETSTRINGWIDTHW     = (LVM_FIRST + 87),
	LVM_ENSUREVISIBLE       = (LVM_FIRST + 19),
	LVM_SCROLL              = (LVM_FIRST + 20),
	LVM_REDRAWITEMS         = (LVM_FIRST + 21),
	LVM_ARRANGE             = (LVM_FIRST + 22),
	LVM_EDITLABELA          = (LVM_FIRST + 23),
	LVM_EDITLABELW          = (LVM_FIRST + 118),
	LVM_GETEDITCONTROL      = (LVM_FIRST + 24),
	LVM_GETCOLUMNA          = (LVM_FIRST + 25),
	LVM_GETCOLUMNW          = (LVM_FIRST + 95),
	LVM_SETCOLUMNA          = (LVM_FIRST + 26),
	LVM_SETCOLUMNW          = (LVM_FIRST + 96),
	LVM_INSERTCOLUMNA       = (LVM_FIRST + 27),
	LVM_INSERTCOLUMNW       = (LVM_FIRST + 97),
	LVM_DELETECOLUMN        = (LVM_FIRST + 28),
	LVM_GETCOLUMNWIDTH      = (LVM_FIRST + 29),
	LVM_SETCOLUMNWIDTH      = (LVM_FIRST + 30),
	LVM_CREATEDRAGIMAGE     = (LVM_FIRST + 33),
	LVM_GETVIEWRECT         = (LVM_FIRST + 34),
	LVM_GETTEXTCOLOR        = (LVM_FIRST + 35),
	LVM_SETTEXTCOLOR        = (LVM_FIRST + 36),
	LVM_GETTEXTBKCOLOR      = (LVM_FIRST + 37),
	LVM_SETTEXTBKCOLOR      = (LVM_FIRST + 38),
	LVM_GETTOPINDEX         = (LVM_FIRST + 39),
	LVM_GETCOUNTPERPAGE     = (LVM_FIRST + 40),
	LVM_GETORIGIN           = (LVM_FIRST + 41),
	LVM_UPDATE              = (LVM_FIRST + 42),
	LVM_SETITEMSTATE        = (LVM_FIRST + 43),
	LVM_GETITEMSTATE        = (LVM_FIRST + 44),
	LVM_GETITEMTEXTA        = (LVM_FIRST + 45),
	LVM_GETITEMTEXTW        = (LVM_FIRST + 115),
	LVM_SETITEMTEXTA        = (LVM_FIRST + 46),
	LVM_SETITEMTEXTW        = (LVM_FIRST + 116),
	LVM_SETITEMCOUNT        = (LVM_FIRST + 47),
	LVM_SORTITEMS           = (LVM_FIRST + 48),
	LVM_SETITEMPOSITION32   = (LVM_FIRST + 49),
	LVM_GETSELECTEDCOUNT    = (LVM_FIRST + 50),
	LVM_GETITEMSPACING      = (LVM_FIRST + 51),
	LVM_GETISEARCHSTRINGA   = (LVM_FIRST + 52),
	LVM_GETISEARCHSTRINGW   = (LVM_FIRST + 117)
}

version (UNICODE) {
alias LVM_SETITEMW LVM_SETITEM;
alias LVM_INSERTITEMW LVM_INSERTITEM;
alias LVM_GETITEMW LVM_GETITEM;
alias LVM_FINDITEMW LVM_FINDITEM;
alias LVM_GETSTRINGWIDTHW LVM_GETSTRINGWIDTH;
alias LVM_EDITLABELW LVM_EDITLABEL;
alias LVM_GETCOLUMNW LVM_GETCOLUMN;
alias LVM_SETCOLUMNW LVM_SETCOLUMN;
alias LVM_INSERTCOLUMNW LVM_INSERTCOLUMN;
alias LVM_GETITEMTEXTW LVM_GETITEMTEXT;
alias LVM_SETITEMTEXTW LVM_SETITEMTEXT;
alias LVM_GETISEARCHSTRINGW LVM_GETISEARCHSTRING;
} else {
alias LVM_SETITEMA LVM_SETITEM;
alias LVM_INSERTITEMA LVM_INSERTITEM;
alias LVM_GETITEMA LVM_GETITEM;
alias LVM_FINDITEMA LVM_FINDITEM;
alias LVM_GETSTRINGWIDTHA LVM_GETSTRINGWIDTH;
alias LVM_EDITLABELA LVM_EDITLABEL;
alias LVM_GETCOLUMNA LVM_GETCOLUMN;
alias LVM_SETCOLUMNA LVM_SETCOLUMN;
alias LVM_INSERTCOLUMNA LVM_INSERTCOLUMN;
alias LVM_GETITEMTEXTA LVM_GETITEMTEXT;
alias LVM_SETITEMTEXTA LVM_SETITEMTEXT;
alias LVM_GETISEARCHSTRINGA LVM_GETISEARCHSTRING;
}

//#define ListView_GetBkColor(hwnd)  \
//    (COLORREF)SNDMSG((hwnd), LVM_GETBKCOLOR, 0, 0L)
//#define ListView_SetBkColor(hwnd, clrBk) \
//    (BOOL)SNDMSG((hwnd), LVM_SETBKCOLOR, 0, (LPARAM)(COLORREF)(clrBk))
//#define ListView_GetImageList(hwnd, iImageList) \
//    (HIMAGELIST)SNDMSG((hwnd), LVM_GETIMAGELIST, (WPARAM)(INT)(iImageList), 0L)
//#define ListView_SetImageList(hwnd, himl, iImageList) \
//    (HIMAGELIST)(UINT)SNDMSG((hwnd), LVM_SETIMAGELIST, (WPARAM)(iImageList), (LPARAM)(UINT)(HIMAGELIST)(himl))
//#define ListView_GetItemCount(hwnd) \
//    (int)SNDMSG((hwnd), LVM_GETITEMCOUNT, 0, 0L)
//#define ListView_GetItem(hwnd, pitem) \
//    (BOOL)SNDMSG((hwnd), LVM_GETITEM, 0, (LPARAM)(LV_ITEM *)(pitem))
//#define ListView_SetItem(hwnd, pitem) \
//    (BOOL)SNDMSG((hwnd), LVM_SETITEM, 0, (LPARAM)(const LV_ITEM *)(pitem))
//#define ListView_InsertItem(hwnd, pitem)   \
//    (int)SNDMSG((hwnd), LVM_INSERTITEM, 0, (LPARAM)(const LV_ITEM *)(pitem))
//#define ListView_DeleteItem(hwnd, i) \
//    (BOOL)SNDMSG((hwnd), LVM_DELETEITEM, (WPARAM)(int)(i), 0L)
//#define ListView_DeleteAllItems(hwnd) \
//    (BOOL)SNDMSG((hwnd), LVM_DELETEALLITEMS, 0, 0L)
//#define ListView_GetCallbackMask(hwnd) \
//    (BOOL)SNDMSG((hwnd), LVM_GETCALLBACKMASK, 0, 0)
//#define ListView_SetCallbackMask(hwnd, mask) \
//    (BOOL)SNDMSG((hwnd), LVM_SETCALLBACKMASK, (WPARAM)(UINT)(mask), 0)
//#define ListView_GetNextItem(hwnd, i, flags) \
//    (int)SNDMSG((hwnd), LVM_GETNEXTITEM, (WPARAM)(int)(i), MAKELPARAM((flags), 0))
//#define ListView_FindItem(hwnd, iStart, plvfi) \
//    (int)SNDMSG((hwnd), LVM_FINDITEM, (WPARAM)(int)(iStart), (LPARAM)(const LV_FINDINFO *)(plvfi))
//#define ListView_GetItemRect(hwnd, i, prc, code) \
//     (BOOL)SNDMSG((hwnd), LVM_GETITEMRECT, (WPARAM)(int)(i), \
//           ((prc) ? (((RECT  *)(prc))->left = (code),(LPARAM)(RECT *)(prc)) : (LPARAM)(RECT *)NULL))
//#define ListView_SetItemPosition(hwndLV, i, x, y) \
//    (BOOL)SNDMSG((hwndLV), LVM_SETITEMPOSITION, (WPARAM)(int)(i), MAKELPARAM((x), (y)))
//#define ListView_GetItemPosition(hwndLV, i, ppt) \
//    (BOOL)SNDMSG((hwndLV), LVM_GETITEMPOSITION, (WPARAM)(int)(i), (LPARAM)(POINT *)(ppt))
//#define ListView_GetStringWidth(hwndLV, psz) \
//    (int)SNDMSG((hwndLV), LVM_GETSTRINGWIDTH, 0, (LPARAM)(LPCTSTR)(psz))
//#define ListView_HitTest(hwndLV, pinfo) \
//    (int)SNDMSG((hwndLV), LVM_HITTEST, 0, (LPARAM)(LV_HITTESTINFO *)(pinfo))
//#define ListView_EnsureVisible(hwndLV, i, fPartialOK) \
//    (BOOL)SNDMSG((hwndLV), LVM_ENSUREVISIBLE, (WPARAM)(int)(i), MAKELPARAM((fPartialOK), 0))
//#define ListView_Scroll(hwndLV, dx, dy) \
//    (BOOL)SNDMSG((hwndLV), LVM_SCROLL, (WPARAM)(int)dx, (LPARAM)(int)dy)
//#define ListView_RedrawItems(hwndLV, iFirst, iLast) \
//    (BOOL)SNDMSG((hwndLV), LVM_REDRAWITEMS, (WPARAM)(int)iFirst, (LPARAM)(int)iLast)
//#define ListView_Arrange(hwndLV, code) \
//    (BOOL)SNDMSG((hwndLV), LVM_ARRANGE, (WPARAM)(UINT)(code), 0L)
//#define ListView_EditLabel(hwndLV, i) \
//    (HWND)SNDMSG((hwndLV), LVM_EDITLABEL, (WPARAM)(int)(i), 0L)
//#define ListView_GetEditControl(hwndLV) \
//    (HWND)SNDMSG((hwndLV), LVM_GETEDITCONTROL, 0, 0L)
//#define ListView_GetColumn(hwnd, iCol, pcol) \
//    (BOOL)SNDMSG((hwnd), LVM_GETCOLUMN, (WPARAM)(int)(iCol), (LPARAM)(LV_COLUMN *)(pcol))
//#define ListView_SetColumn(hwnd, iCol, pcol) \
//    (BOOL)SNDMSG((hwnd), LVM_SETCOLUMN, (WPARAM)(int)(iCol), (LPARAM)(const LV_COLUMN *)(pcol))
//#define ListView_InsertColumn(hwnd, iCol, pcol) \
//    (int)SNDMSG((hwnd), LVM_INSERTCOLUMN, (WPARAM)(int)(iCol), (LPARAM)(const LV_COLUMN *)(pcol))
//#define ListView_DeleteColumn(hwnd, iCol) \
//    (BOOL)SNDMSG((hwnd), LVM_DELETECOLUMN, (WPARAM)(int)(iCol), 0)
//#define ListView_GetColumnWidth(hwnd, iCol) \
//    (int)SNDMSG((hwnd), LVM_GETCOLUMNWIDTH, (WPARAM)(int)(iCol), 0)
//#define ListView_SetColumnWidth(hwnd, iCol, cx) \
//    (BOOL)SNDMSG((hwnd), LVM_SETCOLUMNWIDTH, (WPARAM)(int)(iCol), MAKELPARAM((cx), 0))
//#define ListView_CreateDragImage(hwnd, i, lpptUpLeft) \
//    (HIMAGELIST)SNDMSG((hwnd), LVM_CREATEDRAGIMAGE, (WPARAM)(int)(i), (LPARAM)(LPPOINT)(lpptUpLeft))
//#define ListView_GetViewRect(hwnd, prc) \
//    (BOOL)SNDMSG((hwnd), LVM_GETVIEWRECT, 0, (LPARAM)(RECT *)(prc))
//#define ListView_GetTextColor(hwnd)  \
//   (COLORREF)SNDMSG((hwnd), LVM_GETTEXTCOLOR, 0, 0L)
//#define ListView_SetTextColor(hwnd, clrText) \
//    (BOOL)SNDMSG((hwnd), LVM_SETTEXTCOLOR, 0, (LPARAM)(COLORREF)(clrText))
//#define ListView_GetTextBkColor(hwnd)  \
//    (COLORREF)SNDMSG((hwnd), LVM_GETTEXTBKCOLOR, 0, 0L)
//#define ListView_SetTextBkColor(hwnd, clrTextBk) \
//    (BOOL)SNDMSG((hwnd), LVM_SETTEXTBKCOLOR, 0, (LPARAM)(COLORREF)(clrTextBk))
//#define ListView_GetTopIndex(hwndLV) \
//    (int)SNDMSG((hwndLV), LVM_GETTOPINDEX, 0, 0)
//#define ListView_GetCountPerPage(hwndLV) \
//    (int)SNDMSG((hwndLV), LVM_GETCOUNTPERPAGE, 0, 0)
//#define ListView_GetOrigin(hwndLV, ppt) \
//    (BOOL)SNDMSG((hwndLV), LVM_GETORIGIN, (WPARAM)0, (LPARAM)(POINT *)(ppt))
//#define ListView_Update(hwndLV, i) \
//    (BOOL)SNDMSG((hwndLV), LVM_UPDATE, (WPARAM)i, 0L)
//#define ListView_SetItemState(hwndLV, i, data, mask) \
//{ LV_ITEM _ms_lvi;\
//  _ms_lvi.stateMask = mask;\
//  _ms_lvi.state = data;\
//  SNDMSG((hwndLV), LVM_SETITEMSTATE, (WPARAM)i, (LPARAM)(LV_ITEM  *)&_ms_lvi);\
//}
//#define ListView_GetItemState(hwndLV, i, mask) \
//   (UINT)SNDMSG((hwndLV), LVM_GETITEMSTATE, (WPARAM)i, (LPARAM)mask)
//#define ListView_GetItemText(hwndLV, i, iSubItem_, pszText_, cchTextMax_) \
//{ LV_ITEM _ms_lvi;\
//  _ms_lvi.iSubItem = iSubItem_;\
// _ms_lvi.cchTextMax = cchTextMax_;\
//  _ms_lvi.pszText = pszText_;\
//  SNDMSG((hwndLV), LVM_GETITEMTEXT, (WPARAM)i, (LPARAM)(LV_ITEM  *)&_ms_lvi);\
//}
//#define ListView_SetItemText(hwndLV, i, iSubItem_, pszText_) \
//{ LV_ITEM _ms_lvi;\
//  _ms_lvi.iSubItem = iSubItem_;\
//  _ms_lvi.pszText = pszText_;\
//  SNDMSG((hwndLV), LVM_SETITEMTEXT, (WPARAM)i, (LPARAM)(LV_ITEM  *)&_ms_lvi);\
//}
//#define ListView_SetItemCount(hwndLV, cItems) \
//  SNDMSG((hwndLV), LVM_SETITEMCOUNT, (WPARAM)cItems, 0)
//#define ListView_SortItems(hwndLV, _pfnCompare, _lPrm) \
//  (BOOL)SNDMSG((hwndLV), LVM_SORTITEMS, (WPARAM)(LPARAM)_lPrm, \
//  (LPARAM)(PFNLVCOMPARE)_pfnCompare)
//#define ListView_SetItemPosition32(hwndLV, i, x, y) \
//{ POINT ptNewPos = {x,y}; \
//    SNDMSG((hwndLV), LVM_SETITEMPOSITION32, (WPARAM)(int)(i), (LPARAM)&ptNewPos); \
//}
//#define ListView_GetSelectedCount(hwndLV) \
//    (UINT)SNDMSG((hwndLV), LVM_GETSELECTEDCOUNT, 0, 0L)
//#define ListView_GetItemSpacing(hwndLV, fSmall) \
//        (DWORD)SNDMSG((hwndLV), LVM_GETITEMSPACING, fSmall, 0L)
//#define ListView_GetISearchString(hwndLV, lpsz) \
//        (BOOL)SNDMSG((hwndLV), LVM_GETISEARCHSTRING, 0, (LPARAM)(LPTSTR)lpsz)

alias int (*PFNLVCOMPARE)(LPARAM, LPARAM, LPARAM);

enum {
LVSIL_NORMAL            =0,
LVSIL_SMALL             =1,
LVSIL_STATE             =2
}

enum {
LVIF_TEXT               =0x0001,
LVIF_IMAGE              =0x0002,
LVIF_PARAM              =0x0004,
LVIF_STATE              =0x0008
}

enum {
LVIS_FOCUSED            =0x0001,
LVIS_SELECTED           =0x0002,
LVIS_CUT                =0x0004,
LVIS_DROPHILITED        =0x0008,
LVIS_OVERLAYMASK        =0x0F00,
LVIS_STATEIMAGEMASK     =0xF000
}

//#define INDEXTOSTATEIMAGEMASK(i) ((i) << 12)

struct LV_ITEMA { align (1):
    UINT mask;
    int iItem;
    int iSubItem;
    UINT state;
    UINT stateMask;
    LPSTR pszText;
    int cchTextMax;
    int iImage;
    LPARAM lParam;
} 

struct LV_ITEMW { align (1):
    UINT mask;
    int iItem;
    int iSubItem;
    UINT state;
    UINT stateMask;
    LPWSTR pszText;
    int cchTextMax;
    int iImage;
    LPARAM lParam;
} 

version (UNICODE) {
alias LV_ITEMW LV_ITEM;
} else {
alias LV_ITEMA LV_ITEM;
}

const LPWSTR LPSTR_TEXTCALLBACKW = ((LPWSTR)-1L);
const LPSTR LPSTR_TEXTCALLBACKA  = ((LPSTR)-1L);
version(UNICODE) {
alias LPSTR_TEXTCALLBACKW LPSTR_TEXTCALLBACK;
}else{
alias LPSTR_TEXTCALLBACKA LPSTR_TEXTCALLBACK;
}

enum { I_IMAGECALLBACK         = (-1) }

enum { 
LVNI_ALL                =0x0000,
LVNI_FOCUSED            =0x0001,
LVNI_SELECTED           =0x0002,
LVNI_CUT                =0x0004,
LVNI_DROPHILITED        =0x0008,

LVNI_ABOVE              =0x0100,
LVNI_BELOW              =0x0200,
LVNI_TOLEFT             =0x0400,
LVNI_TORIGHT            =0x0800
}

enum { 
LVFI_PARAM              =0x0001,
LVFI_STRING             =0x0002,
LVFI_PARTIAL            =0x0008,
LVFI_WRAP               =0x0020,
LVFI_NEARESTXY          =0x0040
}

struct LV_FINDINFOA { align (1):
    UINT flags;
    LPCSTR psz;
    LPARAM lParam;
    POINT pt;
    UINT vkDirection;
} 

struct LV_FINDINFOW { align (1):
    UINT flags;
    LPCWSTR psz;
    LPARAM lParam;
    POINT pt;
    UINT vkDirection;
}

version(UNICODE) {
alias LV_FINDINFOW LV_FINDINFO;
} else {
alias LV_FINDINFOA LV_FINDINFO;
}

enum {
LVIR_BOUNDS             =0,
LVIR_ICON               =1,
LVIR_LABEL              =2,
LVIR_SELECTBOUNDS       =3
}

enum {
LVHT_NOWHERE            =0x0001,
LVHT_ONITEMICON         =0x0002,
LVHT_ONITEMLABEL        =0x0004,
LVHT_ONITEMSTATEICON    =0x0008,
LVHT_ONITEM             =(LVHT_ONITEMICON | LVHT_ONITEMLABEL | LVHT_ONITEMSTATEICON),

LVHT_ABOVE              =0x0008,
LVHT_BELOW              =0x0010,
LVHT_TORIGHT            =0x0020,
LVHT_TOLEFT             =0x0040
}

struct LV_HITTESTINFO { align (1):
    POINT pt;
    UINT flags;
    int iItem;
}

enum {
LVA_DEFAULT             =0x0000,
LVA_ALIGNLEFT           =0x0001,
LVA_ALIGNTOP            =0x0002,
LVA_SNAPTOGRID          =0x0005
}

struct LV_COLUMNA { align (1):
    UINT mask;
    int fmt;
    int cx;
    LPSTR pszText;
    int cchTextMax;
    int iSubItem;
}

struct LV_COLUMNW { align (1):
    UINT mask;
    int fmt;
    int cx;
    LPWSTR pszText;
    int cchTextMax;
    int iSubItem;
}

version(UNICODE) {
alias LV_COLUMNW LV_COLUMN;
} else {
alias LV_COLUMNA LV_COLUMN;
}

enum {
LVCF_FMT                =0x0001,
LVCF_WIDTH              =0x0002,
LVCF_TEXT               =0x0004,
LVCF_SUBITEM            =0x0008
}

enum {
LVCFMT_LEFT             =0x0000,
LVCFMT_RIGHT            =0x0001,
LVCFMT_CENTER           =0x0002,
LVCFMT_JUSTIFYMASK      =0x0003
}

enum {
LVSCW_AUTOSIZE              =-1,
LVSCW_AUTOSIZE_USEHEADER    =-2
}

struct NM_LISTVIEW { align (1):
    NMHDR   hdr;
    int     iItem;
    int     iSubItem;
    UINT    uNewState;
    UINT    uOldState;
    UINT    uChanged;
    POINT   ptAction;
    LPARAM  lParam;
} 
alias NM_LISTVIEW * LPNM_LISTVIEW;

struct NM_CACHEHINT { align (1):
    NMHDR   hdr;
    int     iFrom;
    int     iTo;
} 
alias NM_CACHEHINT * LPNM_CACHEHINT,PNM_CACHEHINT;

struct NM_FINDITEM { align (1):
    NMHDR   hdr;
    int     iStart;
    LV_FINDINFO lvfi;
} 
alias NM_FINDITEM * LPNM_FINDITEM,PNM_FINDITEM;

enum {
LVN_ITEMCHANGING        =(LVN_FIRST-0),
LVN_ITEMCHANGED         =(LVN_FIRST-1),
LVN_INSERTITEM          =(LVN_FIRST-2),
LVN_DELETEITEM          =(LVN_FIRST-3),
LVN_DELETEALLITEMS      =(LVN_FIRST-4),
LVN_BEGINLABELEDITA     =(LVN_FIRST-5),
LVN_BEGINLABELEDITW     =(LVN_FIRST-75),
LVN_ENDLABELEDITA       =(LVN_FIRST-6),
LVN_ENDLABELEDITW       =(LVN_FIRST-76),
LVN_COLUMNCLICK         =(LVN_FIRST-8),
LVN_BEGINDRAG           =(LVN_FIRST-9),
LVN_BEGINRDRAG          =(LVN_FIRST-11),
LVN_ODCACHEHINT         =(LVN_FIRST-13),
LVN_ODFINDITEMA         =(LVN_FIRST-52),
LVN_ODFINDITEMW         =(LVN_FIRST-79),
LVN_GETDISPINFOA        =(LVN_FIRST-50),
LVN_GETDISPINFOW        =(LVN_FIRST-77),
LVN_SETDISPINFOA        =(LVN_FIRST-51),
LVN_SETDISPINFOW        =(LVN_FIRST-78),
LVN_KEYDOWN             =(LVN_FIRST-55)
}

version(UNICODE) {
alias LVN_ODFINDITEMW LVN_ODFINDITEM;
alias LVN_BEGINLABELEDITW LVN_BEGINLABELEDIT;
alias LVN_ENDLABELEDITW LVN_ENDLABELEDIT;
alias LVN_GETDISPINFOW LVN_GETDISPINFO;
alias LVN_SETDISPINFOW LVN_SETDISPINFO;
alias LV_DISPINFOW LV_DISPINFO;
} else {
alias LVN_ODFINDITEMA LVN_ODFINDITEM;
alias LVN_BEGINLABELEDITA LVN_BEGINLABELEDIT;
alias LVN_ENDLABELEDITA LVN_ENDLABELEDIT;
alias LVN_GETDISPINFOA LVN_GETDISPINFO;
alias LVN_SETDISPINFOA LVN_SETDISPINFO;
alias LV_DISPINFOA LV_DISPINFO;
}

enum { LVIF_DI_SETITEM         = 0x1000 }

struct LV_DISPINFOA { align (1):
    NMHDR hdr;
    LV_ITEMA item;
} 

struct LV_DISPINFOW { align (1):
    NMHDR hdr;
    LV_ITEMW item;
}

struct LV_KEYDOWN { align (1):
    NMHDR hdr;
    WORD wVKey;
    UINT flags;
}

//====== TREEVIEW CONTROL =====================================================
//#define WC_TREEVIEW             "SysTreeView"
const char[]  WC_TREEVIEWA = "SysTreeView32";
const wchar[] WC_TREEVIEWW = "SysTreeView32";

version (UNICODE) {
alias WC_TREEVIEWW WC_TREEVIEW;
} else {
alias WC_TREEVIEWA WC_TREEVIEW;
}

enum {
TVS_HASBUTTONS          =0x0001,
TVS_HASLINES            =0x0002,
TVS_LINESATROOT         =0x0004,
TVS_EDITLABELS          =0x0008,
TVS_DISABLEDRAGDROP     =0x0010,
TVS_SHOWSELALWAYS       =0x0020
}

struct _TREEITEM {}
alias _TREEITEM * HTREEITEM;

enum {
TVIF_TEXT               =0x0001,
TVIF_IMAGE              =0x0002,
TVIF_PARAM              =0x0004,
TVIF_STATE              =0x0008,
TVIF_HANDLE             =0x0010,
TVIF_SELECTEDIMAGE      =0x0020,
TVIF_CHILDREN           =0x0040
}

enum {
TVIS_FOCUSED            =0x0001,
TVIS_SELECTED           =0x0002,
TVIS_CUT                =0x0004,
TVIS_DROPHILITED        =0x0008,
TVIS_BOLD               =0x0010,
TVIS_EXPANDED           =0x0020,
TVIS_EXPANDEDONCE       =0x0040,

TVIS_OVERLAYMASK        =0x0F00,
TVIS_STATEIMAGEMASK     =0xF000,
TVIS_USERMASK           =0xF000
}


enum { I_CHILDRENCALLBACK  = (-1) }

struct TV_ITEMA { align (1):
    UINT      mask;
    HTREEITEM hItem;
    UINT      state;
    UINT      stateMask;
    LPSTR     pszText;
    int       cchTextMax;
    int       iImage;
    int       iSelectedImage;
    int       cChildren;
    LPARAM    lParam;
} 
alias TV_ITEMA * LPTV_ITEMA;

struct TV_ITEMW { align (1):
    UINT      mask;
    HTREEITEM hItem;
    UINT      state;
    UINT      stateMask;
    LPWSTR    pszText;
    int       cchTextMax;
    int       iImage;
    int       iSelectedImage;
    int       cChildren;
    LPARAM    lParam;
} 
alias TV_ITEMW * LPTV_ITEMW;

version (UNICODE) {
alias TV_ITEMW TV_ITEM;
alias LPTV_ITEMW LPTV_ITEM;
} else {
alias TV_ITEMA TV_ITEM;
alias LPTV_ITEMA LPTV_ITEM;
}

const HTREEITEM TVI_ROOT  = ((HTREEITEM)0xFFFF0000);
const HTREEITEM TVI_FIRST = ((HTREEITEM)0xFFFF0001);
const HTREEITEM TVI_LAST  = ((HTREEITEM)0xFFFF0002);
const HTREEITEM TVI_SORT  = ((HTREEITEM)0xFFFF0003);

struct TV_INSERTSTRUCTA { align (1):
    HTREEITEM hParent;
    HTREEITEM hInsertAfter;
    TV_ITEMA item;
} 
alias TV_INSERTSTRUCTA * LPTV_INSERTSTRUCTA;

struct TV_INSERTSTRUCTW { align (1):
    HTREEITEM hParent;
    HTREEITEM hInsertAfter;
    TV_ITEMW item;
} 
alias TV_INSERTSTRUCTW * LPTV_INSERTSTRUCTW;

version (UNICODE) {
alias TV_INSERTSTRUCTW TV_INSERTSTRUCT;
alias LPTV_INSERTSTRUCTW LPTV_INSERTSTRUCT;
} else {
alias TV_INSERTSTRUCTA TV_INSERTSTRUCT;
alias LPTV_INSERTSTRUCTA LPTV_INSERTSTRUCT;
}

enum {
TVM_INSERTITEMA         =(TV_FIRST + 0),
TVM_INSERTITEMW         =(TV_FIRST + 50),
TVM_DELETEITEM          =(TV_FIRST + 1),
TVM_EXPAND              =(TV_FIRST + 2),
TVM_GETITEMRECT         =(TV_FIRST + 4),
TVM_GETCOUNT            =(TV_FIRST + 5),
TVM_GETINDENT           =(TV_FIRST + 6),
TVM_SETINDENT           =(TV_FIRST + 7),
TVM_GETIMAGELIST        =(TV_FIRST + 8),
TVM_SETIMAGELIST        =(TV_FIRST + 9),
TVM_GETNEXTITEM         =(TV_FIRST + 10),
TVM_GETITEMA            =(TV_FIRST + 12),
TVM_GETITEMW            =(TV_FIRST + 62),
TVM_SELECTITEM          =(TV_FIRST + 11),
TVM_SETITEMA            =(TV_FIRST + 13),
TVM_SETITEMW            =(TV_FIRST + 63),
TVM_EDITLABELA          =(TV_FIRST + 14),
TVM_EDITLABELW          =(TV_FIRST + 65),
TVM_GETEDITCONTROL      =(TV_FIRST + 15),
TVM_GETVISIBLECOUNT     =(TV_FIRST + 16),
TVM_HITTEST             =(TV_FIRST + 17),
TVM_CREATEDRAGIMAGE     =(TV_FIRST + 18),
TVM_SORTCHILDREN        =(TV_FIRST + 19),
TVM_ENSUREVISIBLE       =(TV_FIRST + 20),
TVM_SORTCHILDRENCB      =(TV_FIRST + 21),
TVM_ENDEDITLABELNOW     =(TV_FIRST + 22),
TVM_GETISEARCHSTRINGA   =(TV_FIRST + 23),
TVM_GETISEARCHSTRINGW   =(TV_FIRST + 64)
}

version (UNICODE) {
alias TVM_GETITEMW TVM_GETITEM;
alias TVM_INSERTITEMW TVM_INSERTITEM;
alias TVM_SETITEMW TVM_SETITEM;
alias TVM_EDITLABELW TVM_EDITLABEL;
alias TVM_GETISEARCHSTRINGW TVM_GETISEARCHSTRING;
} else {
alias TVM_GETITEMA TVM_GETITEM;
alias TVM_INSERTITEMA TVM_INSERTITEM;
alias TVM_SETITEMA TVM_SETITEM;
alias TVM_EDITLABELA TVM_EDITLABEL;
alias TVM_GETISEARCHSTRINGA TVM_GETISEARCHSTRING;
}

enum {
TVE_COLLAPSE            =0x0001,
TVE_EXPAND              =0x0002,
TVE_TOGGLE              =0x0003,
TVE_COLLAPSERESET       =0x8000
}

//#define TreeView_InsertItem(hwnd, lpis) \
//    (HTREEITEM)SNDMSG((hwnd), TVM_INSERTITEM, 0, (LPARAM)(LPTV_INSERTSTRUCT)(lpis))
//#define TreeView_DeleteItem(hwnd, hitem) \
//    (BOOL)SNDMSG((hwnd), TVM_DELETEITEM, 0, (LPARAM)(HTREEITEM)(hitem))
//#define TreeView_DeleteAllItems(hwnd) \
//    (BOOL)SNDMSG((hwnd), TVM_DELETEITEM, 0, (LPARAM)TVI_ROOT)
//#define TreeView_Expand(hwnd, hitem, code) \
//    (BOOL)SNDMSG((hwnd), TVM_EXPAND, (WPARAM)code, (LPARAM)(HTREEITEM)(hitem))
//#define TreeView_GetItemRect(hwnd, hitem, prc, code) \
//    (*(HTREEITEM  *)prc = (hitem), (BOOL)SNDMSG((hwnd), TVM_GETITEMRECT, (WPARAM)(code), (LPARAM)(RECT *)(prc)))
//#define TreeView_GetCount(hwnd) \
//    (UINT)SNDMSG((hwnd), TVM_GETCOUNT, 0, 0)
//#define TreeView_GetIndent(hwnd) \
//    (UINT)SNDMSG((hwnd), TVM_GETINDENT, 0, 0)
//#define TreeView_SetIndent(hwnd, indent) \
//    (BOOL)SNDMSG((hwnd), TVM_SETINDENT, (WPARAM)indent, 0)
//#define TreeView_GetImageList(hwnd, iImage) \
//    (HIMAGELIST)SNDMSG((hwnd), TVM_GETIMAGELIST, iImage, 0)
//#define TreeView_SetImageList(hwnd, himl, iImage) \
//    (HIMAGELIST)SNDMSG((hwnd), TVM_SETIMAGELIST, iImage, (LPARAM)(UINT)(HIMAGELIST)(himl))
//#define TreeView_GetNextItem(hwnd, hitem, code) \
//    (HTREEITEM)SNDMSG((hwnd), TVM_GETNEXTITEM, (WPARAM)code, (LPARAM)(HTREEITEM)(hitem))
//#define TreeView_GetChild(hwnd, hitem)          TreeView_GetNextItem(hwnd, hitem, TVGN_CHILD)
//#define TreeView_GetNextSibling(hwnd, hitem)    TreeView_GetNextItem(hwnd, hitem, TVGN_NEXT)
//#define TreeView_GetPrevSibling(hwnd, hitem)    TreeView_GetNextItem(hwnd, hitem, TVGN_PREVIOUS)
//#define TreeView_GetParent(hwnd, hitem)         TreeView_GetNextItem(hwnd, hitem, TVGN_PARENT)
//#define TreeView_GetFirstVisible(hwnd)          TreeView_GetNextItem(hwnd, NULL,  TVGN_FIRSTVISIBLE)
//#define TreeView_GetNextVisible(hwnd, hitem)    TreeView_GetNextItem(hwnd, hitem, TVGN_NEXTVISIBLE)
//#define TreeView_GetPrevVisible(hwnd, hitem)    TreeView_GetNextItem(hwnd, hitem, TVGN_PREVIOUSVISIBLE)
//#define TreeView_GetSelection(hwnd)             TreeView_GetNextItem(hwnd, NULL,  TVGN_CARET)
//#define TreeView_GetDropHilight(hwnd)           TreeView_GetNextItem(hwnd, NULL,  TVGN_DROPHILITE)
//#define TreeView_GetRoot(hwnd)                  TreeView_GetNextItem(hwnd, NULL,  TVGN_ROOT)
//#define TreeView_Select(hwnd, hitem, code) \
//    (HTREEITEM)SNDMSG((hwnd), TVM_SELECTITEM, (WPARAM)code, (LPARAM)(HTREEITEM)(hitem))
//#define TreeView_SelectItem(hwnd, hitem)            TreeView_Select(hwnd, hitem, TVGN_CARET)
//#define TreeView_SelectDropTarget(hwnd, hitem)      TreeView_Select(hwnd, hitem, TVGN_DROPHILITE)
//#define TreeView_SelectSetFirstVisible(hwnd, hitem) TreeView_Select(hwnd, hitem, TVGN_FIRSTVISIBLE)
//#define TreeView_GetItem(hwnd, pitem) \
//    (BOOL)SNDMSG((hwnd), TVM_GETITEM, 0, (LPARAM)(TV_ITEM *)(pitem))
//#define TreeView_SetItem(hwnd, pitem) \
//    (BOOL)SNDMSG((hwnd), TVM_SETITEM, 0, (LPARAM)(const TV_ITEM *)(pitem))
//#define TreeView_EditLabel(hwnd, hitem) \
//    (HWND)SNDMSG((hwnd), TVM_EDITLABEL, 0, (LPARAM)(HTREEITEM)(hitem))
//#define TreeView_GetEditControl(hwnd) \
//    (HWND)SNDMSG((hwnd), TVM_GETEDITCONTROL, 0, 0)
//#define TreeView_GetVisibleCount(hwnd) \
//    (UINT)SNDMSG((hwnd), TVM_GETVISIBLECOUNT, 0, 0)
//#define TreeView_HitTest(hwnd, lpht) \
//    (HTREEITEM)SNDMSG((hwnd), TVM_HITTEST, 0, (LPARAM)(LPTV_HITTESTINFO)(lpht))
//#define TreeView_CreateDragImage(hwnd, hitem) \
//    (HIMAGELIST)SNDMSG((hwnd), TVM_CREATEDRAGIMAGE, 0, (LPARAM)(HTREEITEM)(hitem))
//#define TreeView_SortChildren(hwnd, hitem, recurse) \
//    (BOOL)SNDMSG((hwnd), TVM_SORTCHILDREN, (WPARAM)recurse, (LPARAM)(HTREEITEM)(hitem))
//#define TreeView_EnsureVisible(hwnd, hitem) \
//    (BOOL)SNDMSG((hwnd), TVM_ENSUREVISIBLE, 0, (LPARAM)(HTREEITEM)(hitem))
//#define TreeView_SortChildrenCB(hwnd, psort, recurse) \
//    (BOOL)SNDMSG((hwnd), TVM_SORTCHILDRENCB, (WPARAM)recurse, \
//    (LPARAM)(LPTV_SORTCB)(psort))
//#define TreeView_EndEditLabelNow(hwnd, fCancel) \
//    (BOOL)SNDMSG((hwnd), TVM_ENDEDITLABELNOW, (WPARAM)fCancel, 0)
//#define TreeView_GetISearchString(hwndTV, lpsz) \
//        (BOOL)SNDMSG((hwndTV), TVM_GETISEARCHSTRING, 0, (LPARAM)(LPTSTR)lpsz)

enum {
TVSIL_NORMAL            =0,
TVSIL_STATE             =2
}

enum {
TVGN_ROOT               =0x0000,
TVGN_NEXT               =0x0001,
TVGN_PREVIOUS           =0x0002,
TVGN_PARENT             =0x0003,
TVGN_CHILD              =0x0004,
TVGN_FIRSTVISIBLE       =0x0005,
TVGN_NEXTVISIBLE        =0x0006,
TVGN_PREVIOUSVISIBLE    =0x0007,
TVGN_DROPHILITE         =0x0008,
TVGN_CARET              =0x0009
}

struct TV_HITTESTINFO { align (1):
    POINT       pt;
    UINT        flags;
    HTREEITEM   hItem;
} 
alias TV_HITTESTINFO * LPTV_HITTESTINFO;

enum {
TVHT_NOWHERE            =0x0001,
TVHT_ONITEMICON         =0x0002,
TVHT_ONITEMLABEL        =0x0004,
TVHT_ONITEMINDENT       =0x0008,
TVHT_ONITEMBUTTON       =0x0010,
TVHT_ONITEMRIGHT        =0x0020,
TVHT_ONITEMSTATEICON    =0x0040,

TVHT_ABOVE              =0x0100,
TVHT_BELOW              =0x0200,
TVHT_TORIGHT            =0x0400,
TVHT_TOLEFT             =0x0800,

TVHT_ONITEM             =(TVHT_ONITEMICON | TVHT_ONITEMLABEL | TVHT_ONITEMSTATEICON)
}

alias int (*PFNTVCOMPARE)(LPARAM lParam1, LPARAM lParam2, LPARAM lParamSort);

struct TV_SORTCB { align (1):
        HTREEITEM       hParent;
        PFNTVCOMPARE    lpfnCompare;
        LPARAM          lParam;
} 
alias TV_SORTCB * LPTV_SORTCB;

struct NM_TREEVIEWA { align (1):
    NMHDR       hdr;
    UINT        action;
    TV_ITEMA    itemOld;
    TV_ITEMA    itemNew;
    POINT       ptDrag;
} 
alias NM_TREEVIEWA * LPNM_TREEVIEWA;

struct NM_TREEVIEWW { align (1):
    NMHDR       hdr;
    UINT        action;
    TV_ITEMW    itemOld;
    TV_ITEMW    itemNew;
    POINT       ptDrag;
} 
alias NM_TREEVIEWW * LPNM_TREEVIEWW;

version (UNICODE) {
alias NM_TREEVIEWW NM_TREEVIEW;
alias LPNM_TREEVIEWW LPNM_TREEVIEW;
} else {
alias NM_TREEVIEWA NM_TREEVIEW;
alias LPNM_TREEVIEWA LPNM_TREEVIEW;
}

enum {
TVN_SELCHANGINGA        =(TVN_FIRST-1),
TVN_SELCHANGINGW        =(TVN_FIRST-50),
TVN_SELCHANGEDA         =(TVN_FIRST-2),
TVN_SELCHANGEDW         =(TVN_FIRST-51),
TVN_GETDISPINFOA        =(TVN_FIRST-3),
TVN_GETDISPINFOW        =(TVN_FIRST-52),
TVN_SETDISPINFOA        =(TVN_FIRST-4),
TVN_SETDISPINFOW        =(TVN_FIRST-53),
TVN_ITEMEXPANDINGA      =(TVN_FIRST-5),
TVN_ITEMEXPANDINGW      =(TVN_FIRST-54),
TVN_ITEMEXPANDEDA       =(TVN_FIRST-6),
TVN_ITEMEXPANDEDW       =(TVN_FIRST-55),
TVN_BEGINDRAGA          =(TVN_FIRST-7),
TVN_BEGINDRAGW          =(TVN_FIRST-56),
TVN_BEGINRDRAGA         =(TVN_FIRST-8),
TVN_BEGINRDRAGW         =(TVN_FIRST-57),
TVN_DELETEITEMA         =(TVN_FIRST-9),
TVN_DELETEITEMW         =(TVN_FIRST-58),
TVN_BEGINLABELEDITA     =(TVN_FIRST-10),
TVN_BEGINLABELEDITW     =(TVN_FIRST-59),
TVN_ENDLABELEDITA       =(TVN_FIRST-11),
TVN_ENDLABELEDITW       =(TVN_FIRST-60),
TVN_KEYDOWN             =(TVN_FIRST-12)
}

enum {
TVC_UNKNOWN             =0x0000,
TVC_BYMOUSE             =0x0001,
TVC_BYKEYBOARD          =0x0002
}

enum { TVIF_DI_SETITEM         = 0x1000 }

struct TV_DISPINFOA { align (1):
    NMHDR hdr;
    TV_ITEMA item;
}

struct TV_DISPINFOW { align (1):
    NMHDR hdr;
    TV_ITEMW item;
}

struct TV_KEYDOWN { align (1):
    NMHDR hdr;
    WORD wVKey;
    UINT flags;
} 

version (UNICODE) {
alias TV_DISPINFOW TV_DISPINFO;
alias TVN_SELCHANGINGW TVN_SELCHANGING;
alias TVN_SELCHANGEDW TVN_SELCHANGED;
alias TVN_GETDISPINFOW TVN_GETDISPINFO;
alias TVN_SETDISPINFOW TVN_SETDISPINFO;
alias TVN_ITEMEXPANDINGW TVN_ITEMEXPANDING;
alias TVN_ITEMEXPANDEDW TVN_ITEMEXPANDED;
alias TVN_BEGINDRAGW TVN_BEGINDRAG;
alias TVN_BEGINRDRAGW TVN_BEGINRDRAG;
alias TVN_DELETEITEMW TVN_DELETEITEM;
alias TVN_BEGINLABELEDITW TVN_BEGINLABELEDIT;
alias TVN_ENDLABELEDITW TVN_ENDLABELEDIT;
} else {
alias TV_DISPINFOA TV_DISPINFO;
alias TVN_SELCHANGINGA TVN_SELCHANGING;
alias TVN_SELCHANGEDA TVN_SELCHANGED;
alias TVN_GETDISPINFOA TVN_GETDISPINFO;
alias TVN_SETDISPINFOA TVN_SETDISPINFO;
alias TVN_ITEMEXPANDINGA TVN_ITEMEXPANDING;
alias TVN_ITEMEXPANDEDA TVN_ITEMEXPANDED;
alias TVN_BEGINDRAGA TVN_BEGINDRAG;
alias TVN_BEGINRDRAGA TVN_BEGINRDRAG;
alias TVN_DELETEITEMA TVN_DELETEITEM;
alias TVN_BEGINLABELEDITA TVN_BEGINLABELEDIT;
alias TVN_ENDLABELEDITA TVN_ENDLABELEDIT;
}

//====== TAB CONTROL ==========================================================
//#define WC_TABCONTROL           "SysTabControl"
const char[]  WC_TABCONTROLA = "SysTabControl32";
const wchar[] WC_TABCONTROLW = "SysTabControl32";

version (UNICODE) {
alias WC_TABCONTROLW WC_TABCONTROL;
} else {
alias WC_TABCONTROLA WC_TABCONTROL;
}

enum {
TCS_FORCEICONLEFT       =0x0010,
TCS_FORCELABELLEFT      =0x0020,
TCS_TABS                =0x0000,
TCS_BUTTONS             =0x0100,
TCS_SINGLELINE          =0x0000,
TCS_MULTILINE           =0x0200,
TCS_RIGHTJUSTIFY        =0x0000,
TCS_FIXEDWIDTH          =0x0400,
TCS_RAGGEDRIGHT         =0x0800,
TCS_FOCUSONBUTTONDOWN   =0x1000,
TCS_OWNERDRAWFIXED      =0x2000,
TCS_TOOLTIPS            =0x4000,
TCS_FOCUSNEVER          =0x8000
}

enum { TCM_FIRST               = 0x1300 }

enum { 
TCM_GETIMAGELIST        =(TCM_FIRST + 2),
TCM_SETIMAGELIST        =(TCM_FIRST + 3),
TCM_GETITEMCOUNT        =(TCM_FIRST + 4),
TCM_GETITEMA            =(TCM_FIRST + 5),
TCM_GETITEMW            =(TCM_FIRST + 60),
TCM_SETITEMA            =(TCM_FIRST + 6),
TCM_SETITEMW            =(TCM_FIRST + 61),
TCM_DELETEITEM          =(TCM_FIRST + 8),
TCM_DELETEALLITEMS      =(TCM_FIRST + 9),
TCM_GETITEMRECT         =(TCM_FIRST + 10),
TCM_GETCURSEL           =(TCM_FIRST + 11),
TCM_SETCURSEL           =(TCM_FIRST + 12),
TCM_INSERTITEMA         =(TCM_FIRST + 7),
TCM_INSERTITEMW         =(TCM_FIRST + 62),
TCM_HITTEST             =(TCM_FIRST + 13),
TCM_SETITEMEXTRA        =(TCM_FIRST + 14),
TCM_ADJUSTRECT          =(TCM_FIRST + 40),
TCM_SETITEMSIZE         =(TCM_FIRST + 41),
TCM_REMOVEIMAGE         =(TCM_FIRST + 42),
TCM_SETPADDING          =(TCM_FIRST + 43),
TCM_GETROWCOUNT         =(TCM_FIRST + 44),
TCM_GETTOOLTIPS         =(TCM_FIRST + 45),
TCM_SETTOOLTIPS         =(TCM_FIRST + 46),
TCM_GETCURFOCUS         =(TCM_FIRST + 47),
TCM_SETCURFOCUS         =(TCM_FIRST + 48)
}

version (UNICODE) {
alias TCM_GETITEMW TCM_GETITEM;
alias TCM_SETITEMW TCM_SETITEM;
alias TCM_INSERTITEMW TCM_INSERTITEM;
} else {
alias TCM_GETITEMA TCM_GETITEM;
alias TCM_SETITEMA TCM_SETITEM;
alias TCM_INSERTITEMA TCM_INSERTITEM;
}

enum {
TCN_KEYDOWN             =(TCN_FIRST - 0),
TCN_SELCHANGE           =(TCN_FIRST - 1),
TCN_SELCHANGING         =(TCN_FIRST - 2)
}

enum {
TCIF_TEXT               =0x0001,
TCIF_IMAGE              =0x0002,
TCIF_RTLREADING         =0x0004,
TCIF_PARAM              =0x0008
}

struct TC_ITEMHEADERA { align (1):
    UINT mask;
    UINT lpReserved1;
    UINT lpReserved2;
    LPSTR pszText;
    int cchTextMax;
    int iImage;
}

struct TC_ITEMHEADERW { align (1):
    UINT mask;
    UINT lpReserved1;
    UINT lpReserved2;
    LPWSTR pszText;
    int cchTextMax;
    int iImage;
} 

version (UNICODE) {
alias TC_ITEMHEADERW TC_ITEMHEADER;
} else {
alias TC_ITEMHEADERA TC_ITEMHEADER;
}

struct TC_ITEMA { align (1):
    UINT mask;
    UINT lpReserved1;
    UINT lpReserved2;
    LPSTR pszText;
    int cchTextMax;
    int iImage;

    LPARAM lParam;
}

struct TC_ITEMW { align (1):
    UINT mask;
    UINT lpReserved1;
    UINT lpReserved2;
    LPWSTR pszText;
    int cchTextMax;
    int iImage;

    LPARAM lParam;
}

version (UNICODE) {
alias TC_ITEMW TC_ITEM;
} else {
alias TC_ITEMA TC_ITEM;
}

//#define TabCtrl_GetImageList(hwnd) \
//    (HIMAGELIST)SNDMSG((hwnd), TCM_GETIMAGELIST, 0, 0L)
//#define TabCtrl_SetImageList(hwnd, himl) \
//    (HIMAGELIST)SNDMSG((hwnd), TCM_SETIMAGELIST, 0, (LPARAM)(UINT)(HIMAGELIST)(himl))
//#define TabCtrl_GetItemCount(hwnd) \
//    (int)SNDMSG((hwnd), TCM_GETITEMCOUNT, 0, 0L)
//#define TabCtrl_GetItem(hwnd, iItem, pitem) \
//    (BOOL)SNDMSG((hwnd), TCM_GETITEM, (WPARAM)(int)iItem, (LPARAM)(TC_ITEM *)(pitem))
//#define TabCtrl_SetItem(hwnd, iItem, pitem) \
//    (BOOL)SNDMSG((hwnd), TCM_SETITEM, (WPARAM)(int)iItem, (LPARAM)(TC_ITEM *)(pitem))
//#define TabCtrl_InsertItem(hwnd, iItem, pitem)   \
//    (int)SNDMSG((hwnd), TCM_INSERTITEM, (WPARAM)(int)iItem, (LPARAM)(const TC_ITEM *)(pitem))
//#define TabCtrl_DeleteItem(hwnd, i) \
//    (BOOL)SNDMSG((hwnd), TCM_DELETEITEM, (WPARAM)(int)(i), 0L)
//#define TabCtrl_DeleteAllItems(hwnd) \
//    (BOOL)SNDMSG((hwnd), TCM_DELETEALLITEMS, 0, 0L)
//#define TabCtrl_GetItemRect(hwnd, i, prc) \
//    (BOOL)SNDMSG((hwnd), TCM_GETITEMRECT, (WPARAM)(int)(i), (LPARAM)(RECT *)(prc))
//#define TabCtrl_GetCurSel(hwnd) \
//    (int)SNDMSG((hwnd), TCM_GETCURSEL, 0, 0)
//#define TabCtrl_SetCurSel(hwnd, i) \
//    (int)SNDMSG((hwnd), TCM_SETCURSEL, (WPARAM)i, 0)
//#define TabCtrl_HitTest(hwndTC, pinfo) \
//    (int)SNDMSG((hwndTC), TCM_HITTEST, 0, (LPARAM)(TC_HITTESTINFO *)(pinfo))
//#define TabCtrl_SetItemExtra(hwndTC, cb) \
//    (BOOL)SNDMSG((hwndTC), TCM_SETITEMEXTRA, (WPARAM)(cb), 0L)
//#define TabCtrl_AdjustRect(hwnd, bLarger, prc) \
//    (int)SNDMSG(hwnd, TCM_ADJUSTRECT, (WPARAM)(BOOL)bLarger, (LPARAM)(RECT  *)prc)
//#define TabCtrl_SetItemSize(hwnd, x, y) \
//    (DWORD)SNDMSG((hwnd), TCM_SETITEMSIZE, 0, MAKELPARAM(x,y))
//#define TabCtrl_RemoveImage(hwnd, i) \
//       (void)SNDMSG((hwnd), TCM_REMOVEIMAGE, i, 0L)
//#define TabCtrl_SetPadding(hwnd,  cx, cy) \
//        (void)SNDMSG((hwnd), TCM_SETPADDING, 0, MAKELPARAM(cx, cy))
//#define TabCtrl_GetRowCount(hwnd) \
//        (int)SNDMSG((hwnd), TCM_GETROWCOUNT, 0, 0L)
//#define TabCtrl_GetToolTips(hwnd) \
//        (HWND)SNDMSG((hwnd), TCM_GETTOOLTIPS, 0, 0L)
//#define TabCtrl_SetToolTips(hwnd, hwndTT) \
//        (void)SNDMSG((hwnd), TCM_SETTOOLTIPS, (WPARAM)hwndTT, 0L)
//#define TabCtrl_GetCurFocus(hwnd) \
//    (int)SNDMSG((hwnd), TCM_GETCURFOCUS, 0, 0)
//#define TabCtrl_SetCurFocus(hwnd, i) \
//    SNDMSG((hwnd),TCM_SETCURFOCUS, i, 0)

enum {
TCHT_NOWHERE            =0x0001,
TCHT_ONITEMICON         =0x0002,
TCHT_ONITEMLABEL        =0x0004,
TCHT_ONITEM             =(TCHT_ONITEMICON | TCHT_ONITEMLABEL)
}

struct TC_HITTESTINFO { align (1):
    POINT pt;
    UINT flags;
} 
alias TC_HITTESTINFO * LPTC_HITTESTINFO;

struct TC_KEYDOWN { align (1):
    NMHDR hdr;
    WORD wVKey;
    UINT flags;
}



//====== ANIMATE CONTROL ======================================================


const char[]  ANIMATE_CLASSA = "SysAnimate32";
const wchar[] ANIMATE_CLASSW = "SysAnimate32";

enum {
ACS_CENTER              =0x0001,
ACS_TRANSPARENT         =0x0002,
ACS_AUTOPLAY            =0x0004
}

enum {
ACM_OPENA               =(WM_USER+100),
ACM_PLAY                =(WM_USER+101),
ACM_STOP                =(WM_USER+102),
ACM_OPENW               =(WM_USER+103)
}

version (UNICODE) {
alias ANIMATE_CLASSW ANIMATE_CLASS;
alias ACM_OPENW ACM_OPEN;
} else {
alias ANIMATE_CLASSA ANIMATE_CLASS;
alias ACM_OPENA ACM_OPEN;
}

enum {
ACN_START               =1,
ACN_STOP                =2
}

//#define Animate_Create(hwndP, id, dwStyle, hInstance)   \
//            CreateWindow(ANIMATE_CLASS, NULL,           \
//                dwStyle, 0, 0, 0, 0, hwndP, (HMENU)(id), hInstance, NULL)
//#define Animate_Open(hwnd, szName)          (BOOL)SNDMSG(hwnd, ACM_OPEN, 0, (LPARAM)(LPTSTR)(szName))
//#define Animate_Play(hwnd, from, to, rep)   (BOOL)SNDMSG(hwnd, ACM_PLAY, (WPARAM)(UINT)(rep), (LPARAM)MAKELONG(from, to))
//#define Animate_Stop(hwnd)                  (BOOL)SNDMSG(hwnd, ACM_STOP, 0, 0)
//#define Animate_Close(hwnd)                 Animate_Open(hwnd, NULL)
//#define Animate_Seek(hwnd, frame)           Animate_Play(hwnd, frame, frame, 1)

} // extern (Windows)
