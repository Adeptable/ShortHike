module winbase;

version( STANDALONE ) {
} else {
import windows;
}

import winnt;

/*
 * win32 (WINVER>=0x0400) port to D of  ......
 */

/************************************************************************
*                                                                       *
*   winbase.h -- This module defines the 32-Bit Windows Base APIs       *
*                                                                       *
*   Copyright (c) 1990-1996, Microsoft Corp. All rights reserved.       *
*                                                                       *
************************************************************************/

extern (Windows)
{

/*
 * Compatibility macros
 */
/*
#define DefineHandleTable(w)            ((w),TRUE)
#define LimitEmsPages(dw)
#define SetSwapAreaSize(w)              (w)
#define LockSegment(w)                  GlobalFix((HANDLE)(w))
#define UnlockSegment(w)                GlobalUnfix((HANDLE)(w))
#define GetCurrentTime()                GetTickCount()

#define Yield()
*/

//const HANDLE INVALID_HANDLE_VALUE = (HANDLE)-1;
const DWORD INVALID_FILE_SIZE = (DWORD)0xFFFFFFFF;

enum {
FILE_BEGIN           =0,
FILE_CURRENT         =1,
FILE_END             =2
}

const DWORD TIME_ZONE_ID_INVALID = (DWORD)0xFFFFFFFF;

enum : DWORD {
WAIT_FAILED         = (DWORD)0xFFFFFFFF,
WAIT_OBJECT_0       = (STATUS_WAIT_0 + 0 ),

WAIT_ABANDONED     =(STATUS_ABANDONED_WAIT_0 + 0 ),
WAIT_ABANDONED_0   =(STATUS_ABANDONED_WAIT_0 + 0 ),

WAIT_TIMEOUT                        =STATUS_TIMEOUT,
WAIT_IO_COMPLETION                  =STATUS_USER_APC,
STILL_ACTIVE                        =STATUS_PENDING,
EXCEPTION_ACCESS_VIOLATION          =STATUS_ACCESS_VIOLATION,
EXCEPTION_DATATYPE_MISALIGNMENT     =STATUS_DATATYPE_MISALIGNMENT,
EXCEPTION_BREAKPOINT                =STATUS_BREAKPOINT,
EXCEPTION_SINGLE_STEP               =STATUS_SINGLE_STEP,
EXCEPTION_ARRAY_BOUNDS_EXCEEDED     =STATUS_ARRAY_BOUNDS_EXCEEDED,
EXCEPTION_FLT_DENORMAL_OPERAND      =STATUS_FLOAT_DENORMAL_OPERAND,
EXCEPTION_FLT_DIVIDE_BY_ZERO        =STATUS_FLOAT_DIVIDE_BY_ZERO,
EXCEPTION_FLT_INEXACT_RESULT        =STATUS_FLOAT_INEXACT_RESULT,
EXCEPTION_FLT_INVALID_OPERATION     =STATUS_FLOAT_INVALID_OPERATION,
EXCEPTION_FLT_OVERFLOW              =STATUS_FLOAT_OVERFLOW,
EXCEPTION_FLT_STACK_CHECK           =STATUS_FLOAT_STACK_CHECK,
EXCEPTION_FLT_UNDERFLOW             =STATUS_FLOAT_UNDERFLOW,
EXCEPTION_INT_DIVIDE_BY_ZERO        =STATUS_INTEGER_DIVIDE_BY_ZERO,
EXCEPTION_INT_OVERFLOW              =STATUS_INTEGER_OVERFLOW,
EXCEPTION_PRIV_INSTRUCTION          =STATUS_PRIVILEGED_INSTRUCTION,
EXCEPTION_IN_PAGE_ERROR             =STATUS_IN_PAGE_ERROR,
EXCEPTION_ILLEGAL_INSTRUCTION       =STATUS_ILLEGAL_INSTRUCTION,
EXCEPTION_NONCONTINUABLE_EXCEPTION  =STATUS_NONCONTINUABLE_EXCEPTION,
EXCEPTION_STACK_OVERFLOW            =STATUS_STACK_OVERFLOW,
EXCEPTION_INVALID_DISPOSITION       =STATUS_INVALID_DISPOSITION,
EXCEPTION_GUARD_PAGE                =STATUS_GUARD_PAGE_VIOLATION,
EXCEPTION_INVALID_HANDLE            =STATUS_INVALID_HANDLE,
CONTROL_C_EXIT                      =STATUS_CONTROL_C_EXIT
}
/*
#define MoveMemory RtlMoveMemory
#define CopyMemory RtlCopyMemory
#define FillMemory RtlFillMemory
#define ZeroMemory RtlZeroMemory
*/

//
// File creation flags must start at the high end since they
// are combined with the attributes
//
enum : uint {
FILE_FLAG_WRITE_THROUGH         =0x80000000,
FILE_FLAG_OVERLAPPED            =0x40000000,
FILE_FLAG_NO_BUFFERING          =0x20000000,
FILE_FLAG_RANDOM_ACCESS         =0x10000000,
FILE_FLAG_SEQUENTIAL_SCAN       =0x08000000,
FILE_FLAG_DELETE_ON_CLOSE       =0x04000000,
FILE_FLAG_BACKUP_SEMANTICS      =0x02000000,
FILE_FLAG_POSIX_SEMANTICS       =0x01000000
}

enum {
CREATE_NEW          =1,
CREATE_ALWAYS       =2,
OPEN_EXISTING       =3,
OPEN_ALWAYS         =4,
TRUNCATE_EXISTING   =5
}

enum {
//
// Define possible return codes from the CopyFileEx callback routine
//
PROGRESS_CONTINUE   =0,
PROGRESS_CANCEL     =1,
PROGRESS_STOP       =2,
PROGRESS_QUIET      =3
}

enum {
//
// Define CopyFileEx callback routine state change values
//
CALLBACK_CHUNK_FINISHED         =0x00000000,
CALLBACK_STREAM_SWITCH          =0x00000001
}

enum {
//
// Define CopyFileEx option flags
//
COPY_FILE_FAIL_IF_EXISTS        =0x00000001,
COPY_FILE_RESTARTABLE           =0x00000002
}
//
// Define the NamedPipe definitions
//

enum {
//
// Define the dwOpenMode values for CreateNamedPipe
//
PIPE_ACCESS_INBOUND         =0x00000001,
PIPE_ACCESS_OUTBOUND        =0x00000002,
PIPE_ACCESS_DUPLEX          =0x00000003
}

enum {
//
// Define the Named Pipe End flags for GetNamedPipeInfo
//
PIPE_CLIENT_END             =0x00000000,
PIPE_SERVER_END             =0x00000001
}

enum {
//
// Define the dwPipeMode values for CreateNamedPipe
//
PIPE_WAIT                   =0x00000000,
PIPE_NOWAIT                 =0x00000001,
PIPE_READMODE_BYTE          =0x00000000,
PIPE_READMODE_MESSAGE       =0x00000002,
PIPE_TYPE_BYTE              =0x00000000,
PIPE_TYPE_MESSAGE           =0x00000004
}

//
// Define the well known values for CreateNamedPipe nMaxInstances
//

enum { PIPE_UNLIMITED_INSTANCES    = 255 }

//
// Define the Security Quality of Service bits to be passed
// into CreateFile
//
enum {
SECURITY_ANONYMOUS          =( SECURITY_IMPERSONATION_LEVEL.SecurityAnonymous      << 16 ),
SECURITY_IDENTIFICATION     =( SECURITY_IMPERSONATION_LEVEL.SecurityIdentification << 16 ),
SECURITY_IMPERSONATION      =( SECURITY_IMPERSONATION_LEVEL.SecurityImpersonation  << 16 ),
SECURITY_DELEGATION         =( SECURITY_IMPERSONATION_LEVEL.SecurityDelegation     << 16 ),

SECURITY_CONTEXT_TRACKING  =0x00040000,
SECURITY_EFFECTIVE_ONLY    =0x00080000,

SECURITY_SQOS_PRESENT      =0x00100000,
SECURITY_VALID_SQOS_FLAGS  =0x001F0000
}

//
//  File structures
//
struct OVERLAPPED {
    DWORD   Internal;
    DWORD   InternalHigh;
    DWORD   Offset;
    DWORD   OffsetHigh;
    HANDLE  hEvent;
} 
alias OVERLAPPED * LPOVERLAPPED;

/*
struct SECURITY_ATTRIBUTES {
    DWORD nLength;
    LPVOID lpSecurityDescriptor;
    BOOL bInheritHandle;
} 
*/
alias SECURITY_ATTRIBUTES * PSECURITY_ATTRIBUTES,LPSECURITY_ATTRIBUTES;


struct PROCESS_INFORMATION {
    HANDLE hProcess;
    HANDLE hThread;
    DWORD dwProcessId;
    DWORD dwThreadId;
} 
alias PROCESS_INFORMATION * PPROCESS_INFORMATION,LPPROCESS_INFORMATION;

//
//  File System time stamps are represented with the following structure:
//

struct FILETIME {
    DWORD dwLowDateTime;
    DWORD dwHighDateTime;
} 
alias FILETIME * PFILETIME,LPFILETIME;

//
// System time is represented with the following structure:
//
struct SYSTEMTIME {
    WORD wYear;
    WORD wMonth;
    WORD wDayOfWeek;
    WORD wDay;
    WORD wHour;
    WORD wMinute;
    WORD wSecond;
    WORD wMilliseconds;
} 
alias SYSTEMTIME * PSYSTEMTIME,LPSYSTEMTIME;

alias DWORD (*PTHREAD_START_ROUTINE)(LPVOID lpThreadParameter);
alias PTHREAD_START_ROUTINE LPTHREAD_START_ROUTINE;

alias VOID (*PFIBER_START_ROUTINE)(LPVOID lpFiberParameter);
alias PFIBER_START_ROUTINE LPFIBER_START_ROUTINE;

alias RTL_CRITICAL_SECTION CRITICAL_SECTION;
alias PRTL_CRITICAL_SECTION PCRITICAL_SECTION;
alias PRTL_CRITICAL_SECTION LPCRITICAL_SECTION;

alias RTL_CRITICAL_SECTION_DEBUG CRITICAL_SECTION_DEBUG;
alias PRTL_CRITICAL_SECTION_DEBUG PCRITICAL_SECTION_DEBUG;
alias PRTL_CRITICAL_SECTION_DEBUG LPCRITICAL_SECTION_DEBUG;

/*
#ifdef _X86_
typedef PLDT_ENTRY LPLDT_ENTRY;
#else
typedef LPVOID LPLDT_ENTRY;
#endif
*/

//alias MUTEX_MODIFY_STATE MUTANT_QUERY_STATE;
//alias MUTEX_ALL_ACCESS MUTANT_ALL_ACCESS;

//
// Serial provider type.
//

enum : uint  { SP_SERIALCOMM    =((DWORD)0x00000001) }

enum : uint  { 
//
// Provider SubTypes
//
PST_UNSPECIFIED      =((DWORD)0x00000000),
PST_RS232            =((DWORD)0x00000001),
PST_PARALLELPORT     =((DWORD)0x00000002),
PST_RS422            =((DWORD)0x00000003),
PST_RS423            =((DWORD)0x00000004),
PST_RS449            =((DWORD)0x00000005),
PST_MODEM            =((DWORD)0x00000006),
PST_FAX              =((DWORD)0x00000021),
PST_SCANNER          =((DWORD)0x00000022),
PST_NETWORK_BRIDGE   =((DWORD)0x00000100),
PST_LAT              =((DWORD)0x00000101),
PST_TCPIP_TELNET     =((DWORD)0x00000102),
PST_X25              =((DWORD)0x00000103)
}

enum : uint  { 
//
// Provider capabilities flags.
//
PCF_DTRDSR        =((DWORD)0x0001),
PCF_RTSCTS        =((DWORD)0x0002),
PCF_RLSD          =((DWORD)0x0004),
PCF_PARITY_CHECK  =((DWORD)0x0008),
PCF_XONXOFF       =((DWORD)0x0010),
PCF_SETXCHAR      =((DWORD)0x0020),
PCF_TOTALTIMEOUTS =((DWORD)0x0040),
PCF_INTTIMEOUTS   =((DWORD)0x0080),
PCF_SPECIALCHARS  =((DWORD)0x0100),
PCF_16BITMODE     =((DWORD)0x0200)
}

enum : uint  { 
//
// Comm provider settable parameters.
//
SP_PARITY         =((DWORD)0x0001),
SP_BAUD           =((DWORD)0x0002),
SP_DATABITS       =((DWORD)0x0004),
SP_STOPBITS       =((DWORD)0x0008),
SP_HANDSHAKING    =((DWORD)0x0010),
SP_PARITY_CHECK   =((DWORD)0x0020),
SP_RLSD           =((DWORD)0x0040)
}

enum :uint {
//
// Settable baud rates in the provider.
//
BAUD_075          =((DWORD)0x00000001),
BAUD_110          =((DWORD)0x00000002),
BAUD_134_5        =((DWORD)0x00000004),
BAUD_150          =((DWORD)0x00000008),
BAUD_300          =((DWORD)0x00000010),
BAUD_600          =((DWORD)0x00000020),
BAUD_1200         =((DWORD)0x00000040),
BAUD_1800         =((DWORD)0x00000080),
BAUD_2400         =((DWORD)0x00000100),
BAUD_4800         =((DWORD)0x00000200),
BAUD_7200         =((DWORD)0x00000400),
BAUD_9600         =((DWORD)0x00000800),
BAUD_14400        =((DWORD)0x00001000),
BAUD_19200        =((DWORD)0x00002000),
BAUD_38400        =((DWORD)0x00004000),
BAUD_56K          =((DWORD)0x00008000),
BAUD_128K         =((DWORD)0x00010000),
BAUD_115200       =((DWORD)0x00020000),
BAUD_57600        =((DWORD)0x00040000),
BAUD_USER         =((DWORD)0x10000000)
}

enum : WORD {
//
// Settable Data Bits
//
DATABITS_5        =((WORD)0x0001),
DATABITS_6        =((WORD)0x0002),
DATABITS_7        =((WORD)0x0004),
DATABITS_8        =((WORD)0x0008),
DATABITS_16       =((WORD)0x0010),
DATABITS_16X      =((WORD)0x0020)
}

enum : WORD {
//
// Settable Stop and Parity bits.
//
STOPBITS_10       =((WORD)0x0001),
STOPBITS_15       =((WORD)0x0002),
STOPBITS_20       =((WORD)0x0004),
PARITY_NONE       =((WORD)0x0100),
PARITY_ODD        =((WORD)0x0200),
PARITY_EVEN       =((WORD)0x0400),
PARITY_MARK       =((WORD)0x0800),
PARITY_SPACE      =((WORD)0x1000)
}

struct COMMPROP {
    WORD wPacketLength;
    WORD wPacketVersion;
    DWORD dwServiceMask;
    DWORD dwReserved1;
    DWORD dwMaxTxQueue;
    DWORD dwMaxRxQueue;
    DWORD dwMaxBaud;
    DWORD dwProvSubType;
    DWORD dwProvCapabilities;
    DWORD dwSettableParams;
    DWORD dwSettableBaud;
    WORD wSettableData;
    WORD wSettableStopParity;
    DWORD dwCurrentTxQueue;
    DWORD dwCurrentRxQueue;
    DWORD dwProvSpec1;
    DWORD dwProvSpec2;
    WCHAR wcProvChar[1];
} 
alias COMMPROP * LPCOMMPROP;

//
// Set dwProvSpec1 to COMMPROP_INITIALIZED to indicate that wPacketLength
// is valid before a call to GetCommProperties().
//
enum : uint { COMMPROP_INITIALIZED  = ((DWORD)0xE73CF52E) }

struct COMSTAT {
	/*
    DWORD fCtsHold : 1;
    DWORD fDsrHold : 1;
    DWORD fRlsdHold : 1;
    DWORD fXoffHold : 1;
    DWORD fXoffSent : 1;
    DWORD fEof : 1;
    DWORD fTxim : 1;
    DWORD fReserved : 25;
	 */
    DWORD bits;
    DWORD cbInQue;
    DWORD cbOutQue;
} 
alias COMSTAT * LPCOMSTAT;

enum {
//
// DTR Control Flow Values.
//
DTR_CONTROL_DISABLE    =0x00,
DTR_CONTROL_ENABLE     =0x01,
DTR_CONTROL_HANDSHAKE  =0x02
}

enum {
//
// RTS Control Flow Values
//
RTS_CONTROL_DISABLE    =0x00,
RTS_CONTROL_ENABLE     =0x01,
RTS_CONTROL_HANDSHAKE  =0x02,
RTS_CONTROL_TOGGLE     =0x03
}

struct DCB {
    DWORD DCBlength;      /* sizeof(DCB)                     */
    DWORD BaudRate;       /* Baudrate at which running       */

//	 DWORD fBinary: 1;     /* Binary Mode (skip EOF check)    */
//    DWORD fParity: 1;     /* Enable parity checking          */
//    DWORD fOutxCtsFlow:1; /* CTS handshaking on output       */
//    DWORD fOutxDsrFlow:1; /* DSR handshaking on output       */
//    DWORD fDtrControl:2;  /* DTR Flow control                */
//    DWORD fDsrSensitivity:1; /* DSR Sensitivity              */
//    DWORD fTXContinueOnXoff: 1; /* Continue TX when Xoff sent */
//    DWORD fOutX: 1;       /* Enable output X-ON/X-OFF        */
//    DWORD fInX: 1;        /* Enable input X-ON/X-OFF         */
//    DWORD fErrorChar: 1;  /* Enable Err Replacement          */
//    DWORD fNull: 1;       /* Enable Null stripping           */
//    DWORD fRtsControl:2;  /* Rts Flow control                */
//    DWORD fAbortOnError:1; /* Abort all reads and writes on Error */
//    DWORD fDummy2:17;     /* Reserved                        */
	DWORD bits;

    WORD wReserved;       /* Not currently used              */
    WORD XonLim;          /* Transmit X-ON threshold         */
    WORD XoffLim;         /* Transmit X-OFF threshold        */
    BYTE ByteSize;        /* Number of bits/byte, 4-8        */
    BYTE Parity;          /* 0-4=None,Odd,Even,Mark,Space    */
    BYTE StopBits;        /* 0,1,2 = 1, 1.5, 2               */
    char XonChar;         /* Tx and Rx X-ON character        */
    char XoffChar;        /* Tx and Rx X-OFF character       */
    char ErrorChar;       /* Error replacement char          */
    char EofChar;         /* End of Input character          */
    char EvtChar;         /* Received Event character        */
    WORD wReserved1;      /* Fill for now.                   */
} 
alias DCB * LPDCB;

struct COMMTIMEOUTS {
    DWORD ReadIntervalTimeout;          /* Maximum time between read chars. */
    DWORD ReadTotalTimeoutMultiplier;   /* Multiplier of characters.        */
    DWORD ReadTotalTimeoutConstant;     /* Constant in milliseconds.        */
    DWORD WriteTotalTimeoutMultiplier;  /* Multiplier of characters.        */
    DWORD WriteTotalTimeoutConstant;    /* Constant in milliseconds.        */
} 
alias COMMTIMEOUTS * LPCOMMTIMEOUTS;

struct COMMCONFIG {
    DWORD dwSize;               /* Size of the entire struct */
    WORD wVersion;              /* version of the structure */
    WORD wReserved;             /* alignment */
    DCB dcb;                    /* device control block */
    DWORD dwProviderSubType;    /* ordinal value for identifying
                                   provider-defined data structure format*/
    DWORD dwProviderOffset;     /* Specifies the offset of provider specific
                                   data field in bytes from the start */
    DWORD dwProviderSize;       /* size of the provider-specific data field */
    WCHAR wcProviderData[1];    /* provider-specific data */
} 
alias COMMCONFIG * LPCOMMCONFIG;

struct SYSTEM_INFO {
    union {
        DWORD dwOemId;          // Obsolete field...do not use
        struct {
            WORD wProcessorArchitecture;
            WORD wReserved;
        };
    };
    DWORD dwPageSize;
    LPVOID lpMinimumApplicationAddress;
    LPVOID lpMaximumApplicationAddress;
    DWORD dwActiveProcessorMask;
    DWORD dwNumberOfProcessors;
    DWORD dwProcessorType;
    DWORD dwAllocationGranularity;
    WORD wProcessorLevel;
    WORD wProcessorRevision;
} 
alias SYSTEM_INFO * LPSYSTEM_INFO;

//
//
//#define FreeModule(hLibModule) FreeLibrary((hLibModule))
//#define MakeProcInstance(lpProc,hInstance) (lpProc)
//#define FreeProcInstance(lpProc) (lpProc)

enum {
/* Global Memory Flags */
GMEM_FIXED          =0x0000,
GMEM_MOVEABLE       =0x0002,
GMEM_NOCOMPACT      =0x0010,
GMEM_NODISCARD      =0x0020,
GMEM_ZEROINIT       =0x0040,
GMEM_MODIFY         =0x0080,
GMEM_DISCARDABLE    =0x0100,
GMEM_NOT_BANKED     =0x1000,
GMEM_SHARE          =0x2000,
GMEM_DDESHARE       =0x2000,
GMEM_NOTIFY         =0x4000,
GMEM_LOWER          =GMEM_NOT_BANKED,
GMEM_VALID_FLAGS    =0x7F72,
GMEM_INVALID_HANDLE =0x8000,

GHND                =(GMEM_MOVEABLE | GMEM_ZEROINIT),
GPTR                =(GMEM_FIXED | GMEM_ZEROINIT)
}

/*
#define GlobalLRUNewest( h )    (HANDLE)(h)
#define GlobalLRUOldest( h )    (HANDLE)(h)
#define GlobalDiscard( h )      GlobalReAlloc( (h), 0, GMEM_MOVEABLE )
*/
enum {
/* Flags returned by GlobalFlags (in addition to GMEM_DISCARDABLE) */
GMEM_DISCARDED      =0x4000,
GMEM_LOCKCOUNT      =0x00FF
}

struct MEMORYSTATUS {
    DWORD dwLength;
    DWORD dwMemoryLoad;
    DWORD dwTotalPhys;
    DWORD dwAvailPhys;
    DWORD dwTotalPageFile;
    DWORD dwAvailPageFile;
    DWORD dwTotalVirtual;
    DWORD dwAvailVirtual;
} 
alias MEMORYSTATUS * LPMEMORYSTATUS;

enum { 
/* Local Memory Flags */
LMEM_FIXED          =0x0000,
LMEM_MOVEABLE       =0x0002,
LMEM_NOCOMPACT      =0x0010,
LMEM_NODISCARD      =0x0020,
LMEM_ZEROINIT       =0x0040,
LMEM_MODIFY         =0x0080,
LMEM_DISCARDABLE    =0x0F00,
LMEM_VALID_FLAGS    =0x0F72,
LMEM_INVALID_HANDLE =0x8000,
LHND                =(LMEM_MOVEABLE | LMEM_ZEROINIT),
LPTR                =(LMEM_FIXED | LMEM_ZEROINIT),
NONZEROLHND         =(LMEM_MOVEABLE),
NONZEROLPTR         =(LMEM_FIXED)
}

//#define LocalDiscard( h )   LocalReAlloc( (h), 0, LMEM_MOVEABLE )

enum {
/* Flags returned by LocalFlags (in addition to LMEM_DISCARDABLE) */
LMEM_DISCARDED      =0x4000,
LMEM_LOCKCOUNT      =0x00FF
}

enum {
//
// dwCreationFlag values
//
DEBUG_PROCESS               =0x00000001,
DEBUG_ONLY_THIS_PROCESS     =0x00000002,
CREATE_SUSPENDED            =0x00000004,
DETACHED_PROCESS            =0x00000008,
CREATE_NEW_CONSOLE          =0x00000010,

NORMAL_PRIORITY_CLASS       =0x00000020,
IDLE_PRIORITY_CLASS         =0x00000040,
HIGH_PRIORITY_CLASS         =0x00000080,
REALTIME_PRIORITY_CLASS     =0x00000100,

CREATE_NEW_PROCESS_GROUP    =0x00000200,
CREATE_UNICODE_ENVIRONMENT  =0x00000400,

CREATE_SEPARATE_WOW_VDM     =0x00000800,
CREATE_SHARED_WOW_VDM       =0x00001000,
CREATE_FORCEDOS             =0x00002000,

CREATE_DEFAULT_ERROR_MODE   =0x04000000,
CREATE_NO_WINDOW            =0x08000000,

PROFILE_USER                =0x10000000,
PROFILE_KERNEL              =0x20000000,
PROFILE_SERVER              =0x40000000,
}
enum {
THREAD_PRIORITY_LOWEST          =THREAD_BASE_PRIORITY_MIN,
THREAD_PRIORITY_BELOW_NORMAL    =(THREAD_PRIORITY_LOWEST+1),
THREAD_PRIORITY_NORMAL          =0,
THREAD_PRIORITY_HIGHEST         =THREAD_BASE_PRIORITY_MAX,
THREAD_PRIORITY_ABOVE_NORMAL    =(THREAD_PRIORITY_HIGHEST-1),
THREAD_PRIORITY_ERROR_RETURN    =(MAXLONG),
THREAD_PRIORITY_TIME_CRITICAL   =THREAD_BASE_PRIORITY_LOWRT,
THREAD_PRIORITY_IDLE            =THREAD_BASE_PRIORITY_IDLE
}

enum {
//
// Debug APIs
//
EXCEPTION_DEBUG_EVENT       =1,
CREATE_THREAD_DEBUG_EVENT   =2,
CREATE_PROCESS_DEBUG_EVENT  =3,
EXIT_THREAD_DEBUG_EVENT     =4,
EXIT_PROCESS_DEBUG_EVENT    =5,
LOAD_DLL_DEBUG_EVENT        =6,
UNLOAD_DLL_DEBUG_EVENT      =7,
OUTPUT_DEBUG_STRING_EVENT   =8,
RIP_EVENT                   =9
}

struct EXCEPTION_DEBUG_INFO {
    EXCEPTION_RECORD ExceptionRecord;
    DWORD dwFirstChance;
} 
alias EXCEPTION_DEBUG_INFO * LPEXCEPTION_DEBUG_INFO;

struct CREATE_THREAD_DEBUG_INFO {
    HANDLE hThread;
    LPVOID lpThreadLocalBase;
    LPTHREAD_START_ROUTINE lpStartAddress;
} 
alias CREATE_THREAD_DEBUG_INFO * LPCREATE_THREAD_DEBUG_INFO;

struct CREATE_PROCESS_DEBUG_INFO {
    HANDLE hFile;
    HANDLE hProcess;
    HANDLE hThread;
    LPVOID lpBaseOfImage;
    DWORD dwDebugInfoFileOffset;
    DWORD nDebugInfoSize;
    LPVOID lpThreadLocalBase;
    LPTHREAD_START_ROUTINE lpStartAddress;
    LPVOID lpImageName;
    WORD fUnicode;
} 
alias CREATE_PROCESS_DEBUG_INFO * LPCREATE_PROCESS_DEBUG_INFO;

struct EXIT_THREAD_DEBUG_INFO {
    DWORD dwExitCode;
} 
alias EXIT_THREAD_DEBUG_INFO * LPEXIT_THREAD_DEBUG_INFO;

struct EXIT_PROCESS_DEBUG_INFO {
    DWORD dwExitCode;
} 
alias EXIT_PROCESS_DEBUG_INFO * LPEXIT_PROCESS_DEBUG_INFO;

struct LOAD_DLL_DEBUG_INFO {
    HANDLE hFile;
    LPVOID lpBaseOfDll;
    DWORD dwDebugInfoFileOffset;
    DWORD nDebugInfoSize;
    LPVOID lpImageName;
    WORD fUnicode;
} 
alias LOAD_DLL_DEBUG_INFO * LPLOAD_DLL_DEBUG_INFO;

struct UNLOAD_DLL_DEBUG_INFO {
    LPVOID lpBaseOfDll;
} 
alias UNLOAD_DLL_DEBUG_INFO * LPUNLOAD_DLL_DEBUG_INFO;

struct OUTPUT_DEBUG_STRING_INFO {
    LPSTR lpDebugStringData;
    WORD fUnicode;
    WORD nDebugStringLength;
} 
alias OUTPUT_DEBUG_STRING_INFO * LPOUTPUT_DEBUG_STRING_INFO;

struct RIP_INFO {
    DWORD dwError;
    DWORD dwType;
} 
alias RIP_INFO * LPRIP_INFO;


struct DEBUG_EVENT {
    DWORD dwDebugEventCode;
    DWORD dwProcessId;
    DWORD dwThreadId;
    union u {
        EXCEPTION_DEBUG_INFO Exception;
        CREATE_THREAD_DEBUG_INFO CreateThread;
        CREATE_PROCESS_DEBUG_INFO CreateProcessInfo;
        EXIT_THREAD_DEBUG_INFO ExitThread;
        EXIT_PROCESS_DEBUG_INFO ExitProcess;
        LOAD_DLL_DEBUG_INFO LoadDll;
        UNLOAD_DLL_DEBUG_INFO UnloadDll;
        OUTPUT_DEBUG_STRING_INFO DebugString;
        RIP_INFO RipInfo;
    };
} 
alias DEBUG_EVENT * LPDEBUG_EVENT;

//alias PCONTEXT LPCONTEXT;
alias PEXCEPTION_RECORD LPEXCEPTION_RECORD;
//alias PEXCEPTION_POINTERS LPEXCEPTION_POINTERS;

enum { 
DRIVE_UNKNOWN     =0,
DRIVE_NO_ROOT_DIR =1,
DRIVE_REMOVABLE   =2,
DRIVE_FIXED       =3,
DRIVE_REMOTE      =4,
DRIVE_CDROM       =5,
DRIVE_RAMDISK     =6
}


//GetFreeSpace(w)                 (0x100000L)

enum {
FILE_TYPE_UNKNOWN   =0x0000,
FILE_TYPE_DISK      =0x0001,
FILE_TYPE_CHAR      =0x0002,
FILE_TYPE_PIPE      =0x0003,
FILE_TYPE_REMOTE    =0x8000
}


enum : DWORD {
STD_INPUT_HANDLE    =(DWORD)-10,
STD_OUTPUT_HANDLE   =(DWORD)-11,
STD_ERROR_HANDLE      =(DWORD)-12
}

enum {
NOPARITY            =0,
ODDPARITY           =1,
EVENPARITY          =2,
MARKPARITY          =3,
SPACEPARITY         =4
}

enum {
ONESTOPBIT          =0,
ONE5STOPBITS        =1,
TWOSTOPBITS         =2
}

enum : uint {
IGNORE              =0 ,      // Ignore signal
INFINITE            =0xFFFFFFFF  // Infinite timeout
}

enum {
//
// Baud rates at which the communication device operates
//
CBR_110             =110,
CBR_300             =300,
CBR_600             =600,
CBR_1200            =1200,
CBR_2400            =2400,
CBR_4800            =4800,
CBR_9600            =9600,
CBR_14400           =14400,
CBR_19200           =19200,
CBR_38400           =38400,
CBR_56000           =56000,
CBR_57600           =57600,
CBR_115200          =115200,
CBR_128000          =128000,
CBR_256000          =256000
}

enum {
//
// Error Flags
//
CE_RXOVER           =0x0001,  // Receive Queue overflow
CE_OVERRUN          =0x0002,  // Receive Overrun Error
CE_RXPARITY         =0x0004,  // Receive Parity Error
CE_FRAME            =0x0008,  // Receive Framing error
CE_BREAK            =0x0010,  // Break Detected
CE_TXFULL           =0x0100,  // TX Queue is full
CE_PTO              =0x0200,  // LPTx Timeout
CE_IOE              =0x0400,// LPTx I/O Error
CE_DNS              =0x0800, // LPTx Device not selected
CE_OOP              =0x1000,  // LPTx Out-Of-Paper
CE_MODE             =0x8000  // Requested mode unsupported
}

enum {
IE_BADID            =(-1),    // Invalid or unsupported id
IE_OPEN             =(-2),    // Device Already Open
IE_NOPEN            =(-3),    // Device Not Open
IE_MEMORY           =(-4),    // Unable to allocate queues
IE_DEFAULT          =(-5),    // Error in default parameters
IE_HARDWARE         =(-10),   // Hardware Not Present
IE_BYTESIZE         =(-11),   // Illegal Byte Size
IE_BAUDRATE         =(-12)   // Unsupported BaudRate
}

enum {
//
// Events
//
EV_RXCHAR           =0x0001,  // Any Character received
EV_RXFLAG           =0x0002,  // Received certain character
EV_TXEMPTY          =0x0004,  // Transmitt Queue Empty
EV_CTS              =0x0008,  // CTS changed state
EV_DSR              =0x0010,  // DSR changed state
EV_RLSD             =0x0020,  // RLSD changed state
EV_BREAK            =0x0040,  // BREAK received
EV_ERR              =0x0080,  // Line status error occurred
EV_RING             =0x0100,  // Ring signal detected
EV_PERR             =0x0200,  // Printer error occured
EV_RX80FULL         =0x0400,  // Receive buffer is 80 percent full
EV_EVENT1           =0x0800,  // Provider specific event 1
EV_EVENT2           =0x1000  // Provider specific event 2
}

enum {
//
// Escape Functions
//
SETXOFF             =1,       // Simulate XOFF received
SETXON              =2,       // Simulate XON received
SETRTS              =3,       // Set RTS high
CLRRTS              =4,       // Set RTS low
SETDTR              =5,       // Set DTR high
CLRDTR              =6 ,      // Set DTR low
RESETDEV            =7,       // Reset device if possible
SETBREAK            =8,       // Set the device break line.
CLRBREAK            =9       // Clear the device break line.
}

enum {
//
// PURGE function flags.
//
PURGE_TXABORT       =0x0001,  // Kill the pending/current writes to the comm port.
PURGE_RXABORT       =0x0002,  // Kill the pending/current reads to the comm port.
PURGE_TXCLEAR       =0x0004,  // Kill the transmit queue if there.
PURGE_RXCLEAR       =0x0008  // Kill the typeahead buffer if there.
}

enum { LPTx                =0x80 }    // Set if ID is for LPT device

enum : DWORD { 
//
// Modem Status Flags
//
MS_CTS_ON           =((DWORD)0x0010),
MS_DSR_ON           =((DWORD)0x0020),
MS_RING_ON          =((DWORD)0x0040),
MS_RLSD_ON          =((DWORD)0x0080)
}

enum {
//
// WaitSoundState() Constants
//
S_QUEUEEMPTY        =0,
S_THRESHOLD         =1,
S_ALLTHRESHOLD      =2
}

enum {
//
// Accent Modes
//
S_NORMAL      =0,
S_LEGATO      =1,
S_STACCATO    =2
}

enum {
//
// SetSoundNoise() Sources
//
S_PERIOD512   =0,     // Freq = N/512 high pitch, less coarse hiss
S_PERIOD1024  =1,     // Freq = N/1024
S_PERIOD2048  =2,     // Freq = N/2048 low pitch, more coarse hiss
S_PERIODVOICE =3,     // Source is frequency from voice channel (3)
S_WHITE512    =4,     // Freq = N/512 high pitch, less coarse hiss
S_WHITE1024   =5,     // Freq = N/1024
S_WHITE2048   =6,     // Freq = N/2048 low pitch, more coarse hiss
S_WHITEVOICE  =7,     // Source is frequency from voice channel (3)

S_SERDVNA     =(-1),  // Device not available
S_SEROFM      =(-2),  // Out of memory
S_SERMACT     =(-3),  // Music active
S_SERQFUL     =(-4),  // Queue full
S_SERBDNT     =(-5),  // Invalid note
S_SERDLN      =(-6),  // Invalid note length
S_SERDCC      =(-7),  // Invalid note count
S_SERDTP      =(-8),  // Invalid tempo
S_SERDVL      =(-9) , // Invalid volume
S_SERDMD      =(-10), // Invalid mode
S_SERDSH      =(-11), // Invalid shape
S_SERDPT      =(-12), // Invalid pitch
S_SERDFQ      =(-13), // Invalid frequency
S_SERDDR      =(-14), // Invalid duration
S_SERDSR      =(-15), // Invalid source
S_SERDST      =(-16) // Invalid state
}

enum : uint {
NMPWAIT_WAIT_FOREVER            =0xffffffff,
NMPWAIT_NOWAIT                  =0x00000001,
NMPWAIT_USE_DEFAULT_WAIT        =0x00000000
}

enum {
FS_CASE_IS_PRESERVED            =FILE_CASE_PRESERVED_NAMES,
FS_CASE_SENSITIVE               =FILE_CASE_SENSITIVE_SEARCH,
FS_UNICODE_STORED_ON_DISK       =FILE_UNICODE_ON_DISK,
FS_PERSISTENT_ACLS              =FILE_PERSISTENT_ACLS,
FS_VOL_IS_COMPRESSED            =FILE_VOLUME_IS_COMPRESSED,
FS_FILE_COMPRESSION             =FILE_FILE_COMPRESSION
}

enum {
FILE_MAP_COPY       =SECTION_QUERY,
FILE_MAP_WRITE      =SECTION_MAP_WRITE,
FILE_MAP_READ       =SECTION_MAP_READ,
FILE_MAP_ALL_ACCESS =SECTION_ALL_ACCESS
}

enum {
OF_READ             =0x00000000,
OF_WRITE            =0x00000001,
OF_READWRITE        =0x00000002,
OF_SHARE_COMPAT     =0x00000000,
OF_SHARE_EXCLUSIVE  =0x00000010,
OF_SHARE_DENY_WRITE =0x00000020,
OF_SHARE_DENY_READ  =0x00000030,
OF_SHARE_DENY_NONE  =0x00000040,
OF_PARSE            =0x00000100,
OF_DELETE           =0x00000200,
OF_VERIFY           =0x00000400,
OF_CANCEL           =0x00000800,
OF_CREATE           =0x00001000,
OF_PROMPT           =0x00002000,
OF_EXIST            =0x00004000,
OF_REOPEN           =0x00008000
}

enum { OFS_MAXPATHNAME  = 128 }
struct OFSTRUCT {
    BYTE cBytes;
    BYTE fFixedDisk;
    WORD nErrCode;
    WORD Reserved1;
    WORD Reserved2;
    CHAR szPathName[OFS_MAXPATHNAME];
} 
alias OFSTRUCT * LPOFSTRUCT,POFSTRUCT;
/*
//
// The MS-MIPS and Alpha compilers support intrinsic functions for interlocked
// increment, decrement, and exchange.
//

#if (defined(_M_MRX000) || defined(_M_ALPHA) || (defined(_M_PPC) && (_MSC_VER >= 1000))) && !defined(RC_INVOKED)

#define InterlockedIncrement _InterlockedIncrement
#define InterlockedDecrement _InterlockedDecrement
#define InterlockedExchange _InterlockedExchange
#define InterlockedExchangeAdd _InterlockedExchangeAdd
#define InterlockedCompareExchange _InterlockedCompareExchange

LONG
WINAPI
InterlockedIncrement(
    LPLONG lpAddend
    );

LONG
WINAPI
InterlockedDecrement(
    LPLONG lpAddend
    );

LONG
WINAPI
InterlockedExchange(
    LPLONG Target,
    LONG Value
    );

PVOID
WINAPI
InterlockedCompareExchange (
    PVOID *Destination,
    PVOID Exchange,
    PVOID Comperand
    );

LONG
WINAPI
InterlockedExchangeAdd(
    LPLONG Addend,
    LONG Value
    );

#pragma intrinsic(_InterlockedIncrement)
#pragma intrinsic(_InterlockedDecrement)
#pragma intrinsic(_InterlockedExchange)
#pragma intrinsic(_InterlockedCompareExchange)
#pragma intrinsic(_InterlockedExchangeAdd)

#else

#ifndef _NTOS_

WINBASEAPI
LONG
WINAPI
InterlockedIncrement(
    LPLONG lpAddend
    );

WINBASEAPI
LONG
WINAPI
InterlockedDecrement(
    LPLONG lpAddend
    );

WINBASEAPI
LONG
WINAPI
InterlockedExchange(
    LPLONG Target,
    LONG Value
    );

WINBASEAPI
LONG
WINAPI
InterlockedExchangeAdd(
    LPLONG Addend,
    LONG Value
    );

WINBASEAPI
PVOID
WINAPI
InterlockedCompareExchange (
    PVOID *Destination,
    PVOID Exchange,
    PVOID Comperand
    );
*/
//#endif /* NT_INCLUDED */
//#endif

LONG InterlockedIncrement(LPLONG lpAddend);
LONG InterlockedDecrement(LPLONG lpAddend);
LONG InterlockedExchange(LPLONG Target,LONG Value);
LONG InterlockedExchangeAdd(LPLONG Addend,LONG Value);
PVOID InterlockedCompareExchange (PVOID *Destination,PVOID Exchange,PVOID Comperand);


BOOL FreeResource(HGLOBAL hResData);
LPVOID LockResource(HGLOBAL hResData);

//#define UnlockResource(hResData) ((hResData), 0)
enum { MAXINTATOM  = 0xC000 }
LPTSTR MAKEINTATOM( int i) { return (LPTSTR)((DWORD)((WORD)(i))); }
//#define INVALID_ATOM ((ATOM)0)

//int WinMain(HINSTANCE hInstance,HINSTANCE hPrevInstance,LPSTR lpCmdLine,int nShowCmd);

BOOL FreeLibrary(HMODULE hLibModule);
VOID FreeLibraryAndExitThread(HMODULE hLibModule,DWORD dwExitCode);
BOOL DisableThreadLibraryCalls(HMODULE hLibModule);
version (STANDALONE) {
FARPROC GetProcAddress(HMODULE hModule,LPCSTR lpProcName);
}
DWORD GetVersion( );
HGLOBAL GlobalAlloc(UINT uFlags,DWORD dwBytes);
HGLOBAL GlobalReAlloc(HGLOBAL hMem,DWORD dwBytes,UINT uFlags);
DWORD GlobalSize(HGLOBAL hMem);
UINT GlobalFlags(HGLOBAL hMem);
LPVOID GlobalLock(HGLOBAL hMem);

//!!!MWH My version  win31 = DWORD WINAPI GlobalHandle(UINT)
HGLOBAL GlobalHandle(LPCVOID pMem);
BOOL GlobalUnlock(HGLOBAL hMem);
HGLOBAL GlobalFree(HGLOBAL hMem);
UINT GlobalCompact(DWORD dwMinFree);
VOID GlobalFix(HGLOBAL hMem);
VOID GlobalUnfix(HGLOBAL hMem);
LPVOID GlobalWire(HGLOBAL hMem);
BOOL GlobalUnWire(HGLOBAL hMem);
VOID GlobalMemoryStatus(LPMEMORYSTATUS lpBuffer);
HLOCAL LocalAlloc(UINT uFlags,UINT uBytes);
HLOCAL LocalReAlloc(HLOCAL hMem,UINT uBytes,UINT uFlags);
LPVOID LocalLock(HLOCAL hMem);
HLOCAL LocalHandle(LPCVOID pMem);
BOOL LocalUnlock(HLOCAL hMem);
UINT LocalSize(HLOCAL hMem);
UINT LocalFlags(HLOCAL hMem);
HLOCAL LocalFree(HLOCAL hMem);
UINT LocalShrink(HLOCAL hMem,UINT cbNewSize);
UINT LocalCompact(UINT uMinFree);
BOOL FlushInstructionCache(HANDLE hProcess,LPCVOID lpBaseAddress,DWORD dwSize);
LPVOID VirtualAlloc(LPVOID lpAddress,DWORD dwSize,DWORD flAllocationType,DWORD flProtect);
BOOL VirtualFree(LPVOID lpAddress,DWORD dwSize,DWORD dwFreeType);
BOOL VirtualProtect(LPVOID lpAddress,DWORD dwSize,DWORD flNewProtect,PDWORD lpflOldProtect);
DWORD VirtualQuery( LPCVOID lpAddress,PMEMORY_BASIC_INFORMATION lpBuffer,DWORD dwLength);
LPVOID VirtualAllocEx(HANDLE hProcess,LPVOID lpAddress,DWORD dwSize,DWORD flAllocationType,DWORD flProtect);
BOOL VirtualFreeEx(HANDLE hProcess,LPVOID lpAddress,DWORD dwSize,DWORD dwFreeType);
BOOL VirtualProtectEx(HANDLE hProcess,LPVOID lpAddress,DWORD dwSize,DWORD flNewProtect,PDWORD lpflOldProtect);
DWORD VirtualQueryEx(HANDLE hProcess,LPCVOID lpAddress,PMEMORY_BASIC_INFORMATION lpBuffer,DWORD dwLength);
HANDLE HeapCreate(DWORD flOptions,DWORD dwInitialSize,DWORD dwMaximumSize);
BOOL HeapDestroy(HANDLE hHeap);
LPVOID HeapAlloc(HANDLE hHeap,DWORD dwFlags,DWORD dwBytes);
LPVOID HeapReAlloc(HANDLE hHeap,DWORD dwFlags,LPVOID lpMem,DWORD dwBytes);
BOOL HeapFree(HANDLE hHeap,DWORD dwFlags,LPVOID lpMem);
DWORD HeapSize(HANDLE hHeap,DWORD dwFlags,LPCVOID lpMem);
BOOL HeapValidate(HANDLE hHeap,DWORD dwFlags,LPCVOID lpMem);
UINT HeapCompact(HANDLE hHeap,DWORD dwFlags);
HANDLE GetProcessHeap( );
DWORD GetProcessHeaps(DWORD NumberOfHeaps,PHANDLE ProcessHeaps);

struct PROCESS_HEAP_ENTRY {
    PVOID lpData;
    DWORD cbData;
    BYTE cbOverhead;
    BYTE iRegionIndex;
    WORD wFlags;
    union {
        struct Block {
            HANDLE hMem;
            DWORD dwReserved[ 3 ];
        } ;
        struct Region {
            DWORD dwCommittedSize;
            DWORD dwUnCommittedSize;
            LPVOID lpFirstBlock;
            LPVOID lpLastBlock;
        } ;
    };
} 
alias PROCESS_HEAP_ENTRY * LPPROCESS_HEAP_ENTRY,PPROCESS_HEAP_ENTRY;

enum {
PROCESS_HEAP_REGION             =0x0001,
PROCESS_HEAP_UNCOMMITTED_RANGE  =0x0002,
PROCESS_HEAP_ENTRY_BUSY         =0x0004,
PROCESS_HEAP_ENTRY_MOVEABLE     =0x0010,
PROCESS_HEAP_ENTRY_DDESHARE     =0x0020
}

BOOL HeapLock(HANDLE hHeap);
BOOL HeapUnlock(HANDLE hHeap);
BOOL HeapWalk(HANDLE hHeap,LPPROCESS_HEAP_ENTRY lpEntry);

enum {
// GetBinaryType return values.
SCS_32BIT_BINARY    =0,
SCS_DOS_BINARY      =1,
SCS_WOW_BINARY      =2,
SCS_PIF_BINARY      =3,
SCS_POSIX_BINARY    =4,
SCS_OS216_BINARY    =5
}

BOOL GetBinaryTypeA(LPCSTR lpApplicationName,LPDWORD lpBinaryType);
BOOL GetBinaryTypeW(LPCWSTR lpApplicationName,LPDWORD lpBinaryType);

DWORD GetShortPathNameA(LPCSTR lpszLongPath,LPSTR  lpszShortPath,DWORD    cchBuffer);
DWORD GetShortPathNameW(LPCWSTR lpszLongPath,LPWSTR  lpszShortPath,DWORD    cchBuffer);

BOOL GetProcessAffinityMask(HANDLE hProcess,LPDWORD lpProcessAffinityMask,LPDWORD lpSystemAffinityMask);
BOOL SetProcessAffinityMask(HANDLE hProcess,DWORD dwProcessAffinityMask);
BOOL GetProcessTimes(HANDLE hProcess,LPFILETIME lpCreationTime,LPFILETIME lpExitTime,LPFILETIME lpKernelTime,LPFILETIME lpUserTime);
BOOL GetProcessWorkingSetSize(HANDLE hProcess,LPDWORD lpMinimumWorkingSetSize,LPDWORD lpMaximumWorkingSetSize);
BOOL SetProcessWorkingSetSize(HANDLE hProcess,DWORD dwMinimumWorkingSetSize,DWORD dwMaximumWorkingSetSize);
HANDLE OpenProcess(DWORD dwDesiredAccess,BOOL bInheritHandle,DWORD dwProcessId);
HANDLE GetCurrentProcess();
DWORD GetCurrentProcessId();
VOID ExitProcess(UINT uExitCode);

BOOL TerminateProcess(HANDLE hProcess,UINT uExitCode);
BOOL GetExitCodeProcess(HANDLE hProcess,LPDWORD lpExitCode);
VOID FatalExit(int ExitCode);

//// !!!! looks like a bug to me MJW !!!!
LPSTR GetEnvironmentStrings();
LPWSTR GetEnvironmentStringsW();

BOOL FreeEnvironmentStringsA(LPSTR);
BOOL FreeEnvironmentStringsW(LPWSTR);

VOID RaiseException(DWORD dwExceptionCode,DWORD dwExceptionFlags,DWORD nNumberOfArguments,DWORD *lpArguments);
/*
LONG
UnhandledExceptionFilter(
    struct _EXCEPTION_POINTERS *ExceptionInfo
    );

typedef LONG (WINAPI *PTOP_LEVEL_EXCEPTION_FILTER)(
    struct _EXCEPTION_POINTERS *ExceptionInfo
    );
typedef PTOP_LEVEL_EXCEPTION_FILTER LPTOP_LEVEL_EXCEPTION_FILTER;

WINBASEAPI
LPTOP_LEVEL_EXCEPTION_FILTER
WINAPI
SetUnhandledExceptionFilter(
    LPTOP_LEVEL_EXCEPTION_FILTER lpTopLevelExceptionFilter
    );
*/

LPVOID CreateFiber(DWORD dwStackSize,LPFIBER_START_ROUTINE lpStartAddress,LPVOID lpParameter);
VOID DeleteFiber(LPVOID lpFiber);
LPVOID ConvertThreadToFiber(LPVOID lpParameter);
VOID SwitchToFiber(LPVOID lpFiber);
BOOL SwitchToThread();

HANDLE CreateThread(LPSECURITY_ATTRIBUTES lpThreadAttributes,DWORD dwStackSize,LPTHREAD_START_ROUTINE lpStartAddress,LPVOID lpParameter,DWORD dwCreationFlags,LPDWORD lpThreadId);
HANDLE CreateRemoteThread(HANDLE hProcess,LPSECURITY_ATTRIBUTES lpThreadAttributes,DWORD dwStackSize,LPTHREAD_START_ROUTINE lpStartAddress,LPVOID lpParameter,DWORD dwCreationFlags,LPDWORD lpThreadId);
HANDLE GetCurrentThread();
DWORD GetCurrentThreadId();
DWORD SetThreadAffinityMask(HANDLE hThread,DWORD dwThreadAffinityMask);
DWORD SetThreadIdealProcessor(HANDLE hThread,DWORD dwIdealProcessor);
BOOL SetProcessPriorityBoost(HANDLE hProcess,BOOL bDisablePriorityBoost);
BOOL GetProcessPriorityBoost(HANDLE hProcess,PBOOL pDisablePriorityBoost);
BOOL SetThreadPriority(HANDLE hThread,int nPriority);
BOOL SetThreadPriorityBoost(HANDLE hThread,BOOL bDisablePriorityBoost);
BOOL GetThreadPriorityBoost(HANDLE hThread,PBOOL pDisablePriorityBoost);
int GetThreadPriority(HANDLE hThread);
BOOL GetThreadTimes(HANDLE hThread,LPFILETIME lpCreationTime,LPFILETIME lpExitTime,LPFILETIME lpKernelTime,LPFILETIME lpUserTime);
VOID ExitThread(DWORD dwExitCode);
BOOL TerminateThread(HANDLE hThread,DWORD dwExitCode);
BOOL GetExitCodeThread(HANDLE hThread,LPDWORD lpExitCode);
//BOOL GetThreadSelectorEntry(HANDLE hThread,DWORD dwSelector,LPLDT_ENTRY lpSelectorEntry);
version( STANDALONE )
{
  DWORD GetLastError();
}
VOID SetLastError(DWORD dwErrCode);

//#define HasOverlappedIoCompleted(lpOverlapped) ((lpOverlapped)->Internal != STATUS_PENDING)

BOOL GetOverlappedResult(HANDLE hFile,LPOVERLAPPED lpOverlapped,LPDWORD lpNumberOfBytesTransferred,BOOL bWait);
HANDLE CreateIoCompletionPort(HANDLE FileHandle,HANDLE ExistingCompletionPort,DWORD CompletionKey,DWORD NumberOfConcurrentThreads);
BOOL GetQueuedCompletionStatus(HANDLE CompletionPort,LPDWORD lpNumberOfBytesTransferred,LPDWORD lpCompletionKey,LPOVERLAPPED *lpOverlapped,DWORD dwMilliseconds);
BOOL PostQueuedCompletionStatus(HANDLE CompletionPort,DWORD dwNumberOfBytesTransferred,DWORD dwCompletionKey,LPOVERLAPPED lpOverlapped);

enum { 
SEM_FAILCRITICALERRORS      =0x0001,
SEM_NOGPFAULTERRORBOX       =0x0002,
SEM_NOALIGNMENTFAULTEXCEPT  =0x0004,
SEM_NOOPENFILEERRORBOX      =0x8000
}

UINT SetErrorMode(UINT uMode);
BOOL ReadProcessMemory(HANDLE hProcess,LPCVOID lpBaseAddress,LPVOID lpBuffer,DWORD nSize,LPDWORD lpNumberOfBytesRead);
BOOL WriteProcessMemory(HANDLE hProcess,LPVOID lpBaseAddress,LPVOID lpBuffer,DWORD nSize,LPDWORD lpNumberOfBytesWritten);

//BOOL GetThreadContext(HANDLE hThread,LPCONTEXT lpContext);
// BOOL SetThreadContext(HANDLE hThread,CONST CONTEXT *lpContext);

DWORD SuspendThread(HANDLE hThread);
DWORD ResumeThread(HANDLE hThread);


alias VOID (*PAPCFUNC)(DWORD dwParam);

DWORD QueueUserAPC(PAPCFUNC pfnAPC,HANDLE hThread,DWORD dwData);
VOID DebugBreak();
BOOL WaitForDebugEvent( LPDEBUG_EVENT lpDebugEvent,DWORD dwMilliseconds);
BOOL ContinueDebugEvent(DWORD dwProcessId,DWORD dwThreadId,DWORD dwContinueStatus);
BOOL DebugActiveProcess(DWORD dwProcessId);
VOID InitializeCriticalSection(LPCRITICAL_SECTION lpCriticalSection);
VOID EnterCriticalSection(LPCRITICAL_SECTION lpCriticalSection);
VOID LeaveCriticalSection(LPCRITICAL_SECTION lpCriticalSection);
BOOL TryEnterCriticalSection(LPCRITICAL_SECTION lpCriticalSection);
VOID DeleteCriticalSection(LPCRITICAL_SECTION lpCriticalSection);
BOOL SetEvent(HANDLE hEvent);
BOOL ResetEvent(HANDLE hEvent);
BOOL PulseEvent(HANDLE hEvent);
BOOL ReleaseSemaphore(HANDLE hSemaphore,LONG lReleaseCount,LPLONG lpPreviousCount);
BOOL ReleaseMutex(HANDLE hMutex);
//DWORD WaitForSingleObject(HANDLE hHandle,DWORD dwMilliseconds);
DWORD WaitForMultipleObjects(DWORD nCount,HANDLE *lpHandles,BOOL bWaitAll,DWORD dwMilliseconds);
VOID Sleep(DWORD dwMilliseconds);
HGLOBAL LoadResource(HMODULE hModule,HRSRC hResInfo);
DWORD SizeofResource(HMODULE hModule,HRSRC hResInfo);
ATOM GlobalDeleteAtom(ATOM nAtom);
BOOL InitAtomTable(DWORD nSize);
ATOM DeleteAtom(ATOM nAtom);
UINT SetHandleCount(UINT uNumber);
DWORD GetLogicalDrives();

BOOL LockFile(HANDLE hFile,DWORD dwFileOffsetLow,DWORD dwFileOffsetHigh,DWORD nNumberOfBytesToLockLow,DWORD nNumberOfBytesToLockHigh);
BOOL UnlockFile(HANDLE hFile,DWORD dwFileOffsetLow,DWORD dwFileOffsetHigh,DWORD nNumberOfBytesToUnlockLow,DWORD nNumberOfBytesToUnlockHigh);
BOOL LockFileEx(HANDLE hFile,DWORD dwFlags,DWORD dwReserved,DWORD nNumberOfBytesToLockLow,DWORD nNumberOfBytesToLockHigh,LPOVERLAPPED lpOverlapped);

enum { 
LOCKFILE_FAIL_IMMEDIATELY   =0x00000001,
LOCKFILE_EXCLUSIVE_LOCK     =0x00000002
}

BOOL UnlockFileEx(HANDLE hFile,DWORD dwReserved,DWORD nNumberOfBytesToUnlockLow,DWORD nNumberOfBytesToUnlockHigh,LPOVERLAPPED lpOverlapped);

struct BY_HANDLE_FILE_INFORMATION {
    DWORD dwFileAttributes;
    FILETIME ftCreationTime;
    FILETIME ftLastAccessTime;
    FILETIME ftLastWriteTime;
    DWORD dwVolumeSerialNumber;
    DWORD nFileSizeHigh;
    DWORD nFileSizeLow;
    DWORD nNumberOfLinks;
    DWORD nFileIndexHigh;
    DWORD nFileIndexLow;
} 
alias BY_HANDLE_FILE_INFORMATION * PBY_HANDLE_FILE_INFORMATION,LPBY_HANDLE_FILE_INFORMATION;

BOOL GetFileInformationByHandle(HANDLE hFile,LPBY_HANDLE_FILE_INFORMATION lpFileInformation);
DWORD GetFileType(HANDLE hFile);
DWORD GetFileSize(HANDLE hFile,LPDWORD lpFileSizeHigh);
HANDLE GetStdHandle(DWORD nStdHandle);
BOOL SetStdHandle(DWORD nStdHandle,HANDLE hHandle);
//BOOL WriteFile(HANDLE hFile,LPCVOID lpBuffer,DWORD nNumberOfBytesToWrite,LPDWORD lpNumberOfBytesWritten,LPOVERLAPPED lpOverlapped);
//BOOL ReadFile( HANDLE hFile,LPVOID lpBuffer,DWORD nNumberOfBytesToRead,LPDWORD lpNumberOfBytesRead,LPOVERLAPPED lpOverlapped);
BOOL FlushFileBuffers(HANDLE hFile);
BOOL DeviceIoControl(HANDLE hDevice,DWORD dwIoControlCode,LPVOID lpInBuffer,DWORD nInBufferSize,LPVOID lpOutBuffer,DWORD nOutBufferSize,LPDWORD lpBytesReturned,LPOVERLAPPED lpOverlapped);
BOOL SetEndOfFile(HANDLE hFile);
DWORD SetFilePointer(HANDLE hFile,LONG lDistanceToMove,PLONG lpDistanceToMoveHigh,DWORD dwMoveMethod);
BOOL FindClose(HANDLE hFindFile);
BOOL GetFileTime(HANDLE hFile,LPFILETIME lpCreationTime,LPFILETIME lpLastAccessTime,LPFILETIME lpLastWriteTime);
BOOL SetFileTime(HANDLE hFile,FILETIME *lpCreationTime,FILETIME *lpLastAccessTime,FILETIME *lpLastWriteTime);
BOOL CloseHandle(HANDLE hObject);
BOOL DuplicateHandle( HANDLE hSourceProcessHandle,HANDLE hSourceHandle,HANDLE hTargetProcessHandle,LPHANDLE lpTargetHandle,DWORD dwDesiredAccess,BOOL bInheritHandle,DWORD dwOptions);
BOOL GetHandleInformation(HANDLE hObject,LPDWORD lpdwFlags);
BOOL SetHandleInformation(HANDLE hObject,DWORD dwMask,DWORD dwFlags);

enum {
 HANDLE_FLAG_INHERIT            = 0x00000001,
HANDLE_FLAG_PROTECT_FROM_CLOSE  =0x00000002
}

enum { HINSTANCE_ERROR = 32 }

DWORD LoadModule(LPCSTR lpModuleName,LPVOID lpParameterBlock);

UINT WinExec(LPCSTR lpCmdLine,UINT uCmdShow);

BOOL ClearCommBreak(HANDLE hFile);

BOOL ClearCommError(HANDLE hFile,LPDWORD lpErrors,LPCOMSTAT lpStat);

BOOL SetupComm(HANDLE hFile,DWORD dwInQueue,DWORD dwOutQueue);

BOOL EscapeCommFunction(HANDLE hFile,DWORD dwFunc);

BOOL GetCommConfig(HANDLE hCommDev,LPCOMMCONFIG lpCC,LPDWORD lpdwSize);

BOOL GetCommMask(HANDLE hFile,LPDWORD lpEvtMask);

BOOL GetCommProperties(HANDLE hFile,LPCOMMPROP lpCommProp);

BOOL GetCommModemStatus(HANDLE hFile,LPDWORD lpModemStat);

BOOL GetCommState(HANDLE hFile,LPDCB lpDCB);

BOOL GetCommTimeouts(HANDLE hFile,LPCOMMTIMEOUTS lpCommTimeouts);

BOOL PurgeComm(HANDLE hFile,DWORD dwFlags);

BOOL SetCommBreak(HANDLE hFile);
BOOL SetCommConfig(HANDLE hCommDev,LPCOMMCONFIG lpCC,DWORD dwSize);
BOOL SetCommMask(HANDLE hFile,DWORD dwEvtMask);
BOOL SetCommState(HANDLE hFile,LPDCB lpDCB);
BOOL SetCommTimeouts(HANDLE hFile,LPCOMMTIMEOUTS lpCommTimeouts);
BOOL TransmitCommChar(HANDLE hFile,char cChar);
BOOL WaitCommEvent(HANDLE hFile,LPDWORD lpEvtMask,LPOVERLAPPED lpOverlapped);

DWORD SetTapePosition(HANDLE hDevice,DWORD dwPositionMethod,DWORD dwPartition,DWORD dwOffsetLow,DWORD dwOffsetHigh,BOOL bImmediate);
DWORD GetTapePosition(HANDLE hDevice,DWORD dwPositionType,LPDWORD lpdwPartition,LPDWORD lpdwOffsetLow,LPDWORD lpdwOffsetHigh);
DWORD PrepareTape(HANDLE hDevice,DWORD dwOperation,BOOL bImmediate);
DWORD EraseTape(HANDLE hDevice,DWORD dwEraseType,BOOL bImmediate);
DWORD CreateTapePartition(HANDLE hDevice,DWORD dwPartitionMethod,DWORD dwCount,DWORD dwSize);
DWORD WriteTapemark(HANDLE hDevice,DWORD dwTapemarkType,DWORD dwTapemarkCount,BOOL bImmediate);
DWORD GetTapeStatus(HANDLE hDevice);
DWORD GetTapeParameters(HANDLE hDevice,DWORD dwOperation,LPDWORD lpdwSize,LPVOID lpTapeInformation);

enum {
GET_TAPE_MEDIA_INFORMATION =0,
GET_TAPE_DRIVE_INFORMATION =1
}

DWORD SetTapeParameters(HANDLE hDevice,DWORD dwOperation,LPVOID lpTapeInformation);

enum {
SET_TAPE_MEDIA_INFORMATION =0,
SET_TAPE_DRIVE_INFORMATION =1
}

BOOL Beep(DWORD dwFreq,DWORD dwDuration);

int MulDiv(int nNumber,int nNumerator,int nDenominator);
VOID GetSystemTime(LPSYSTEMTIME lpSystemTime);
VOID GetSystemTimeAsFileTime(LPFILETIME lpSystemTimeAsFileTime);

BOOL SetSystemTime(SYSTEMTIME *lpSystemTime);

VOID GetLocalTime(LPSYSTEMTIME lpSystemTime);

BOOL SetLocalTime(SYSTEMTIME *lpSystemTime);
VOID GetSystemInfo(LPSYSTEM_INFO lpSystemInfo);

BOOL IsProcessorFeaturePresent(DWORD ProcessorFeature);

struct TIME_ZONE_INFORMATION {
    LONG Bias;
    WCHAR StandardName[ 32 ];
    SYSTEMTIME StandardDate;
    LONG StandardBias;
    WCHAR DaylightName[ 32 ];
    SYSTEMTIME DaylightDate;
    LONG DaylightBias;
} 
alias TIME_ZONE_INFORMATION * PTIME_ZONE_INFORMATION,LPTIME_ZONE_INFORMATION;

BOOL SystemTimeToTzSpecificLocalTime(LPTIME_ZONE_INFORMATION lpTimeZoneInformation,LPSYSTEMTIME lpUniversalTime,LPSYSTEMTIME lpLocalTime);
DWORD GetTimeZoneInformation(LPTIME_ZONE_INFORMATION lpTimeZoneInformation);
BOOL SetTimeZoneInformation( TIME_ZONE_INFORMATION *lpTimeZoneInformation);


//
// Routines to convert back and forth between system time and file time
//

BOOL SystemTimeToFileTime(SYSTEMTIME *lpSystemTime,LPFILETIME lpFileTime);
BOOL FileTimeToLocalFileTime(FILETIME *lpFileTime,LPFILETIME lpLocalFileTime);
BOOL LocalFileTimeToFileTime(FILETIME *lpLocalFileTime,LPFILETIME lpFileTime);
BOOL FileTimeToSystemTime(FILETIME *lpFileTime,LPSYSTEMTIME lpSystemTime);
LONG CompareFileTime(FILETIME *lpFileTime1,FILETIME *lpFileTime2);
BOOL FileTimeToDosDateTime(FILETIME *lpFileTime,LPWORD lpFatDate,LPWORD lpFatTime);
BOOL DosDateTimeToFileTime(WORD wFatDate,WORD wFatTime,LPFILETIME lpFileTime);
DWORD GetTickCount();
BOOL SetSystemTimeAdjustment(DWORD dwTimeAdjustment,BOOL  bTimeAdjustmentDisabled);
BOOL GetSystemTimeAdjustment(PDWORD lpTimeAdjustment,PDWORD lpTimeIncrement,PBOOL  lpTimeAdjustmentDisabled);

// DWORD FormatMessageA(DWORD dwFlags,LPCVOID lpSource,DWORD dwMessageId,DWORD dwLanguageId,LPSTR lpBuffer,DWORD nSize,va_list *Arguments);
// DWORD FormatMessageW(DWORD dwFlags,LPCVOID lpSource,DWORD dwMessageId,DWORD dwLanguageId,LPWSTR lpBuffer,DWORD nSize,va_list *Arguments);
//#ifdef UNICODE
//#define FormatMessage  FormatMessageW
//#else
//#define FormatMessage  FormatMessageA
//#endif // !UNICODE
//#endif

enum {
FORMAT_MESSAGE_ALLOCATE_BUFFER =0x00000100,
FORMAT_MESSAGE_IGNORE_INSERTS  =0x00000200,
FORMAT_MESSAGE_FROM_STRING     =0x00000400,
FORMAT_MESSAGE_FROM_HMODULE    =0x00000800,
FORMAT_MESSAGE_FROM_SYSTEM     =0x00001000,
FORMAT_MESSAGE_ARGUMENT_ARRAY  =0x00002000,
FORMAT_MESSAGE_MAX_WIDTH_MASK  =0x000000FF
}

BOOL CreatePipe(PHANDLE hReadPipe,PHANDLE hWritePipe,LPSECURITY_ATTRIBUTES lpPipeAttributes,DWORD nSize);
BOOL ConnectNamedPipe(HANDLE hNamedPipe,LPOVERLAPPED lpOverlapped);
BOOL DisconnectNamedPipe(HANDLE hNamedPipe);
BOOL SetNamedPipeHandleState(HANDLE hNamedPipe,LPDWORD lpMode,LPDWORD lpMaxCollectionCount,LPDWORD lpCollectDataTimeout);
BOOL GetNamedPipeInfo(HANDLE hNamedPipe,LPDWORD lpFlags,LPDWORD lpOutBufferSize,LPDWORD lpInBufferSize,LPDWORD lpMaxInstances);
BOOL PeekNamedPipe(HANDLE hNamedPipe,LPVOID lpBuffer,DWORD nBufferSize,LPDWORD lpBytesRead,LPDWORD lpTotalBytesAvail,LPDWORD lpBytesLeftThisMessage);
BOOL TransactNamedPipe(HANDLE hNamedPipe,LPVOID lpInBuffer,DWORD nInBufferSize,LPVOID lpOutBuffer,DWORD nOutBufferSize,LPDWORD lpBytesRead,LPOVERLAPPED lpOverlapped);
HANDLE CreateMailslotA(LPCSTR lpName,DWORD nMaxMessageSize,DWORD lReadTimeout,LPSECURITY_ATTRIBUTES lpSecurityAttributes);
HANDLE CreateMailslotW(LPCWSTR lpName,DWORD nMaxMessageSize,DWORD lReadTimeout,LPSECURITY_ATTRIBUTES lpSecurityAttributes);

BOOL GetMailslotInfo(HANDLE hMailslot,LPDWORD lpMaxMessageSize,LPDWORD lpNextSize,LPDWORD lpMessageCount,LPDWORD lpReadTimeout);
BOOL SetMailslotInfo(HANDLE hMailslot,DWORD lReadTimeout);

LPVOID MapViewOfFile(HANDLE hFileMappingObject,DWORD dwDesiredAccess,DWORD dwFileOffsetHigh,DWORD dwFileOffsetLow,DWORD dwNumberOfBytesToMap);

BOOL
FlushViewOfFile(
    LPCVOID lpBaseAddress,
    DWORD dwNumberOfBytesToFlush
    );

BOOL
UnmapViewOfFile(
    LPCVOID lpBaseAddress
    );


//
// _l Compat Functions
//

int
lstrcmpA(
    LPCSTR lpString1,
    LPCSTR lpString2
    );

int
lstrcmpW(
    LPCWSTR lpString1,
    LPCWSTR lpString2
    );

int
lstrcmpiA(
    LPCSTR lpString1,
    LPCSTR lpString2
    );

int
lstrcmpiW(
    LPCWSTR lpString1,
    LPCWSTR lpString2
    );

LPSTR
lstrcpynA(
    LPSTR lpString1,
    LPCSTR lpString2,
    int iMaxLength
    );

LPWSTR
lstrcpynW(
    LPWSTR lpString1,
    LPCWSTR lpString2,
    int iMaxLength
    );

LPSTR
lstrcpyA(
    LPSTR lpString1,
    LPCSTR lpString2
    );

LPWSTR
lstrcpyW(
    LPWSTR lpString1,
    LPCWSTR lpString2
    );

LPSTR
lstrcatA(
    LPSTR lpString1,
    LPCSTR lpString2
    );

LPWSTR
lstrcatW(
    LPWSTR lpString1,
    LPCWSTR lpString2
    );

int
lstrlenA(
    LPCSTR lpString
    );

int
lstrlenW(
    LPCWSTR lpString
    );

HFILE
OpenFile(
    LPCSTR lpFileName,
    LPOFSTRUCT lpReOpenBuff,
    UINT uStyle
    );

HFILE
_lopen(
    LPCSTR lpPathName,
    int iReadWrite
    );

HFILE
_lcreat(
    LPCSTR lpPathName,
    int  iAttribute
    );

UINT
_lread(
    HFILE hFile,
    LPVOID lpBuffer,
    UINT uBytes
    );

UINT
_lwrite(
    HFILE hFile,
    LPCSTR lpBuffer,
    UINT uBytes
    );

long
_hread(
    HFILE hFile,
    LPVOID lpBuffer,
    long lBytes
    );

long
_hwrite(
    HFILE hFile,
    LPCSTR lpBuffer,
    long lBytes
    );

HFILE
_lclose(
    HFILE hFile
    );

LONG
_llseek(
    HFILE hFile,
    LONG lOffset,
    int iOrigin
    );

BOOL
IsTextUnicode(
    LPVOID lpBuffer,
    int cb,
    LPINT lpi
    );

DWORD TlsAlloc(    );

enum : DWORD { TLS_OUT_OF_INDEXES = (DWORD)0xFFFFFFFF }

LPVOID TlsGetValue(DWORD dwTlsIndex);

BOOL
TlsSetValue(
    DWORD dwTlsIndex,
    LPVOID lpTlsValue
    );

BOOL
TlsFree(
    DWORD dwTlsIndex
    );

alias VOID (*LPOVERLAPPED_COMPLETION_ROUTINE)(
    DWORD dwErrorCode,
    DWORD dwNumberOfBytesTransfered,
    LPOVERLAPPED lpOverlapped
    );

DWORD
SleepEx(
    DWORD dwMilliseconds,
    BOOL bAlertable
    );

DWORD
WaitForSingleObjectEx(
    HANDLE hHandle,
    DWORD dwMilliseconds,
    BOOL bAlertable
    );

DWORD
WaitForMultipleObjectsEx(
    DWORD nCount,
    HANDLE *lpHandles,
    BOOL bWaitAll,
    DWORD dwMilliseconds,
    BOOL bAlertable
    );

DWORD
SignalObjectAndWait(
    HANDLE hObjectToSignal,
    HANDLE hObjectToWaitOn,
    DWORD dwMilliseconds,
    BOOL bAlertable
    );

BOOL
ReadFileEx(
    HANDLE hFile,
    LPVOID lpBuffer,
    DWORD nNumberOfBytesToRead,
    LPOVERLAPPED lpOverlapped,
    LPOVERLAPPED_COMPLETION_ROUTINE lpCompletionRoutine
    );

BOOL
WriteFileEx(
    HANDLE hFile,
    LPCVOID lpBuffer,
    DWORD nNumberOfBytesToWrite,
    LPOVERLAPPED lpOverlapped,
    LPOVERLAPPED_COMPLETION_ROUTINE lpCompletionRoutine
    );

BOOL
BackupRead(
    HANDLE hFile,
    LPBYTE lpBuffer,
    DWORD nNumberOfBytesToRead,
    LPDWORD lpNumberOfBytesRead,
    BOOL bAbort,
    BOOL bProcessSecurity,
    LPVOID *lpContext
    );

BOOL
BackupSeek(
    HANDLE hFile,
    DWORD  dwLowBytesToSeek,
    DWORD  dwHighBytesToSeek,
    LPDWORD lpdwLowByteSeeked,
    LPDWORD lpdwHighByteSeeked,
    LPVOID *lpContext
    );

BOOL
BackupWrite(
    HANDLE hFile,
    LPBYTE lpBuffer,
    DWORD nNumberOfBytesToWrite,
    LPDWORD lpNumberOfBytesWritten,
    BOOL bAbort,
    BOOL bProcessSecurity,
    LPVOID *lpContext
    );

//
//  Stream id structure
//
struct WIN32_STREAM_ID {
        DWORD          dwStreamId ;
        DWORD          dwStreamAttributes ;
        LARGE_INTEGER  Size ;
        DWORD          dwStreamNameSize ;
        WCHAR          cStreamName[ ANYSIZE_ARRAY ] ;
} 
alias WIN32_STREAM_ID * LPWIN32_STREAM_ID ;

enum {
//
//  Stream Ids
//
BACKUP_INVALID          =0x00000000,
BACKUP_DATA             =0x00000001,
BACKUP_EA_DATA          =0x00000002,
BACKUP_SECURITY_DATA    =0x00000003,
BACKUP_ALTERNATE_DATA   =0x00000004,
BACKUP_LINK             =0x00000005,
BACKUP_PROPERTY_DATA    =0x00000006
}

enum {
//
//  Stream Attributes
//
STREAM_NORMAL_ATTRIBUTE         =0x00000000,
STREAM_MODIFIED_WHEN_READ       =0x00000001,
STREAM_CONTAINS_SECURITY        =0x00000002,
STREAM_CONTAINS_PROPERTIES      =0x00000004
}

enum {
//
// Dual Mode API below this line. Dual Mode Structures also included.
//
STARTF_USESHOWWINDOW    =0x00000001,
STARTF_USESIZE          =0x00000002,
STARTF_USEPOSITION      =0x00000004,
STARTF_USECOUNTCHARS    =0x00000008,
STARTF_USEFILLATTRIBUTE =0x00000010,
STARTF_RUNFULLSCREEN    =0x00000020,  // ignored for non-x86 platforms
STARTF_FORCEONFEEDBACK  =0x00000040,
STARTF_FORCEOFFFEEDBACK =0x00000080,
STARTF_USESTDHANDLES    =0x00000100,
STARTF_USEHOTKEY        =0x00000200
}

struct STARTUPINFOA {
    DWORD   cb;
    LPSTR   lpReserved;
    LPSTR   lpDesktop;
    LPSTR   lpTitle;
    DWORD   dwX;
    DWORD   dwY;
    DWORD   dwXSize;
    DWORD   dwYSize;
    DWORD   dwXCountChars;
    DWORD   dwYCountChars;
    DWORD   dwFillAttribute;
    DWORD   dwFlags;
    WORD    wShowWindow;
    WORD    cbReserved2;
    LPBYTE  lpReserved2;
    HANDLE  hStdInput;
    HANDLE  hStdOutput;
    HANDLE  hStdError;
} 
alias STARTUPINFOA * LPSTARTUPINFOA;
struct STARTUPINFOW {
    DWORD   cb;
    LPWSTR  lpReserved;
    LPWSTR  lpDesktop;
    LPWSTR  lpTitle;
    DWORD   dwX;
    DWORD   dwY;
    DWORD   dwXSize;
    DWORD   dwYSize;
    DWORD   dwXCountChars;
    DWORD   dwYCountChars;
    DWORD   dwFillAttribute;
    DWORD   dwFlags;
    WORD    wShowWindow;
    WORD    cbReserved2;
    LPBYTE  lpReserved2;
    HANDLE  hStdInput;
    HANDLE  hStdOutput;
    HANDLE  hStdError;
} 
alias STARTUPINFOW * LPSTARTUPINFOW;

enum { SHUTDOWN_NORETRY                = 0x00000001 }

struct WIN32_FIND_DATAA {
    DWORD dwFileAttributes;
    FILETIME ftCreationTime;
    FILETIME ftLastAccessTime;
    FILETIME ftLastWriteTime;
    DWORD nFileSizeHigh;
    DWORD nFileSizeLow;
    DWORD dwReserved0;
    DWORD dwReserved1;
    CHAR   cFileName[ MAX_PATH ];
    CHAR   cAlternateFileName[ 14 ];
} 
alias WIN32_FIND_DATAA * PWIN32_FIND_DATAA,LPWIN32_FIND_DATAA;
struct WIN32_FIND_DATAW {
    DWORD dwFileAttributes;
    FILETIME ftCreationTime;
    FILETIME ftLastAccessTime;
    FILETIME ftLastWriteTime;
    DWORD nFileSizeHigh;
    DWORD nFileSizeLow;
    DWORD dwReserved0;
    DWORD dwReserved1;
    WCHAR  cFileName[ MAX_PATH ];
    WCHAR  cAlternateFileName[ 14 ];
} 
alias WIN32_FIND_DATAW * PWIN32_FIND_DATAW,LPWIN32_FIND_DATAW;

struct WIN32_FILE_ATTRIBUTE_DATA {
    DWORD dwFileAttributes;
    FILETIME ftCreationTime;
    FILETIME ftLastAccessTime;
    FILETIME ftLastWriteTime;
    DWORD nFileSizeHigh;
    DWORD nFileSizeLow;
} 
alias WIN32_FILE_ATTRIBUTE_DATA * LPWIN32_FILE_ATTRIBUTE_DATA;

HANDLE
CreateMutexA(
    LPSECURITY_ATTRIBUTES lpMutexAttributes,
    BOOL bInitialOwner,
    LPCSTR lpName
    );

HANDLE
CreateMutexW(
    LPSECURITY_ATTRIBUTES lpMutexAttributes,
    BOOL bInitialOwner,
    LPCWSTR lpName
    );

HANDLE
OpenMutexA(
    DWORD dwDesiredAccess,
    BOOL bInheritHandle,
    LPCSTR lpName
    );

HANDLE
OpenMutexW(
    DWORD dwDesiredAccess,
    BOOL bInheritHandle,
    LPCWSTR lpName
    );

HANDLE
CreateEventA(
    LPSECURITY_ATTRIBUTES lpEventAttributes,
    BOOL bManualReset,
    BOOL bInitialState,
    LPCSTR lpName
    );

HANDLE
CreateEventW(
    LPSECURITY_ATTRIBUTES lpEventAttributes,
    BOOL bManualReset,
    BOOL bInitialState,
    LPCWSTR lpName
    );

HANDLE
OpenEventA(
    DWORD dwDesiredAccess,
    BOOL bInheritHandle,
    LPCSTR lpName
    );

HANDLE
OpenEventW(
    DWORD dwDesiredAccess,
    BOOL bInheritHandle,
    LPCWSTR lpName
    );

HANDLE
CreateSemaphoreA(
    LPSECURITY_ATTRIBUTES lpSemaphoreAttributes,
    LONG lInitialCount,
    LONG lMaximumCount,
    LPCSTR lpName
    );

HANDLE
CreateSemaphoreW(
    LPSECURITY_ATTRIBUTES lpSemaphoreAttributes,
    LONG lInitialCount,
    LONG lMaximumCount,
    LPCWSTR lpName
    );

HANDLE
OpenSemaphoreA(
    DWORD dwDesiredAccess,
    BOOL bInheritHandle,
    LPCSTR lpName
    );

HANDLE
OpenSemaphoreW(
    DWORD dwDesiredAccess,
    BOOL bInheritHandle,
    LPCWSTR lpName
    );

alias VOID (*PTIMERAPCROUTINE)(LPVOID lpArgToCompletionRoutine,
    DWORD dwTimerLowValue,
    DWORD dwTimerHighValue
    );

HANDLE
CreateWaitableTimerA(
    LPSECURITY_ATTRIBUTES lpTimerAttributes,
    BOOL bManualReset,
    LPCSTR lpTimerName
    );

HANDLE
CreateWaitableTimerW(
    LPSECURITY_ATTRIBUTES lpTimerAttributes,
    BOOL bManualReset,
    LPCWSTR lpTimerName
    );

HANDLE
OpenWaitableTimerA(
    DWORD dwDesiredAccess,
    BOOL bInheritHandle,
    LPCSTR lpTimerName
    );

HANDLE
OpenWaitableTimerW(
    DWORD dwDesiredAccess,
    BOOL bInheritHandle,
    LPCWSTR lpTimerName
    );

BOOL
SetWaitableTimer(
    HANDLE hTimer,
    LARGE_INTEGER *lpDueTime,
    LONG lPeriod,
    PTIMERAPCROUTINE pfnCompletionRoutine,
    LPVOID lpArgToCompletionRoutine,
    BOOL fResume
    );

BOOL
CancelWaitableTimer(
    HANDLE hTimer
    );

HANDLE
CreateFileMappingA(
    HANDLE hFile,
    LPSECURITY_ATTRIBUTES lpFileMappingAttributes,
    DWORD flProtect,
    DWORD dwMaximumSizeHigh,
    DWORD dwMaximumSizeLow,
    LPCSTR lpName
    );

HANDLE
CreateFileMappingW(
    HANDLE hFile,
    LPSECURITY_ATTRIBUTES lpFileMappingAttributes,
    DWORD flProtect,
    DWORD dwMaximumSizeHigh,
    DWORD dwMaximumSizeLow,
    LPCWSTR lpName
    );

HANDLE
OpenFileMappingA(
    DWORD dwDesiredAccess,
    BOOL bInheritHandle,
    LPCSTR lpName
    );

HANDLE
OpenFileMappingW(
    DWORD dwDesiredAccess,
    BOOL bInheritHandle,
    LPCWSTR lpName
    );

DWORD
GetLogicalDriveStringsA(
    DWORD nBufferLength,
    LPSTR lpBuffer
    );

DWORD
GetLogicalDriveStringsW(
    DWORD nBufferLength,
    LPWSTR lpBuffer
    );

//HMODULE LoadLibraryA(LPCSTR lpLibFileName);
HMODULE LoadLibraryW(LPCWSTR lpLibFileName);

HMODULE LoadLibraryExA(LPCSTR lpLibFileName,HANDLE hFile,DWORD dwFlags);
HMODULE LoadLibraryExW(LPCWSTR lpLibFileName,HANDLE hFile,DWORD dwFlags);

enum {
DONT_RESOLVE_DLL_REFERENCES     =0x00000001,
LOAD_LIBRARY_AS_DATAFILE        =0x00000002,
LOAD_WITH_ALTERED_SEARCH_PATH   =0x00000008
}

//DWORD GetModuleFileNameA(HMODULE hModule,LPSTR lpFilename,DWORD nSize);
DWORD GetModuleFileNameW(HMODULE hModule,LPWSTR lpFilename,DWORD nSize);

/*
HMODULE GetModuleHandleA(LPCSTR lpModuleName);
*/

HMODULE
GetModuleHandleW(
    LPCWSTR lpModuleName
    );

BOOL
CreateProcessA(
    LPCSTR lpApplicationName,
    LPSTR lpCommandLine,
    LPSECURITY_ATTRIBUTES lpProcessAttributes,
    LPSECURITY_ATTRIBUTES lpThreadAttributes,
    BOOL bInheritHandles,
    DWORD dwCreationFlags,
    LPVOID lpEnvironment,
    LPCSTR lpCurrentDirectory,
    LPSTARTUPINFOA lpStartupInfo,
    LPPROCESS_INFORMATION lpProcessInformation
    );

BOOL
CreateProcessW(
    LPCWSTR lpApplicationName,
    LPWSTR lpCommandLine,
    LPSECURITY_ATTRIBUTES lpProcessAttributes,
    LPSECURITY_ATTRIBUTES lpThreadAttributes,
    BOOL bInheritHandles,
    DWORD dwCreationFlags,
    LPVOID lpEnvironment,
    LPCWSTR lpCurrentDirectory,
    LPSTARTUPINFOW lpStartupInfo,
    LPPROCESS_INFORMATION lpProcessInformation
    );

BOOL
SetProcessShutdownParameters(
    DWORD dwLevel,
    DWORD dwFlags
    );

BOOL
GetProcessShutdownParameters(
    LPDWORD lpdwLevel,
    LPDWORD lpdwFlags
    );

DWORD
GetProcessVersion(
    DWORD ProcessId
    );

VOID
FatalAppExitA(
    UINT uAction,
    LPCSTR lpMessageText
    );

VOID
FatalAppExitW(
    UINT uAction,
    LPCWSTR lpMessageText
    );

VOID
GetStartupInfoA(
    LPSTARTUPINFOA lpStartupInfo
    );

VOID
GetStartupInfoW(
    LPSTARTUPINFOW lpStartupInfo
    );

LPSTR GetCommandLineA( );

LPWSTR GetCommandLineW( );


DWORD
GetEnvironmentVariableA(
    LPCSTR lpName,
    LPSTR lpBuffer,
    DWORD nSize
    );

DWORD
GetEnvironmentVariableW(
    LPCWSTR lpName,
    LPWSTR lpBuffer,
    DWORD nSize
    );

BOOL
SetEnvironmentVariableA(
    LPCSTR lpName,
    LPCSTR lpValue
    );

BOOL
SetEnvironmentVariableW(
    LPCWSTR lpName,
    LPCWSTR lpValue
    );

DWORD
ExpandEnvironmentStringsA(
    LPCSTR lpSrc,
    LPSTR lpDst,
    DWORD nSize
    );

DWORD
ExpandEnvironmentStringsW(
    LPCWSTR lpSrc,
    LPWSTR lpDst,
    DWORD nSize
    );

VOID
OutputDebugStringA(
    LPCSTR lpOutputString
    );

VOID
OutputDebugStringW(
    LPCWSTR lpOutputString
    );

HRSRC
FindResourceA(
    HMODULE hModule,
    LPCSTR lpName,
    LPCSTR lpType
    );

HRSRC
FindResourceW(
    HMODULE hModule,
    LPCWSTR lpName,
    LPCWSTR lpType
    );

HRSRC
FindResourceExA(
    HMODULE hModule,
    LPCSTR lpType,
    LPCSTR lpName,
    WORD    wLanguage
    );

HRSRC
FindResourceExW(
    HMODULE hModule,
    LPCWSTR lpType,
    LPCWSTR lpName,
    WORD    wLanguage
    );

alias BOOL (* ENUMRESTYPEPROC)(HMODULE hModule, LPTSTR lpType,LONG lParam);
alias BOOL (* ENUMRESNAMEPROC)(HMODULE hModule, LPCTSTR lpType,LPTSTR lpName, LONG lParam);
alias BOOL (* ENUMRESLANGPROC)(HMODULE hModule, LPCTSTR lpType,LPCTSTR lpName, WORD  wLanguage, LONG lParam);

BOOL EnumResourceTypesA(HMODULE hModule,ENUMRESTYPEPROC lpEnumFunc,LONG lParam);
BOOL EnumResourceTypesW(HMODULE hModule,ENUMRESTYPEPROC lpEnumFunc,LONG lParam);

BOOL
EnumResourceNamesA(
    HMODULE hModule,
    LPCSTR lpType,
    ENUMRESNAMEPROC lpEnumFunc,
    LONG lParam
    );

BOOL
EnumResourceNamesW(
    HMODULE hModule,
    LPCWSTR lpType,
    ENUMRESNAMEPROC lpEnumFunc,
    LONG lParam
    );

BOOL
EnumResourceLanguagesA(
    HMODULE hModule,
    LPCSTR lpType,
    LPCSTR lpName,
    ENUMRESLANGPROC lpEnumFunc,
    LONG lParam
    );

BOOL
EnumResourceLanguagesW(
    HMODULE hModule,
    LPCWSTR lpType,
    LPCWSTR lpName,
    ENUMRESLANGPROC lpEnumFunc,
    LONG lParam
    );

HANDLE
BeginUpdateResourceA(
    LPCSTR pFileName,
    BOOL bDeleteExistingResources
    );

HANDLE
BeginUpdateResourceW(
    LPCWSTR pFileName,
    BOOL bDeleteExistingResources
    );

BOOL
UpdateResourceA(
    HANDLE      hUpdate,
    LPCSTR     lpType,
    LPCSTR     lpName,
    WORD        wLanguage,
    LPVOID      lpData,
    DWORD       cbData
    );

BOOL
UpdateResourceW(
    HANDLE      hUpdate,
    LPCWSTR     lpType,
    LPCWSTR     lpName,
    WORD        wLanguage,
    LPVOID      lpData,
    DWORD       cbData
    );

BOOL
EndUpdateResourceA(
    HANDLE      hUpdate,
    BOOL        fDiscard
    );

BOOL
EndUpdateResourceW(
    HANDLE      hUpdate,
    BOOL        fDiscard
    );

ATOM GlobalAddAtomA(LPCSTR lpString);
ATOM GlobalAddAtomW(LPCWSTR lpString);

ATOM GlobalFindAtomA(LPCSTR lpString);
ATOM GlobalFindAtomW(LPCWSTR lpString);

UINT GlobalGetAtomNameA(ATOM nAtom,LPSTR lpBuffer,int nSize);
UINT GlobalGetAtomNameW(ATOM nAtom,LPWSTR lpBuffer,int nSize);

ATOM
AddAtomA(
    LPCSTR lpString
    );

ATOM
AddAtomW(
    LPCWSTR lpString
    );

ATOM
FindAtomA(
    LPCSTR lpString
    );

ATOM
FindAtomW(
    LPCWSTR lpString
    );

UINT
GetAtomNameA(
    ATOM nAtom,
    LPSTR lpBuffer,
    int nSize
    );

UINT
GetAtomNameW(
    ATOM nAtom,
    LPWSTR lpBuffer,
    int nSize
    );

UINT
GetProfileIntA(
    LPCSTR lpAppName,
    LPCSTR lpKeyName,
    INT nDefault
    );

UINT
GetProfileIntW(
    LPCWSTR lpAppName,
    LPCWSTR lpKeyName,
    INT nDefault
    );

DWORD
GetProfileStringA(
    LPCSTR lpAppName,
    LPCSTR lpKeyName,
    LPCSTR lpDefault,
    LPSTR lpReturnedString,
    DWORD nSize
    );

DWORD
GetProfileStringW(
    LPCWSTR lpAppName,
    LPCWSTR lpKeyName,
    LPCWSTR lpDefault,
    LPWSTR lpReturnedString,
    DWORD nSize
    );

BOOL
WriteProfileStringA(
    LPCSTR lpAppName,
    LPCSTR lpKeyName,
    LPCSTR lpString
    );
BOOL
WriteProfileStringW(
    LPCWSTR lpAppName,
    LPCWSTR lpKeyName,
    LPCWSTR lpString
    );

DWORD
GetProfileSectionA(
    LPCSTR lpAppName,
    LPSTR lpReturnedString,
    DWORD nSize
    );

DWORD
GetProfileSectionW(
    LPCWSTR lpAppName,
    LPWSTR lpReturnedString,
    DWORD nSize
    );

BOOL
WriteProfileSectionA(
    LPCSTR lpAppName,
    LPCSTR lpString
    );

BOOL
WriteProfileSectionW(
    LPCWSTR lpAppName,
    LPCWSTR lpString
    );

UINT
GetPrivateProfileIntA(
    LPCSTR lpAppName,
    LPCSTR lpKeyName,
    INT nDefault,
    LPCSTR lpFileName
    );

UINT
GetPrivateProfileIntW(
    LPCWSTR lpAppName,
    LPCWSTR lpKeyName,
    INT nDefault,
    LPCWSTR lpFileName
    );

DWORD
GetPrivateProfileStringA(
    LPCSTR lpAppName,
    LPCSTR lpKeyName,
    LPCSTR lpDefault,
    LPSTR lpReturnedString,
    DWORD nSize,
    LPCSTR lpFileName
    );

DWORD
GetPrivateProfileStringW(
    LPCWSTR lpAppName,
    LPCWSTR lpKeyName,
    LPCWSTR lpDefault,
    LPWSTR lpReturnedString,
    DWORD nSize,
    LPCWSTR lpFileName
    );

BOOL
WritePrivateProfileStringA(
    LPCSTR lpAppName,
    LPCSTR lpKeyName,
    LPCSTR lpString,
    LPCSTR lpFileName
    );

BOOL
WritePrivateProfileStringW(
    LPCWSTR lpAppName,
    LPCWSTR lpKeyName,
    LPCWSTR lpString,
    LPCWSTR lpFileName
    );

DWORD
GetPrivateProfileSectionA(
    LPCSTR lpAppName,
    LPSTR lpReturnedString,
    DWORD nSize,
    LPCSTR lpFileName
    );

DWORD
GetPrivateProfileSectionW(
    LPCWSTR lpAppName,
    LPWSTR lpReturnedString,
    DWORD nSize,
    LPCWSTR lpFileName
    );

BOOL
WritePrivateProfileSectionA(
    LPCSTR lpAppName,
    LPCSTR lpString,
    LPCSTR lpFileName
    );

BOOL
WritePrivateProfileSectionW(
    LPCWSTR lpAppName,
    LPCWSTR lpString,
    LPCWSTR lpFileName
    );

DWORD
GetPrivateProfileSectionNamesA(
    LPSTR lpszReturnBuffer,
    DWORD nSize,
    LPCSTR lpFileName
    );

DWORD
GetPrivateProfileSectionNamesW(
    LPWSTR lpszReturnBuffer,
    DWORD nSize,
    LPCWSTR lpFileName
    );

BOOL
GetPrivateProfileStructA(
    LPCSTR lpszSection,
    LPCSTR lpszKey,
    LPVOID   lpStruct,
    UINT     uSizeStruct,
    LPCSTR szFile
    );

BOOL
GetPrivateProfileStructW(
    LPCWSTR lpszSection,
    LPCWSTR lpszKey,
    LPVOID   lpStruct,
    UINT     uSizeStruct,
    LPCWSTR szFile
    );

BOOL
WritePrivateProfileStructA(
    LPCSTR lpszSection,
    LPCSTR lpszKey,
    LPVOID   lpStruct,
    UINT     uSizeStruct,
    LPCSTR szFile
    );

BOOL
WritePrivateProfileStructW(
    LPCWSTR lpszSection,
    LPCWSTR lpszKey,
    LPVOID   lpStruct,
    UINT     uSizeStruct,
    LPCWSTR szFile
    );

UINT GetDriveTypeA(LPCSTR lpRootPathName);
UINT GetDriveTypeW(LPCWSTR lpRootPathName);

UINT
GetSystemDirectoryA(
    LPSTR lpBuffer,
    UINT uSize
    );

UINT
GetSystemDirectoryW(
    LPWSTR lpBuffer,
    UINT uSize
    );

DWORD
GetTempPathA(
    DWORD nBufferLength,
    LPSTR lpBuffer
    );

DWORD
GetTempPathW(
    DWORD nBufferLength,
    LPWSTR lpBuffer
    );

UINT
GetTempFileNameA(
    LPCSTR lpPathName,
    LPCSTR lpPrefixString,
    UINT uUnique,
    LPSTR lpTempFileName
    );

UINT
GetTempFileNameW(
    LPCWSTR lpPathName,
    LPCWSTR lpPrefixString,
    UINT uUnique,
    LPWSTR lpTempFileName
    );

UINT
GetWindowsDirectoryA(
    LPSTR lpBuffer,
    UINT uSize
    );

UINT
GetWindowsDirectoryW(
    LPWSTR lpBuffer,
    UINT uSize
    );

BOOL
SetCurrentDirectoryA(
    LPCSTR lpPathName
    );

BOOL
SetCurrentDirectoryW(
    LPCWSTR lpPathName
    );

DWORD
GetCurrentDirectoryA(
    DWORD nBufferLength,
    LPSTR lpBuffer
    );

DWORD
GetCurrentDirectoryW(
    DWORD nBufferLength,
    LPWSTR lpBuffer
    );

BOOL
GetDiskFreeSpaceA(
    LPCSTR lpRootPathName,
    LPDWORD lpSectorsPerCluster,
    LPDWORD lpBytesPerSector,
    LPDWORD lpNumberOfFreeClusters,
    LPDWORD lpTotalNumberOfClusters
    );

BOOL
GetDiskFreeSpaceW(
    LPCWSTR lpRootPathName,
    LPDWORD lpSectorsPerCluster,
    LPDWORD lpBytesPerSector,
    LPDWORD lpNumberOfFreeClusters,
    LPDWORD lpTotalNumberOfClusters
    );

BOOL
GetDiskFreeSpaceExA(
    LPCSTR lpDirectoryName,
    PULARGE_INTEGER lpFreeBytesAvailableToCaller,
    PULARGE_INTEGER lpTotalNumberOfBytes,
    PULARGE_INTEGER lpTotalNumberOfFreeBytes
    );
BOOL
GetDiskFreeSpaceExW(
    LPCWSTR lpDirectoryName,
    PULARGE_INTEGER lpFreeBytesAvailableToCaller,
    PULARGE_INTEGER lpTotalNumberOfBytes,
    PULARGE_INTEGER lpTotalNumberOfFreeBytes
    );

BOOL
CreateDirectoryA(
    LPCSTR lpPathName,
    LPSECURITY_ATTRIBUTES lpSecurityAttributes
    );
BOOL
CreateDirectoryW(
    LPCWSTR lpPathName,
    LPSECURITY_ATTRIBUTES lpSecurityAttributes
    );

BOOL
CreateDirectoryExA(
    LPCSTR lpTemplateDirectory,
    LPCSTR lpNewDirectory,
    LPSECURITY_ATTRIBUTES lpSecurityAttributes
    );
BOOL
CreateDirectoryExW(
    LPCWSTR lpTemplateDirectory,
    LPCWSTR lpNewDirectory,
    LPSECURITY_ATTRIBUTES lpSecurityAttributes
    );

BOOL
RemoveDirectoryA(
    LPCSTR lpPathName
    );
BOOL
RemoveDirectoryW(
    LPCWSTR lpPathName
    );

DWORD
GetFullPathNameA(
    LPCSTR lpFileName,
    DWORD nBufferLength,
    LPSTR lpBuffer,
    LPSTR *lpFilePart
    );
DWORD
GetFullPathNameW(
    LPCWSTR lpFileName,
    DWORD nBufferLength,
    LPWSTR lpBuffer,
    LPWSTR *lpFilePart
    );

enum {
DDD_RAW_TARGET_PATH         =0x00000001,
DDD_REMOVE_DEFINITION       =0x00000002,
DDD_EXACT_MATCH_ON_REMOVE   =0x00000004,
DDD_NO_BROADCAST_SYSTEM     =0x00000008
}

BOOL
DefineDosDeviceA(
    DWORD dwFlags,
    LPCSTR lpDeviceName,
    LPCSTR lpTargetPath
    );

BOOL
DefineDosDeviceW(
    DWORD dwFlags,
    LPCWSTR lpDeviceName,
    LPCWSTR lpTargetPath
    );

DWORD
QueryDosDeviceA(
    LPCSTR lpDeviceName,
    LPSTR lpTargetPath,
    DWORD ucchMax
    );

DWORD
QueryDosDeviceW(
    LPCWSTR lpDeviceName,
    LPWSTR lpTargetPath,
    DWORD ucchMax
    );

//!!!#define EXPAND_LOCAL_DRIVES
/*
HANDLE
CreateFileA(
    LPCSTR lpFileName,
    DWORD dwDesiredAccess,
    DWORD dwShareMode,
    LPSECURITY_ATTRIBUTES lpSecurityAttributes,
    DWORD dwCreationDisposition,
    DWORD dwFlagsAndAttributes,
    HANDLE hTemplateFile
    );
	 */
HANDLE
CreateFileW(
    LPCWSTR lpFileName,
    DWORD dwDesiredAccess,
    DWORD dwShareMode,
    LPSECURITY_ATTRIBUTES lpSecurityAttributes,
    DWORD dwCreationDisposition,
    DWORD dwFlagsAndAttributes,
    HANDLE hTemplateFile
    );

BOOL
SetFileAttributesA(
    LPCSTR lpFileName,
    DWORD dwFileAttributes
    );
BOOL
SetFileAttributesW(
    LPCWSTR lpFileName,
    DWORD dwFileAttributes
    );

//DWORD GetFileAttributesA(LPCSTR lpFileName);
DWORD GetFileAttributesW(LPCWSTR lpFileName);

enum GET_FILEEX_INFO_LEVELS {
    GetFileExInfoStandard,
    GetFileExMaxInfoLevel
}


BOOL
GetFileAttributesExA(
    LPCSTR lpFileName,
    GET_FILEEX_INFO_LEVELS fInfoLevelId,
    LPVOID lpFileInformation
    );

BOOL
GetFileAttributesExW(
    LPCWSTR lpFileName,
    GET_FILEEX_INFO_LEVELS fInfoLevelId,
    LPVOID lpFileInformation
    );

DWORD
GetCompressedFileSizeA(
    LPCSTR lpFileName,
    LPDWORD lpFileSizeHigh
    );

DWORD
GetCompressedFileSizeW(
    LPCWSTR lpFileName,
    LPDWORD lpFileSizeHigh
    );


//BOOL DeleteFileA(LPCSTR lpFileName);
BOOL DeleteFileW(LPCWSTR lpFileName);

//#if(_WIN32_WINNT >= 0x0400)
enum FINDEX_INFO_LEVELS {
    FindExInfoStandard,
    FindExInfoMaxInfoLevel
} 

enum FINDEX_SEARCH_OPS {
    FindExSearchNameMatch,
    FindExSearchLimitToDirectories,
    FindExSearchLimitToDevices,
    FindExSearchMaxSearchOp
} 

enum { FIND_FIRST_EX_CASE_SENSITIVE    = 0x00000001 }


HANDLE
FindFirstFileExA(
    LPCSTR lpFileName,
    FINDEX_INFO_LEVELS fInfoLevelId,
    LPVOID lpFindFileData,
    FINDEX_SEARCH_OPS fSearchOp,
    LPVOID lpSearchFilter,
    DWORD dwAdditionalFlags
    );

HANDLE
FindFirstFileExW(
    LPCWSTR lpFileName,
    FINDEX_INFO_LEVELS fInfoLevelId,
    LPVOID lpFindFileData,
    FINDEX_SEARCH_OPS fSearchOp,
    LPVOID lpSearchFilter,
    DWORD dwAdditionalFlags
    );

//HANDLE FindFirstFileA(LPCSTR lpFileName,LPWIN32_FIND_DATAA lpFindFileData);
HANDLE FindFirstFileW(LPCWSTR lpFileName,LPWIN32_FIND_DATAW lpFindFileData);

//BOOL FindNextFileA(HANDLE hFindFile,LPWIN32_FIND_DATAA lpFindFileData);
BOOL FindNextFileW(HANDLE hFindFile,LPWIN32_FIND_DATAW lpFindFileData);

DWORD
SearchPathA(
    LPCSTR lpPath,
    LPCSTR lpFileName,
    LPCSTR lpExtension,
    DWORD nBufferLength,
    LPSTR lpBuffer,
    LPSTR *lpFilePart
    );

DWORD
SearchPathW(
    LPCWSTR lpPath,
    LPCWSTR lpFileName,
    LPCWSTR lpExtension,
    DWORD nBufferLength,
    LPWSTR lpBuffer,
    LPWSTR *lpFilePart
    );

BOOL
CopyFileA(
    LPCSTR lpExistingFileName,
    LPCSTR lpNewFileName,
    BOOL bFailIfExists
    );

BOOL
CopyFileW(
    LPCWSTR lpExistingFileName,
    LPCWSTR lpNewFileName,
    BOOL bFailIfExists
    );

alias DWORD (*LPPROGRESS_ROUTINE)(
    LARGE_INTEGER TotalFileSize,
    LARGE_INTEGER TotalBytesTransferred,
    LARGE_INTEGER StreamSize,
    LARGE_INTEGER StreamBytesTransferred,
    DWORD dwStreamNumber,
    DWORD dwReason,
    HANDLE hSourceFile,
    HANDLE hDestinationFile,
    LPVOID lpData 
    );

BOOL
CopyFileExA(
    LPCSTR lpExistingFileName,
    LPCSTR lpNewFileName,
    LPPROGRESS_ROUTINE lpProgressRoutine,
    LPVOID lpData ,
    LPBOOL pbCancel ,
    DWORD dwCopyFlags
    );

BOOL
CopyFileExW(
    LPCWSTR lpExistingFileName,
    LPCWSTR lpNewFileName,
    LPPROGRESS_ROUTINE lpProgressRoutine ,
    LPVOID lpData ,
    LPBOOL pbCancel ,
    DWORD dwCopyFlags
    );

//BOOL MoveFileA(LPCSTR lpExistingFileName,LPCSTR lpNewFileName);
BOOL MoveFileW(LPCWSTR lpExistingFileName,LPCWSTR lpNewFileName);

BOOL
MoveFileExA(
    LPCSTR lpExistingFileName,
    LPCSTR lpNewFileName,
    DWORD dwFlags
    );

BOOL
MoveFileExW(
    LPCWSTR lpExistingFileName,
    LPCWSTR lpNewFileName,
    DWORD dwFlags
    );

enum {
MOVEFILE_REPLACE_EXISTING   =0x00000001,
MOVEFILE_COPY_ALLOWED       =0x00000002,
MOVEFILE_DELAY_UNTIL_REBOOT =0x00000004,
MOVEFILE_WRITE_THROUGH      =0x00000008
}


HANDLE
CreateNamedPipeA(
    LPCSTR lpName,
    DWORD dwOpenMode,
    DWORD dwPipeMode,
    DWORD nMaxInstances,
    DWORD nOutBufferSize,
    DWORD nInBufferSize,
    DWORD nDefaultTimeOut,
    LPSECURITY_ATTRIBUTES lpSecurityAttributes
    );

HANDLE
CreateNamedPipeW(
    LPCWSTR lpName,
    DWORD dwOpenMode,
    DWORD dwPipeMode,
    DWORD nMaxInstances,
    DWORD nOutBufferSize,
    DWORD nInBufferSize,
    DWORD nDefaultTimeOut,
    LPSECURITY_ATTRIBUTES lpSecurityAttributes
    );

BOOL
GetNamedPipeHandleStateA(
    HANDLE hNamedPipe,
    LPDWORD lpState,
    LPDWORD lpCurInstances,
    LPDWORD lpMaxCollectionCount,
    LPDWORD lpCollectDataTimeout,
    LPSTR lpUserName,
    DWORD nMaxUserNameSize
    );

BOOL
GetNamedPipeHandleStateW(
    HANDLE hNamedPipe,
    LPDWORD lpState,
    LPDWORD lpCurInstances,
    LPDWORD lpMaxCollectionCount,
    LPDWORD lpCollectDataTimeout,
    LPWSTR lpUserName,
    DWORD nMaxUserNameSize
    );

BOOL
CallNamedPipeA(
    LPCSTR lpNamedPipeName,
    LPVOID lpInBuffer,
    DWORD nInBufferSize,
    LPVOID lpOutBuffer,
    DWORD nOutBufferSize,
    LPDWORD lpBytesRead,
    DWORD nTimeOut
    );

BOOL
CallNamedPipeW(
    LPCWSTR lpNamedPipeName,
    LPVOID lpInBuffer,
    DWORD nInBufferSize,
    LPVOID lpOutBuffer,
    DWORD nOutBufferSize,
    LPDWORD lpBytesRead,
    DWORD nTimeOut
    );

BOOL
WaitNamedPipeA(
    LPCSTR lpNamedPipeName,
    DWORD nTimeOut
    );

BOOL
WaitNamedPipeW(
    LPCWSTR lpNamedPipeName,
    DWORD nTimeOut
    );

BOOL
SetVolumeLabelA(
    LPCSTR lpRootPathName,
    LPCSTR lpVolumeName
    );

BOOL
SetVolumeLabelW(
    LPCWSTR lpRootPathName,
    LPCWSTR lpVolumeName
    );

VOID SetFileApisToOEM( );


VOID SetFileApisToANSI(  );


BOOL AreFileApisANSI(  );


BOOL
GetVolumeInformationA(
    LPCSTR lpRootPathName,
    LPSTR lpVolumeNameBuffer,
    DWORD nVolumeNameSize,
    LPDWORD lpVolumeSerialNumber,
    LPDWORD lpMaximumComponentLength,
    LPDWORD lpFileSystemFlags,
    LPSTR lpFileSystemNameBuffer,
    DWORD nFileSystemNameSize
    );

BOOL
GetVolumeInformationW(
    LPCWSTR lpRootPathName,
    LPWSTR lpVolumeNameBuffer,
    DWORD nVolumeNameSize,
    LPDWORD lpVolumeSerialNumber,
    LPDWORD lpMaximumComponentLength,
    LPDWORD lpFileSystemFlags,
    LPWSTR lpFileSystemNameBuffer,
    DWORD nFileSystemNameSize
    );


BOOL CancelIo(    HANDLE hFile    );

//
// Event logging APIs
//


BOOL ClearEventLogA(HANDLE hEventLog,LPCSTR lpBackupFileName);

BOOL ClearEventLogW(HANDLE hEventLog,LPCWSTR lpBackupFileName);

BOOL BackupEventLogA(HANDLE hEventLog,LPCSTR lpBackupFileName);

BOOL BackupEventLogW(HANDLE hEventLog,LPCWSTR lpBackupFileName);

BOOL CloseEventLog(HANDLE hEventLog );

BOOL DeregisterEventSource(HANDLE hEventLog);

BOOL NotifyChangeEventLog(HANDLE  hEventLog,HANDLE  hEvent);

BOOL GetNumberOfEventLogRecords(HANDLE hEventLog,PDWORD NumberOfRecords);


BOOL GetOldestEventLogRecord(HANDLE hEventLog,PDWORD OldestRecord);


HANDLE OpenEventLogA(LPCSTR lpUNCServerName,LPCSTR lpSourceName);
HANDLE OpenEventLogW(LPCWSTR lpUNCServerName,LPCWSTR lpSourceName);

HANDLE RegisterEventSourceA(LPCSTR lpUNCServerName,LPCSTR lpSourceName);
HANDLE RegisterEventSourceW(LPCWSTR lpUNCServerName,LPCWSTR lpSourceName);

HANDLE OpenBackupEventLogA(LPCSTR lpUNCServerName,LPCSTR lpFileName);
HANDLE OpenBackupEventLogW(LPCWSTR lpUNCServerName,LPCWSTR lpFileName);


BOOL
ReadEventLogA (
     HANDLE     hEventLog,
     DWORD      dwReadFlags,
     DWORD      dwRecordOffset,
     LPVOID     lpBuffer,
     DWORD      nNumberOfBytesToRead,
     DWORD      *pnBytesRead,
     DWORD      *pnMinNumberOfBytesNeeded
    );

BOOL
ReadEventLogW (
     HANDLE     hEventLog,
     DWORD      dwReadFlags,
     DWORD      dwRecordOffset,
     LPVOID     lpBuffer,
     DWORD      nNumberOfBytesToRead,
     DWORD      *pnBytesRead,
     DWORD      *pnMinNumberOfBytesNeeded
    );


BOOL
ReportEventA (
     HANDLE     hEventLog,
     WORD       wType,
     WORD       wCategory,
     DWORD      dwEventID,
     PSID       lpUserSid,
     WORD       wNumStrings,
     DWORD      dwDataSize,
     LPCSTR   *lpStrings,
     LPVOID     lpRawData
    );

BOOL
ReportEventW (
     HANDLE     hEventLog,
     WORD       wType,
     WORD       wCategory,
     DWORD      dwEventID,
     PSID       lpUserSid,
     WORD       wNumStrings,
     DWORD      dwDataSize,
     LPCWSTR   *lpStrings,
     LPVOID     lpRawData
    );

//
//
// Security APIs
//



BOOL
DuplicateToken(
    HANDLE ExistingTokenHandle,
    SECURITY_IMPERSONATION_LEVEL ImpersonationLevel,
    PHANDLE DuplicateTokenHandle
    );


BOOL
GetKernelObjectSecurity (
    HANDLE Handle,
    SECURITY_INFORMATION RequestedInformation,
    PSECURITY_DESCRIPTOR pSecurityDescriptor,
    DWORD nLength,
    LPDWORD lpnLengthNeeded
    );


BOOL ImpersonateNamedPipeClient(    HANDLE hNamedPipe    );


BOOL
ImpersonateSelf(
    SECURITY_IMPERSONATION_LEVEL ImpersonationLevel
    );



BOOL RevertToSelf();

BOOL SetThreadToken(PHANDLE Thread,HANDLE Token);


BOOL
AccessCheck (
    PSECURITY_DESCRIPTOR pSecurityDescriptor,
    HANDLE ClientToken,
    DWORD DesiredAccess,
    PGENERIC_MAPPING GenericMapping,
    PPRIVILEGE_SET PrivilegeSet,
    LPDWORD PrivilegeSetLength,
    LPDWORD GrantedAccess,
    LPBOOL AccessStatus
    );



BOOL
OpenProcessToken (
    HANDLE ProcessHandle,
    DWORD DesiredAccess,
    PHANDLE TokenHandle
    );



BOOL
OpenThreadToken (
    HANDLE ThreadHandle,
    DWORD DesiredAccess,
    BOOL OpenAsSelf,
    PHANDLE TokenHandle
    );



BOOL
GetTokenInformation (
    HANDLE TokenHandle,
    TOKEN_INFORMATION_CLASS TokenInformationClass,
    LPVOID TokenInformation,
    DWORD TokenInformationLength,
    PDWORD ReturnLength
    );



BOOL
SetTokenInformation (
    HANDLE TokenHandle,
    TOKEN_INFORMATION_CLASS TokenInformationClass,
    LPVOID TokenInformation,
    DWORD TokenInformationLength
    );



BOOL
AdjustTokenPrivileges (
    HANDLE TokenHandle,
    BOOL DisableAllPrivileges,
    PTOKEN_PRIVILEGES NewState,
    DWORD BufferLength,
    PTOKEN_PRIVILEGES PreviousState,
    PDWORD ReturnLength
    );



BOOL
AdjustTokenGroups (
    HANDLE TokenHandle,
    BOOL ResetToDefault,
    PTOKEN_GROUPS NewState,
    DWORD BufferLength,
    PTOKEN_GROUPS PreviousState,
    PDWORD ReturnLength
    );



BOOL
PrivilegeCheck (
    HANDLE ClientToken,
    PPRIVILEGE_SET RequiredPrivileges,
    LPBOOL pfResult
    );



BOOL
AccessCheckAndAuditAlarmA (
    LPCSTR SubsystemName,
    LPVOID HandleId,
    LPSTR ObjectTypeName,
    LPSTR ObjectName,
    PSECURITY_DESCRIPTOR SecurityDescriptor,
    DWORD DesiredAccess,
    PGENERIC_MAPPING GenericMapping,
    BOOL ObjectCreation,
    LPDWORD GrantedAccess,
    LPBOOL AccessStatus,
    LPBOOL pfGenerateOnClose
    );

BOOL
AccessCheckAndAuditAlarmW (
    LPCWSTR SubsystemName,
    LPVOID HandleId,
    LPWSTR ObjectTypeName,
    LPWSTR ObjectName,
    PSECURITY_DESCRIPTOR SecurityDescriptor,
    DWORD DesiredAccess,
    PGENERIC_MAPPING GenericMapping,
    BOOL ObjectCreation,
    LPDWORD GrantedAccess,
    LPBOOL AccessStatus,
    LPBOOL pfGenerateOnClose
    );


BOOL
ObjectOpenAuditAlarmA (
    LPCSTR SubsystemName,
    LPVOID HandleId,
    LPSTR ObjectTypeName,
    LPSTR ObjectName,
    PSECURITY_DESCRIPTOR pSecurityDescriptor,
    HANDLE ClientToken,
    DWORD DesiredAccess,
    DWORD GrantedAccess,
    PPRIVILEGE_SET Privileges,
    BOOL ObjectCreation,
    BOOL AccessGranted,
    LPBOOL GenerateOnClose
    );

BOOL
ObjectOpenAuditAlarmW (
    LPCWSTR SubsystemName,
    LPVOID HandleId,
    LPWSTR ObjectTypeName,
    LPWSTR ObjectName,
    PSECURITY_DESCRIPTOR pSecurityDescriptor,
    HANDLE ClientToken,
    DWORD DesiredAccess,
    DWORD GrantedAccess,
    PPRIVILEGE_SET Privileges,
    BOOL ObjectCreation,
    BOOL AccessGranted,
    LPBOOL GenerateOnClose
    );


BOOL
ObjectPrivilegeAuditAlarmA (
    LPCSTR SubsystemName,
    LPVOID HandleId,
    HANDLE ClientToken,
    DWORD DesiredAccess,
    PPRIVILEGE_SET Privileges,
    BOOL AccessGranted
    );

BOOL
ObjectPrivilegeAuditAlarmW (
    LPCWSTR SubsystemName,
    LPVOID HandleId,
    HANDLE ClientToken,
    DWORD DesiredAccess,
    PPRIVILEGE_SET Privileges,
    BOOL AccessGranted
    );

BOOL
ObjectCloseAuditAlarmA (
    LPCSTR SubsystemName,
    LPVOID HandleId,
    BOOL GenerateOnClose
    );

BOOL
ObjectCloseAuditAlarmW (
    LPCWSTR SubsystemName,
    LPVOID HandleId,
    BOOL GenerateOnClose
    );


BOOL
ObjectDeleteAuditAlarmA (
    LPCSTR SubsystemName,
    LPVOID HandleId,
    BOOL GenerateOnClose
    );

BOOL
ObjectDeleteAuditAlarmW (
    LPCWSTR SubsystemName,
    LPVOID HandleId,
    BOOL GenerateOnClose
    );

BOOL
PrivilegedServiceAuditAlarmA (
    LPCSTR SubsystemName,
    LPCSTR ServiceName,
    HANDLE ClientToken,
    PPRIVILEGE_SET Privileges,
    BOOL AccessGranted
    );

BOOL
PrivilegedServiceAuditAlarmW (
    LPCWSTR SubsystemName,
    LPCWSTR ServiceName,
    HANDLE ClientToken,
    PPRIVILEGE_SET Privileges,
    BOOL AccessGranted
    );


BOOL IsValidSid(PSID pSid);
BOOL EqualSid(PSID pSid1,PSID pSid2);
BOOL EqualPrefixSid (PSID pSid1,PSID pSid2);


DWORD
GetSidLengthRequired (
    UCHAR nSubAuthorityCount
    );


BOOL
AllocateAndInitializeSid (
    PSID_IDENTIFIER_AUTHORITY pIdentifierAuthority,
    BYTE nSubAuthorityCount,
    DWORD nSubAuthority0,
    DWORD nSubAuthority1,
    DWORD nSubAuthority2,
    DWORD nSubAuthority3,
    DWORD nSubAuthority4,
    DWORD nSubAuthority5,
    DWORD nSubAuthority6,
    DWORD nSubAuthority7,
    PSID *pSid
    );


PVOID FreeSid(PSID pSid);

BOOL
InitializeSid (
	PSID Sid,
   PSID_IDENTIFIER_AUTHORITY pIdentifierAuthority,
   BYTE nSubAuthorityCount
   );


PSID_IDENTIFIER_AUTHORITY
GetSidIdentifierAuthority (
    PSID pSid
    );



PDWORD GetSidSubAuthority(PSID pSid,DWORD nSubAuthority);

PUCHAR GetSidSubAuthorityCount(PSID pSid);


DWORD GetLengthSid(PSID pSid);


BOOL
CopySid (
    DWORD nDestinationSidLength,
    PSID pDestinationSid,
    PSID pSourceSid
    );



BOOL
AreAllAccessesGranted (
    DWORD GrantedAccess,
    DWORD DesiredAccess
    );



BOOL
AreAnyAccessesGranted (
    DWORD GrantedAccess,
    DWORD DesiredAccess
    );



VOID
MapGenericMask (
    PDWORD AccessMask,
    PGENERIC_MAPPING GenericMapping
    );



BOOL IsValidAcl(PACL pAcl);


BOOL
InitializeAcl (
    PACL pAcl,
    DWORD nAclLength,
    DWORD dwAclRevision
    );



BOOL
GetAclInformation (
    PACL pAcl,
    LPVOID pAclInformation,
    DWORD nAclInformationLength,
    ACL_INFORMATION_CLASS dwAclInformationClass
    );



BOOL
SetAclInformation (
    PACL pAcl,
    LPVOID pAclInformation,
    DWORD nAclInformationLength,
    ACL_INFORMATION_CLASS dwAclInformationClass
    );



BOOL
AddAce (
    PACL pAcl,
    DWORD dwAceRevision,
    DWORD dwStartingAceIndex,
    LPVOID pAceList,
    DWORD nAceListLength
    );



BOOL
DeleteAce (
    PACL pAcl,
    DWORD dwAceIndex
    );



BOOL
GetAce (
    PACL pAcl,
    DWORD dwAceIndex,
    LPVOID *pAce
    );



BOOL
AddAccessAllowedAce (
    PACL pAcl,
    DWORD dwAceRevision,
    DWORD AccessMask,
    PSID pSid
    );



BOOL
AddAccessDeniedAce (
    PACL pAcl,
    DWORD dwAceRevision,
    DWORD AccessMask,
    PSID pSid
    );



BOOL
AddAuditAccessAce(
    PACL pAcl,
    DWORD dwAceRevision,
    DWORD dwAccessMask,
    PSID pSid,
    BOOL bAuditSuccess,
    BOOL bAuditFailure
    );



BOOL
FindFirstFreeAce (
    PACL pAcl,
    LPVOID *pAce
    );



BOOL
InitializeSecurityDescriptor (
    PSECURITY_DESCRIPTOR pSecurityDescriptor,
    DWORD dwRevision
    );



BOOL
IsValidSecurityDescriptor (
    PSECURITY_DESCRIPTOR pSecurityDescriptor
    );



DWORD
GetSecurityDescriptorLength (
    PSECURITY_DESCRIPTOR pSecurityDescriptor
    );



BOOL
GetSecurityDescriptorControl (
    PSECURITY_DESCRIPTOR pSecurityDescriptor,
    PSECURITY_DESCRIPTOR_CONTROL pControl,
    LPDWORD lpdwRevision
    );



BOOL
SetSecurityDescriptorDacl (
    PSECURITY_DESCRIPTOR pSecurityDescriptor,
    BOOL bDaclPresent,
    PACL pDacl,
    BOOL bDaclDefaulted
    );



BOOL
GetSecurityDescriptorDacl (
    PSECURITY_DESCRIPTOR pSecurityDescriptor,
    LPBOOL lpbDaclPresent,
    PACL *pDacl,
    LPBOOL lpbDaclDefaulted
    );



BOOL
SetSecurityDescriptorSacl (
    PSECURITY_DESCRIPTOR pSecurityDescriptor,
    BOOL bSaclPresent,
    PACL pSacl,
    BOOL bSaclDefaulted
    );



BOOL
GetSecurityDescriptorSacl (
    PSECURITY_DESCRIPTOR pSecurityDescriptor,
    LPBOOL lpbSaclPresent,
    PACL *pSacl,
    LPBOOL lpbSaclDefaulted
    );



BOOL
SetSecurityDescriptorOwner (
    PSECURITY_DESCRIPTOR pSecurityDescriptor,
    PSID pOwner,
    BOOL bOwnerDefaulted
    );



BOOL
GetSecurityDescriptorOwner (
    PSECURITY_DESCRIPTOR pSecurityDescriptor,
    PSID *pOwner,
    LPBOOL lpbOwnerDefaulted
    );



BOOL
SetSecurityDescriptorGroup (
    PSECURITY_DESCRIPTOR pSecurityDescriptor,
    PSID pGroup,
    BOOL bGroupDefaulted
    );



BOOL
GetSecurityDescriptorGroup (
    PSECURITY_DESCRIPTOR pSecurityDescriptor,
    PSID *pGroup,
    LPBOOL lpbGroupDefaulted
    );



BOOL
CreatePrivateObjectSecurity (
    PSECURITY_DESCRIPTOR ParentDescriptor,
    PSECURITY_DESCRIPTOR CreatorDescriptor,
    PSECURITY_DESCRIPTOR * NewDescriptor,
    BOOL IsDirectoryObject,
    HANDLE Token,
    PGENERIC_MAPPING GenericMapping
    );



BOOL
SetPrivateObjectSecurity (
    SECURITY_INFORMATION SecurityInformation,
    PSECURITY_DESCRIPTOR ModificationDescriptor,
    PSECURITY_DESCRIPTOR *ObjectsSecurityDescriptor,
    PGENERIC_MAPPING GenericMapping,
    HANDLE Token
    );



BOOL
GetPrivateObjectSecurity (
    PSECURITY_DESCRIPTOR ObjectDescriptor,
    SECURITY_INFORMATION SecurityInformation,
    PSECURITY_DESCRIPTOR ResultantDescriptor,
    DWORD DescriptorLength,
    PDWORD ReturnLength
    );



BOOL
DestroyPrivateObjectSecurity (
    PSECURITY_DESCRIPTOR * ObjectDescriptor
    );



BOOL
MakeSelfRelativeSD (
    PSECURITY_DESCRIPTOR pAbsoluteSecurityDescriptor,
    PSECURITY_DESCRIPTOR pSelfRelativeSecurityDescriptor,
    LPDWORD lpdwBufferLength
    );



BOOL
MakeAbsoluteSD (
    PSECURITY_DESCRIPTOR pSelfRelativeSecurityDescriptor,
    PSECURITY_DESCRIPTOR pAbsoluteSecurityDescriptor,
    LPDWORD lpdwAbsoluteSecurityDescriptorSize,
    PACL pDacl,
    LPDWORD lpdwDaclSize,
    PACL pSacl,
    LPDWORD lpdwSaclSize,
    PSID pOwner,
    LPDWORD lpdwOwnerSize,
    PSID pPrimaryGroup,
    LPDWORD lpdwPrimaryGroupSize
    );



BOOL
SetFileSecurityA (
    LPCSTR lpFileName,
    SECURITY_INFORMATION SecurityInformation,
    PSECURITY_DESCRIPTOR pSecurityDescriptor
    );

BOOL
SetFileSecurityW (
    LPCWSTR lpFileName,
    SECURITY_INFORMATION SecurityInformation,
    PSECURITY_DESCRIPTOR pSecurityDescriptor
    );

BOOL
GetFileSecurityA (
    LPCSTR lpFileName,
    SECURITY_INFORMATION RequestedInformation,
    PSECURITY_DESCRIPTOR pSecurityDescriptor,
    DWORD nLength,
    LPDWORD lpnLengthNeeded
    );

BOOL
GetFileSecurityW (
    LPCWSTR lpFileName,
    SECURITY_INFORMATION RequestedInformation,
    PSECURITY_DESCRIPTOR pSecurityDescriptor,
    DWORD nLength,
    LPDWORD lpnLengthNeeded
    );

BOOL
SetKernelObjectSecurity (
    HANDLE Handle,
    SECURITY_INFORMATION SecurityInformation,
    PSECURITY_DESCRIPTOR SecurityDescriptor
    );


HANDLE
FindFirstChangeNotificationA(
    LPCSTR lpPathName,
    BOOL bWatchSubtree,
    DWORD dwNotifyFilter
    );

HANDLE
FindFirstChangeNotificationW(
    LPCWSTR lpPathName,
    BOOL bWatchSubtree,
    DWORD dwNotifyFilter
    );

BOOL
FindNextChangeNotification(
    HANDLE hChangeHandle
    );


BOOL
FindCloseChangeNotification(
    HANDLE hChangeHandle
    );


BOOL
ReadDirectoryChangesW(
    HANDLE hDirectory,
    LPVOID lpBuffer,
    DWORD nBufferLength,
    BOOL bWatchSubtree,
    DWORD dwNotifyFilter,
    LPDWORD lpBytesReturned,
    LPOVERLAPPED lpOverlapped,
    LPOVERLAPPED_COMPLETION_ROUTINE lpCompletionRoutine
    );


BOOL
VirtualLock(
    LPVOID lpAddress,
    DWORD dwSize
    );


BOOL
VirtualUnlock(
    LPVOID lpAddress,
    DWORD dwSize
    );


LPVOID
MapViewOfFileEx(
    HANDLE hFileMappingObject,
    DWORD dwDesiredAccess,
    DWORD dwFileOffsetHigh,
    DWORD dwFileOffsetLow,
    DWORD dwNumberOfBytesToMap,
    LPVOID lpBaseAddress
    );


BOOL
SetPriorityClass(
    HANDLE hProcess,
    DWORD dwPriorityClass
    );


DWORD
GetPriorityClass(
    HANDLE hProcess
    );


BOOL
IsBadReadPtr(
    VOID *lp,
    UINT ucb
    );


BOOL
IsBadWritePtr(
    LPVOID lp,
    UINT ucb
    );


BOOL
IsBadHugeReadPtr(
    VOID *lp,
    UINT ucb
    );


BOOL
IsBadHugeWritePtr(
    LPVOID lp,
    UINT ucb
    );


BOOL
IsBadCodePtr(
    FARPROC lpfn
    );


BOOL
IsBadStringPtrA(
    LPCSTR lpsz,
    UINT ucchMax
    );

BOOL
IsBadStringPtrW(
    LPCWSTR lpsz,
    UINT ucchMax
    );

BOOL
LookupAccountSidA(
    LPCSTR lpSystemName,
    PSID Sid,
    LPSTR Name,
    LPDWORD cbName,
    LPSTR ReferencedDomainName,
    LPDWORD cbReferencedDomainName,
    PSID_NAME_USE peUse
    );

BOOL
LookupAccountSidW(
    LPCWSTR lpSystemName,
    PSID Sid,
    LPWSTR Name,
    LPDWORD cbName,
    LPWSTR ReferencedDomainName,
    LPDWORD cbReferencedDomainName,
    PSID_NAME_USE peUse
    );

BOOL
LookupAccountNameA(
    LPCSTR lpSystemName,
    LPCSTR lpAccountName,
    PSID Sid,
    LPDWORD cbSid,
    LPSTR ReferencedDomainName,
    LPDWORD cbReferencedDomainName,
    PSID_NAME_USE peUse
    );

BOOL
LookupAccountNameW(
    LPCWSTR lpSystemName,
    LPCWSTR lpAccountName,
    PSID Sid,
    LPDWORD cbSid,
    LPWSTR ReferencedDomainName,
    LPDWORD cbReferencedDomainName,
    PSID_NAME_USE peUse
    );

BOOL
LookupPrivilegeValueA(
    LPCSTR lpSystemName,
    LPCSTR lpName,
    PLUID   lpLuid
    );

BOOL
LookupPrivilegeValueW(
    LPCWSTR lpSystemName,
    LPCWSTR lpName,
    PLUID   lpLuid
    );

BOOL
LookupPrivilegeNameA(
    LPCSTR lpSystemName,
    PLUID   lpLuid,
    LPSTR lpName,
    LPDWORD cbName
    );

BOOL
LookupPrivilegeNameW(
    LPCWSTR lpSystemName,
    PLUID   lpLuid,
    LPWSTR lpName,
    LPDWORD cbName
    );

BOOL
LookupPrivilegeDisplayNameA(
    LPCSTR lpSystemName,
    LPCSTR lpName,
    LPSTR lpDisplayName,
    LPDWORD cbDisplayName,
    LPDWORD lpLanguageId
    );

BOOL
LookupPrivilegeDisplayNameW(
    LPCWSTR lpSystemName,
    LPCWSTR lpName,
    LPWSTR lpDisplayName,
    LPDWORD cbDisplayName,
    LPDWORD lpLanguageId
    );

BOOL
AllocateLocallyUniqueId(
    PLUID Luid
    );


BOOL
BuildCommDCBA(
    LPCSTR lpDef,
    LPDCB lpDCB
    );

BOOL
BuildCommDCBW(
    LPCWSTR lpDef,
    LPDCB lpDCB
    );

BOOL
BuildCommDCBAndTimeoutsA(
    LPCSTR lpDef,
    LPDCB lpDCB,
    LPCOMMTIMEOUTS lpCommTimeouts
    );

BOOL
BuildCommDCBAndTimeoutsW(
    LPCWSTR lpDef,
    LPDCB lpDCB,
    LPCOMMTIMEOUTS lpCommTimeouts
    );

BOOL
CommConfigDialogA(
    LPCSTR lpszName,
    HWND hWnd,
    LPCOMMCONFIG lpCC
    );

BOOL
CommConfigDialogW(
    LPCWSTR lpszName,
    HWND hWnd,
    LPCOMMCONFIG lpCC
    );

BOOL
GetDefaultCommConfigA(
    LPCSTR lpszName,
    LPCOMMCONFIG lpCC,
    LPDWORD lpdwSize
    );

BOOL
GetDefaultCommConfigW(
    LPCWSTR lpszName,
    LPCOMMCONFIG lpCC,
    LPDWORD lpdwSize
    );

BOOL
SetDefaultCommConfigA(
    LPCSTR lpszName,
    LPCOMMCONFIG lpCC,
    DWORD dwSize
    );

BOOL
SetDefaultCommConfigW(
    LPCWSTR lpszName,
    LPCOMMCONFIG lpCC,
    DWORD dwSize
    );

enum { MAX_COMPUTERNAME_LENGTH  = 15 }

BOOL GetComputerNameA(LPSTR lpBuffer,LPDWORD nSize);
BOOL GetComputerNameW(LPWSTR lpBuffer,LPDWORD nSize);

BOOL SetComputerNameA(LPCSTR lpComputerName);
BOOL SetComputerNameW(LPCWSTR lpComputerName);

BOOL GetUserNameA(LPSTR lpBuffer,LPDWORD nSize);
BOOL GetUserNameW(LPWSTR lpBuffer,LPDWORD nSize);

enum {
//
// Logon Support APIs
//
LOGON32_LOGON_INTERACTIVE   =2,
LOGON32_LOGON_NETWORK       =3,
LOGON32_LOGON_BATCH         =4,
LOGON32_LOGON_SERVICE       =5,

LOGON32_PROVIDER_DEFAULT    =0,
LOGON32_PROVIDER_WINNT35    =1,
LOGON32_PROVIDER_WINNT40    =2
}



BOOL
LogonUserA (
    LPSTR lpszUsername,
    LPSTR lpszDomain,
    LPSTR lpszPassword,
    DWORD dwLogonType,
    DWORD dwLogonProvider,
    PHANDLE phToken
    );

BOOL
LogonUserW (
    LPWSTR lpszUsername,
    LPWSTR lpszDomain,
    LPWSTR lpszPassword,
    DWORD dwLogonType,
    DWORD dwLogonProvider,
    PHANDLE phToken
    );


BOOL
ImpersonateLoggedOnUser(
    HANDLE  hToken
    );


BOOL
CreateProcessAsUserA (
    HANDLE hToken,
    LPCSTR lpApplicationName,
    LPSTR lpCommandLine,
    LPSECURITY_ATTRIBUTES lpProcessAttributes,
    LPSECURITY_ATTRIBUTES lpThreadAttributes,
    BOOL bInheritHandles,
    DWORD dwCreationFlags,
    LPVOID lpEnvironment,
    LPCSTR lpCurrentDirectory,
    LPSTARTUPINFOA lpStartupInfo,
    LPPROCESS_INFORMATION lpProcessInformation
    );

BOOL
CreateProcessAsUserW (
    HANDLE hToken,
    LPCWSTR lpApplicationName,
    LPWSTR lpCommandLine,
    LPSECURITY_ATTRIBUTES lpProcessAttributes,
    LPSECURITY_ATTRIBUTES lpThreadAttributes,
    BOOL bInheritHandles,
    DWORD dwCreationFlags,
    LPVOID lpEnvironment,
    LPCWSTR lpCurrentDirectory,
    LPSTARTUPINFOW lpStartupInfo,
    LPPROCESS_INFORMATION lpProcessInformation
    );


BOOL
DuplicateTokenEx(
    HANDLE hExistingToken,
    DWORD dwDesiredAccess,
    LPSECURITY_ATTRIBUTES lpTokenAttributes,
    SECURITY_IMPERSONATION_LEVEL ImpersonationLevel,
    TOKEN_TYPE TokenType,
    PHANDLE phNewToken);


//
// Plug-and-Play API's
//
enum {
HW_PROFILE_GUIDLEN         =39,      // 36-characters plus NULL terminator
MAX_PROFILE_LEN            =80
}

enum {
DOCKINFO_UNDOCKED          =(0x1),
DOCKINFO_DOCKED            =(0x2),
DOCKINFO_USER_SUPPLIED     =(0x4),
DOCKINFO_USER_UNDOCKED     =(DOCKINFO_USER_SUPPLIED | DOCKINFO_UNDOCKED),
DOCKINFO_USER_DOCKED       =(DOCKINFO_USER_SUPPLIED | DOCKINFO_DOCKED)
}

struct HW_PROFILE_INFOA {
    DWORD  dwDockInfo;
    CHAR   szHwProfileGuid[HW_PROFILE_GUIDLEN];
    CHAR   szHwProfileName[MAX_PROFILE_LEN];
} 
alias HW_PROFILE_INFOA * LPHW_PROFILE_INFOA;
struct HW_PROFILE_INFOW {
    DWORD  dwDockInfo;
    WCHAR  szHwProfileGuid[HW_PROFILE_GUIDLEN];
    WCHAR  szHwProfileName[MAX_PROFILE_LEN];
} 
alias HW_PROFILE_INFOW * LPHW_PROFILE_INFOW;



BOOL
GetCurrentHwProfileA (
    LPHW_PROFILE_INFOA  lpHwProfileInfo
    );

BOOL
GetCurrentHwProfileW (
    LPHW_PROFILE_INFOW  lpHwProfileInfo
    );

//
// Performance counter API's
//


BOOL
QueryPerformanceCounter(
    LARGE_INTEGER *lpPerformanceCount
    );


BOOL
QueryPerformanceFrequency(
    LARGE_INTEGER *lpFrequency
    );

struct OSVERSIONINFOA {
    DWORD dwOSVersionInfoSize;
    DWORD dwMajorVersion;
    DWORD dwMinorVersion;
    DWORD dwBuildNumber;
    DWORD dwPlatformId;
    CHAR   szCSDVersion[ 128 ];       // Maintenance string for PSS usage
} 
alias OSVERSIONINFOA * POSVERSIONINFOA,LPOSVERSIONINFOA;
struct OSVERSIONINFOW {
    DWORD dwOSVersionInfoSize;
    DWORD dwMajorVersion;
    DWORD dwMinorVersion;
    DWORD dwBuildNumber;
    DWORD dwPlatformId;
    WCHAR  szCSDVersion[ 128 ];       // Maintenance string for PSS usage
} 
alias OSVERSIONINFOW * POSVERSIONINFOW,LPOSVERSIONINFOW;

enum {
//
// dwPlatformId defines:
//
VER_PLATFORM_WIN32s             =0,
VER_PLATFORM_WIN32_WINDOWS      =1,
VER_PLATFORM_WIN32_NT           =2
}


BOOL
GetVersionExA(
    LPOSVERSIONINFOA lpVersionInformation
    );

BOOL
GetVersionExW(
    LPOSVERSIONINFOW lpVersionInformation
    );


// DOS and OS/2 Compatible Error Code definitions returned by the Win32 Base
// API functions.
//

//#include <winerror.h>

enum {
/* Abnormal termination codes */
TC_NORMAL       =0,
TC_HARDERR      =1,
TC_GP_TRAP      =2,
TC_SIGNAL       =3
}

enum {
//
// Power Management APIs
//
AC_LINE_OFFLINE                 =0x00,
AC_LINE_ONLINE                  =0x01,
AC_LINE_BACKUP_POWER            =0x02,
AC_LINE_UNKNOWN                 =0xFF
}

enum {
BATTERY_FLAG_HIGH               =0x01,
BATTERY_FLAG_LOW                =0x02,
BATTERY_FLAG_CRITICAL           =0x04,
BATTERY_FLAG_CHARGING           =0x08,
BATTERY_FLAG_NO_BATTERY         =0x80,
BATTERY_FLAG_UNKNOWN            =0xFF
}

enum { BATTERY_PERCENTAGE_UNKNOWN   =   0xFF }

enum : uint { BATTERY_LIFE_UNKNOWN        =0xFFFFFFFF }

struct SYSTEM_POWER_STATUS {
    BYTE ACLineStatus;
    BYTE BatteryFlag;
    BYTE BatteryLifePercent;
    BYTE Reserved1;
    DWORD BatteryLifeTime;
    DWORD BatteryFullLifeTime;
}   
alias SYSTEM_POWER_STATUS * LPSYSTEM_POWER_STATUS;

BOOL
GetSystemPowerStatus(
    LPSYSTEM_POWER_STATUS lpSystemPowerStatus
    );

BOOL
SetSystemPowerState(
    BOOL fSuspend,
    BOOL fForce
    );


///////////////////////////////////////////////////////////////
//                                                           //
//      Win Certificate API and Structures                   //
//                                                           //
///////////////////////////////////////////////////////////////

//
// Structures
//

struct WIN_CERTIFICATE {
    DWORD       dwLength;
    WORD        wRevision;
    WORD        wCertificateType;   // WIN_CERT_TYPE_xxx
    BYTE        bCertificate[ANYSIZE_ARRAY];
} 
alias WIN_CERTIFICATE * LPWIN_CERTIFICATE;

//
// Currently, the only defined certificate revision is WIN_CERT_REVISION_1_0
//

enum { WIN_CERT_REVISION_1_0           = (0x0100) }

//
// Possible certificate types are specified by the following values
//
enum { 
WIN_CERT_TYPE_X509               =(0x0001),   // bCertificate contains an X.509 Certificate
WIN_CERT_TYPE_PKCS_SIGNED_DATA   =(0x0002),   // bCertificate contains a PKCS SignedData structure
WIN_CERT_TYPE_RESERVED_1         =(0x0003)   // Reserved
}
//
// API
//


BOOL
WinSubmitCertificate(
    LPWIN_CERTIFICATE lpCertificate
    );


///////////////////////////////////////////////////////////////
//                                                           //
//             Trust API and Structures                      //
//                                                           //
///////////////////////////////////////////////////////////////

LONG
WinVerifyTrust(
    HWND    hwnd,
    GUID *  ActionID,
    LPVOID  ActionData
    );


BOOL
WinLoadTrustProvider(
    GUID * ActionID
    );

///////////////////////////////////////////////////////////////
//                                                           //
//             Common Trust API Data Structures              //
//                                                           //
///////////////////////////////////////////////////////////////


//
// Data type commonly used in ActionData structures
//

alias LPVOID WIN_TRUST_SUBJECT;

//
// Two commonly used ActionData structures
//

struct WIN_TRUST_ACTDATA_CONTEXT_WITH_SUBJECT {

    HANDLE            hClientToken;
    GUID *            SubjectType;
    WIN_TRUST_SUBJECT Subject;

} 
alias WIN_TRUST_ACTDATA_CONTEXT_WITH_SUBJECT * LPWIN_TRUST_ACTDATA_CONTEXT_WITH_SUBJECT ;


struct WIN_TRUST_ACTDATA_SUBJECT_ONLY {

    GUID *            SubjectType;
    WIN_TRUST_SUBJECT Subject;

} 
alias WIN_TRUST_ACTDATA_SUBJECT_ONLY * LPWIN_TRUST_ACTDATA_SUBJECT_ONLY;


////////////////////////////////////////////////////////////////////
//                                                                 /
//      SUBJECT FORM DEFINITIONS                                   /
//                                                                 /
////////////////////////////////////////////////////////////////////

////////////////////////////////////////////////////////////////////
//                                                                 /
// Currently defined Subject Type Identifiers.  All of the below   /
// use the WIN_TRUST_SUBJECT_FILE subject form, defined below.     /
//                                                                 /
////////////////////////////////////////////////////////////////////

/* RawFile == 959dc450-8d9e-11cf-8736-00aa00a485eb */
/*
//#define WIN_TRUST_SUBJTYPE_RAW_FILE                              \
            { 0x959dc450,                                        \
              0x8d9e,                                            \
              0x11cf,                                            \
              {0x87, 0x36, 0x00, 0xaa, 0x00, 0xa4, 0x85, 0xeb}   \
            }
*/
/* PeImage == 43c9a1e0-8da0-11cf-8736-00aa00a485eb */
/*
//#define WIN_TRUST_SUBJTYPE_PE_IMAGE                              \
            { 0x43c9a1e0,                                        \
              0x8da0,                                            \
              0x11cf,                                            \
              {0x87, 0x36, 0x00, 0xaa, 0x00, 0xa4, 0x85, 0xeb}   \
            }
*/

/* JavaClass = 08ad3990-8da1-11cf-8736-00aa00a485eb */
/*
//#define WIN_TRUST_SUBJTYPE_JAVA_CLASS                            \
            { 0x08ad3990,                                        \
              0x8da1,                                            \
              0x11cf,                                            \
              {0x87, 0x36, 0x00, 0xaa, 0x00, 0xa4, 0x85, 0xeb}   \
            }
				*/
/* Cabinet = d17c5374-a392-11cf-9df5-00aa00c184e0 */
/*
//#define WIN_TRUST_SUBJTYPE_CABINET                               \
            { 0xd17c5374,                                        \
              0xa392,                                            \
              0x11cf,                                            \
              { 0x9d, 0xf5, 0x0, 0xaa, 0x0, 0xc1, 0x84, 0xe0 }   \
            }
*/
//
// Associated Subject Data Structure:
//

struct WIN_TRUST_SUBJECT_FILE {

    HANDLE  hFile;
    LPCWSTR lpPath;

} 
alias WIN_TRUST_SUBJECT_FILE * LPWIN_TRUST_SUBJECT_FILE;

////////////////////////////////////////////////////////////////////
//                                                                 /
// The following subject types use the                             /
// WIN_TRUST_SUBJECT_FILE_AND_DISPLAY subject type, defined        /
// below.                                                          /
//                                                                 /
////////////////////////////////////////////////////////////////////
/*
//#define WIN_TRUST_SUBJTYPE_RAW_FILEEX                            \
            { 0x6f458110,                                        \
              0xc2f1,                                            \
              0x11cf,                                            \
              { 0x8a, 0x69, 0x0, 0xaa, 0x0, 0x6c, 0x37, 0x6 }    \
            }
//#define WIN_TRUST_SUBJTYPE_PE_IMAGEEX                            \
            { 0x6f458111,                                        \
              0xc2f1,                                            \
              0x11cf,                                            \
              { 0x8a, 0x69, 0x0, 0xaa, 0x0, 0x6c, 0x37, 0x6 }    \
            }

//#define WIN_TRUST_SUBJTYPE_JAVA_CLASSEX                          \
            { 0x6f458113,                                        \
              0xc2f1,                                            \
              0x11cf,                                            \
              { 0x8a, 0x69, 0x0, 0xaa, 0x0, 0x6c, 0x37, 0x6 }    \
            }

//#define WIN_TRUST_SUBJTYPE_CABINETEX                             \
            { 0x6f458114,                                        \
              0xc2f1,                                            \
              0x11cf,                                            \
              { 0x8a, 0x69, 0x0, 0xaa, 0x0, 0x6c, 0x37, 0x6 }    \
            }
*/

//
// Associated Subject Data Structure:
//

struct WIN_TRUST_SUBJECT_FILE_AND_DISPLAY {

    HANDLE  hFile;              // handle to the open file if you got it
    LPCWSTR lpPath;             // the path to open if you don't
    LPCWSTR lpDisplayName;      // (optional) display name to show to user 
                                //      in place of path

} 
alias WIN_TRUST_SUBJECT_FILE_AND_DISPLAY * LPWIN_TRUST_SUBJECT_FILE_AND_DISPLAY;


////////////////////////////////////////////////////////////////////
//                                                                 /
// Other subject types:                                            /
//                                                                 /
////////////////////////////////////////////////////////////////////

/* OleStorage == c257e740-8da0-11cf-8736-00aa00a485eb */
/*
//#define WIN_TRUST_SUBJTYPE_OLE_STORAGE                           \
            { 0xc257e740,                                        \
              0x8da0,                                            \
              0x11cf,                                            \
              {0x87, 0x36, 0x00, 0xaa, 0x00, 0xa4, 0x85, 0xeb}   \
            }
*/

////////////////////////////////////////////////////////////////////
//                                                                 /
//      TRUST PROVIDER SPECIFIC DEFINITIONS                        /
//                                                                 /
//                                                                 /
//      Each trust provider will have the following                /
//      sections defined:                                          /
//                                                                 /
//      Actions - What actions are supported by the trust          /
//          provider.                                              /
//                                                                 /
//      SubjectForms - Subjects that may be evaluated by this      /
//          trust provider.                                        /
//                                                                 /
//                     and                                         /
//                                                                 /
//      Data structures to support the subject forms.              /
//                                                                 /
//                                                                 /
////////////////////////////////////////////////////////////////////


////////////////////////////////////////////////////////////////////
//                                                                 /
//             Software Publisher Trust Provider                   /
//                                                                 /
////////////////////////////////////////////////////////////////////

//
// Actions:
//

/* TrustedPublisher == 66426730-8da1-11cf-8736-00aa00a485eb */
/*
//#define WIN_SPUB_ACTION_TRUSTED_PUBLISHER                        \
            { 0x66426730,                                        \
              0x8da1,                                            \
              0x11cf,                                            \
              {0x87, 0x36, 0x00, 0xaa, 0x00, 0xa4, 0x85, 0xeb}   \
            }
*/
/* NtActivateImage == 8bc96b00-8da1-11cf-8736-00aa00a485eb */
/*
//#define     WIN_SPUB_ACTION_NT_ACTIVATE_IMAGE                    \
            { 0x8bc96b00,                                        \
              0x8da1,                                            \
              0x11cf,                                            \
              {0x87, 0x36, 0x00, 0xaa, 0x00, 0xa4, 0x85, 0xeb}   \
            }
*/
/* PublishedSoftware == 64b9d180-8da2-11cf-8736-00aa00a485eb */
/*
//#define WIN_SPUB_ACTION_PUBLISHED_SOFTWARE                       \
            { 0x64b9d180,                                        \
              0x8da2,                                            \
              0x11cf,                                            \
              {0x87, 0x36, 0x00, 0xaa, 0x00, 0xa4, 0x85, 0xeb}   \
            }
*/
//
// Data Structures:
//
// WIN_SPUB_ACTION_TRUSTED_PUBLISHER:
//
//      Uses WIN_SPUB_TRUSTED_PUBLISHER_DATA
//
// WIN_SPUB_ACTION_NT_ACTIVATE_IMAGE:
//
//      Uses WIN_TRUST_ACTDATA_CONTEXT_WITH_SUBJECT
//
// WIN_SPUB_ACTION_PUBLISHED_SOFTWARE:
//
//      Uses WIN_TRUST_ACTDATA_CONTEXT_WITH_SUBJECT
//

struct WIN_SPUB_TRUSTED_PUBLISHER_DATA {

    HANDLE            hClientToken;
    LPWIN_CERTIFICATE lpCertificate;

} 
alias WIN_SPUB_TRUSTED_PUBLISHER_DATA * LPWIN_SPUB_TRUSTED_PUBLISHER_DATA;


} //extern (Windows)
