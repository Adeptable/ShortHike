module wingdi;
import windef;
import winbase;

/*
 * win gdi stuff ported to D from 
 */

/**************************************************************************
* wingdi.h -- GDI procedure declarations, constant definitions and macros *
* Copyright (c) 1985-1996, Microsoft Corp. All rights reserved.           *
**************************************************************************/

extern (Windows)
{

//
// Define API decoration for direct importing of DLL references.
//

enum {
/* Binary raster ops */
R2_BLACK            =1,   /*  0       */
R2_NOTMERGEPEN      =2,   /* DPon     */
R2_MASKNOTPEN       =3,   /* DPna     */
R2_NOTCOPYPEN       =4,   /* PN       */
R2_MASKPENNOT       =5,   /* PDna     */
R2_NOT              =6,   /* Dn       */
R2_XORPEN           =7,   /* DPx      */
R2_NOTMASKPEN       =8,   /* DPan     */
R2_MASKPEN          =9,   /* DPa      */
R2_NOTXORPEN        =10,  /* DPxn     */
R2_NOP              =11,  /* D        */
R2_MERGENOTPEN      =12,  /* DPno     */
R2_COPYPEN          =13,  /* P        */
R2_MERGEPENNOT      =14,  /* PDno     */
R2_MERGEPEN         =15,  /* DPo      */
R2_WHITE            =16,  /*  1       */
R2_LAST             =16
}

enum : uint {
/* Ternary raster operations */
SRCCOPY             =(DWORD)0x00CC0020, /* dest = source                   */
SRCPAINT            =(DWORD)0x00EE0086, /* dest = source OR dest           */
SRCAND              =(DWORD)0x008800C6, /* dest = source AND dest          */
SRCINVERT           =(DWORD)0x00660046, /* dest = source XOR dest          */
SRCERASE            =(DWORD)0x00440328, /* dest = source AND (NOT dest )   */
NOTSRCCOPY          =(DWORD)0x00330008, /* dest = (NOT source)             */
NOTSRCERASE         =(DWORD)0x001100A6, /* dest = (NOT src) AND (NOT dest) */
MERGECOPY           =(DWORD)0x00C000CA, /* dest = (source AND pattern)     */
MERGEPAINT          =(DWORD)0x00BB0226, /* dest = (NOT source) OR dest     */
PATCOPY             =(DWORD)0x00F00021, /* dest = pattern                  */
PATPAINT            =(DWORD)0x00FB0A09, /* dest = DPSnoo                   */
PATINVERT           =(DWORD)0x005A0049, /* dest = pattern XOR dest         */
DSTINVERT           =(DWORD)0x00550009, /* dest = (NOT dest)               */
BLACKNESS           =(DWORD)0x00000042, /* dest = BLACK                    */
WHITENESS           =(DWORD)0x00FF0062  /* dest = WHITE                    */
}

/* Quaternary raster codes */
//#define MAKEROP4(fore,back) (DWORD)((((back) << 8) & 0xFF000000) | (fore))

const uint GDI_ERROR = (0xFFFFFFFFL);
const HANDLE HGDI_ERROR = ((HANDLE)(0xFFFFFFFFL));

enum {
/* Region Flags */
ERROR               =0,
NULLREGION          =1,
SIMPLEREGION        =2,
COMPLEXREGION       =3
}

enum {
/* CombineRgn() Styles */
RGN_AND             =1,
RGN_OR              =2,
RGN_XOR             =3,
RGN_DIFF            =4,
RGN_COPY            =5,
RGN_MIN             =RGN_AND,
RGN_MAX             =RGN_COPY
}

enum {
/* StretchBlt() Modes */
BLACKONWHITE                 =1,
WHITEONBLACK                 =2,
COLORONCOLOR                 =3,
HALFTONE                     =4,
MAXSTRETCHBLTMODE            =4,

/* New StretchBlt() Modes */
STRETCH_ANDSCANS    =BLACKONWHITE,
STRETCH_ORSCANS     =WHITEONBLACK,
STRETCH_DELETESCANS =COLORONCOLOR,
STRETCH_HALFTONE    =HALFTONE
}

enum {
/* PolyFill() Modes */
ALTERNATE                    =1,
WINDING                      =2,
POLYFILL_LAST                =2
}

enum {
/* Text Alignment Options */
TA_NOUPDATECP                =0,
TA_UPDATECP                  =1,

TA_LEFT                      =0,
TA_RIGHT                     =2,
TA_CENTER                    =6,

TA_TOP                       =0,
TA_BOTTOM                    =8,
TA_BASELINE                  =24,
TA_RTLREADING                =256,
TA_MASK       =(TA_BASELINE+TA_CENTER+TA_UPDATECP+TA_RTLREADING),

VTA_BASELINE =TA_BASELINE,
VTA_LEFT     =TA_BOTTOM,
VTA_RIGHT    =TA_TOP,
VTA_CENTER   =TA_CENTER,
VTA_BOTTOM   =TA_RIGHT,
VTA_TOP      =TA_LEFT
}

enum {
ETO_OPAQUE                   =0x0002,
ETO_CLIPPED                  =0x0004,
ETO_GLYPH_INDEX              =0x0010,
ETO_RTLREADING               =0x0080,
ETO_IGNORELANGUAGE           =0x1000
}

enum {
ASPECT_FILTERING             = 0x0001
}

enum {
/* Bounds Accumulation APIs */
DCB_RESET       =0x0001,
DCB_ACCUMULATE  =0x0002,
DCB_DIRTY       =DCB_ACCUMULATE,
DCB_SET         =(DCB_RESET | DCB_ACCUMULATE),
DCB_ENABLE      =0x0004,
DCB_DISABLE     =0x0008
}

enum {
/* Metafile Functions */
META_SETBKCOLOR              =0x0201,
META_SETBKMODE               =0x0102,
META_SETMAPMODE              =0x0103,
META_SETROP2                 =0x0104,
META_SETRELABS               =0x0105,
META_SETPOLYFILLMODE         =0x0106,
META_SETSTRETCHBLTMODE       =0x0107,
META_SETTEXTCHAREXTRA        =0x0108,
META_SETTEXTCOLOR            =0x0209,
META_SETTEXTJUSTIFICATION    =0x020A,
META_SETWINDOWORG            =0x020B,
META_SETWINDOWEXT            =0x020C,
META_SETVIEWPORTORG          =0x020D,
META_SETVIEWPORTEXT          =0x020E,
META_OFFSETWINDOWORG         =0x020F,
META_SCALEWINDOWEXT          =0x0410,
META_OFFSETVIEWPORTORG       =0x0211,
META_SCALEVIEWPORTEXT        =0x0412,
META_LINETO                  =0x0213,
META_MOVETO                  =0x0214,
META_EXCLUDECLIPRECT         =0x0415,
META_INTERSECTCLIPRECT       =0x0416,
META_ARC                     =0x0817,
META_ELLIPSE                 =0x0418,
META_FLOODFILL               =0x0419,
META_PIE                     =0x081A,
META_RECTANGLE               =0x041B,
META_ROUNDRECT               =0x061C,
META_PATBLT                  =0x061D,
META_SAVEDC                  =0x001E,
META_SETPIXEL                =0x041F,
META_OFFSETCLIPRGN           =0x0220,
META_TEXTOUT                 =0x0521,
META_BITBLT                  =0x0922,
META_STRETCHBLT              =0x0B23,
META_POLYGON                 =0x0324,
META_POLYLINE                =0x0325,
META_ESCAPE                  =0x0626,
META_RESTOREDC               =0x0127,
META_FILLREGION              =0x0228,
META_FRAMEREGION             =0x0429,
META_INVERTREGION            =0x012A,
META_PAINTREGION             =0x012B,
META_SELECTCLIPREGION        =0x012C,
META_SELECTOBJECT            =0x012D,
META_SETTEXTALIGN            =0x012E,
META_CHORD                   =0x0830,
META_SETMAPPERFLAGS          =0x0231,
META_EXTTEXTOUT              =0x0a32,
META_SETDIBTODEV             =0x0d33,
META_SELECTPALETTE           =0x0234,
META_REALIZEPALETTE          =0x0035,
META_ANIMATEPALETTE          =0x0436,
META_SETPALENTRIES           =0x0037,
META_POLYPOLYGON             =0x0538,
META_RESIZEPALETTE           =0x0139,
META_DIBBITBLT               =0x0940,
META_DIBSTRETCHBLT           =0x0b41,
META_DIBCREATEPATTERNBRUSH   =0x0142,
META_STRETCHDIB              =0x0f43,
META_EXTFLOODFILL            =0x0548,
META_DELETEOBJECT            =0x01f0,
META_CREATEPALETTE           =0x00f7,
META_CREATEPATTERNBRUSH      =0x01F9,
META_CREATEPENINDIRECT       =0x02FA,
META_CREATEFONTINDIRECT      =0x02FB,
META_CREATEBRUSHINDIRECT     =0x02FC,
META_CREATEREGION            =0x06FF
}

enum {
/* GDI Escapes */
NEWFRAME                     =1,
ABORTDOC                     =2,
NEXTBAND                     =3,
SETCOLORTABLE                =4,
GETCOLORTABLE                =5,
FLUSHOUTPUT                  =6,
DRAFTMODE                    =7,
QUERYESCSUPPORT              =8,
SETABORTPROC                 =9,
STARTDOC                     =10,
ENDDOC                       =11,
GETPHYSPAGESIZE              =12,
GETPRINTINGOFFSET            =13,
GETSCALINGFACTOR             =14,
MFCOMMENT                    =15,
GETPENWIDTH                  =16,
SETCOPYCOUNT                 =17,
SELECTPAPERSOURCE            =18,
DEVICEDATA                   =19,
PASSTHROUGH                  =19,
GETTECHNOLGY                 =20,
GETTECHNOLOGY                =20,
SETLINECAP                   =21,
SETLINEJOIN                  =22,
SETMITERLIMIT                =23,
BANDINFO                     =24,
DRAWPATTERNRECT              =25,
GETVECTORPENSIZE             =26,
GETVECTORBRUSHSIZE           =27,
ENABLEDUPLEX                 =28,
GETSETPAPERBINS              =29,
GETSETPRINTORIENT            =30,
ENUMPAPERBINS                =31,
SETDIBSCALING                =32,
EPSPRINTING                  =33,
ENUMPAPERMETRICS             =34,
GETSETPAPERMETRICS           =35,
POSTSCRIPT_DATA              =37,
POSTSCRIPT_IGNORE            =38,
MOUSETRAILS                  =39,
GETDEVICEUNITS               =42,

GETEXTENDEDTEXTMETRICS       =256,
GETEXTENTTABLE               =257,
GETPAIRKERNTABLE             =258,
GETTRACKKERNTABLE            =259,
EXTTEXTOUT                   =512,
GETFACENAME                  =513,
DOWNLOADFACE                 =514,
ENABLERELATIVEWIDTHS         =768,
ENABLEPAIRKERNING            =769,
SETKERNTRACK                 =770,
SETALLJUSTVALUES             =771,
SETCHARSET                   =772,

STRETCHBLT                   =2048,
GETSETSCREENPARAMS           =3072,
QUERYDIBSUPPORT              =3073,
BEGIN_PATH                   =4096,
CLIP_TO_PATH                 =4097,
END_PATH                     =4098,
EXT_DEVICE_CAPS              =4099,
RESTORE_CTM                  =4100,
SAVE_CTM                     =4101,
SET_ARC_DIRECTION            =4102,
SET_BACKGROUND_COLOR         =4103,
SET_POLY_MODE                =4104,
SET_SCREEN_ANGLE             =4105,
SET_SPREAD                   =4106,
TRANSFORM_CTM                =4107,
SET_CLIP_BOX                 =4108,
SET_BOUNDS                   =4109,
SET_MIRROR_MODE              =4110,
OPENCHANNEL                  =4110,
DOWNLOADHEADER               =4111,
CLOSECHANNEL                 =4112,
POSTSCRIPT_PASSTHROUGH       =4115,
ENCAPSULATED_POSTSCRIPT      =4116
}

enum {
/* Flag returned from QUERYDIBSUPPORT */
QDI_SETDIBITS                =1,
QDI_GETDIBITS                =2,
QDI_DIBTOSCREEN              =4,
QDI_STRETCHDIB               =8
}

enum {
/* Spooler Error Codes */
SP_NOTREPORTED               =0x4000,
SP_ERROR                     =(-1),
SP_APPABORT                  =(-2),
SP_USERABORT                 =(-3),
SP_OUTOFDISK                 =(-4),
SP_OUTOFMEMORY               =(-5)
}

enum {
PR_JOBSTATUS                 = 0x0000
}

enum {
/* Object Definitions for EnumObjects() */
OBJ_PEN             =1,
OBJ_BRUSH           =2,
OBJ_DC              =3,
OBJ_METADC          =4,
OBJ_PAL             =5,
OBJ_FONT            =6,
OBJ_BITMAP          =7,
OBJ_REGION          =8,
OBJ_METAFILE        =9,
OBJ_MEMDC           =10,
OBJ_EXTPEN          =11,
OBJ_ENHMETADC       =12,
OBJ_ENHMETAFILE     =13
}

enum {
/* xform stuff */
MWT_IDENTITY        =1,
MWT_LEFTMULTIPLY    =2,
MWT_RIGHTMULTIPLY   =3,

MWT_MIN             =MWT_IDENTITY,
MWT_MAX             =MWT_RIGHTMULTIPLY
}

struct XFORM {
    FLOAT   eM11;
    FLOAT   eM12;
    FLOAT   eM21;
    FLOAT   eM22;
    FLOAT   eDx;
    FLOAT   eDy;
} 
alias XFORM * PXFORM,LPXFORM;

/* Bitmap Header Definition */
struct BITMAP {
    LONG        bmType;
    LONG        bmWidth;
    LONG        bmHeight;
    LONG        bmWidthBytes;
    WORD        bmPlanes;
    WORD        bmBitsPixel;
    LPVOID      bmBits;
} 
alias BITMAP * PBITMAP,NPBITMAP,LPBITMAP;

//#include <pshpack1.h>
struct RGBTRIPLE {
        BYTE    rgbtBlue;
        BYTE    rgbtGreen;
        BYTE    rgbtRed;
}
//#include <poppack.h>

struct RGBQUAD {
        BYTE    rgbBlue;
        BYTE    rgbGreen;
        BYTE    rgbRed;
        BYTE    rgbReserved;
}
alias RGBQUAD * LPRGBQUAD;


/* Image Color Matching color definitions */
alias LONG   LCSCSTYPE;

enum : uint {
LCS_CALIBRATED_RGB              =0x00000000,
LCS_DEVICE_RGB                  =0x00000001,
LCS_DEVICE_CMYK                 =0x00000002
}

typedef LONG    LCSGAMUTMATCH;
enum : uint {
LCS_GM_BUSINESS                 =0x00000001,
LCS_GM_GRAPHICS                 =0x00000002,
LCS_GM_IMAGES                   =0x00000004
}

enum {
/* ICM Defines for results from CheckColorInGamut() */
CM_OUT_OF_GAMUT         =255,
CM_IN_GAMUT             =0
}

/* Macros to retrieve CMYK values from a COLORREF */
/*
#define GetKValue(cmyk)      ((BYTE)(cmyk))
#define GetYValue(cmyk)      ((BYTE)((cmyk)>> 8))
#define GetMValue(cmyk)      ((BYTE)((cmyk)>>16))
#define GetCValue(cmyk)      ((BYTE)((cmyk)>>24))
#define CMYK(c,m,y,k)       ((COLORREF)((((BYTE)(k)|((WORD)((BYTE)(y))<<8))|(((DWORD)(BYTE)(m))<<16))|(((DWORD)(BYTE)(c))<<24)))
*/

alias long FXPT16DOT16;
alias long FXPT2DOT30;
alias FXPT16DOT16 * LPFXPT16DOT16;
alias FXPT2DOT30  * LPFXPT2DOT30;

/* ICM Color Definitions */
// The following two structures are used for defining RGB's in terms of
// CIEXYZ. The values are fixed point 16.16.

struct CIEXYZ
{
	FXPT2DOT30 ciexyzX;
	FXPT2DOT30 ciexyzY;
	FXPT2DOT30 ciexyzZ;
}
alias CIEXYZ * LPCIEXYZ;

struct CIEXYZTRIPLE
{
        CIEXYZ  ciexyzRed;
        CIEXYZ  ciexyzGreen;
        CIEXYZ  ciexyzBlue;
} 
alias CIEXYZTRIPLE * LPCIEXYZTRIPLE;

// The next structures the logical color space. Unlike pens and brushes,
// but like palettes, there is only one way to create a LogColorSpace.
// A pointer to it must be passed, its elements can't be pushed as
// arguments.

struct LOGCOLORSPACEA {
    DWORD lcsSignature;
    DWORD lcsVersion;
    DWORD lcsSize;
    LCSCSTYPE lcsCSType;
    LCSGAMUTMATCH lcsIntent;
    CIEXYZTRIPLE lcsEndpoints;
    DWORD lcsGammaRed;
    DWORD lcsGammaGreen;
    DWORD lcsGammaBlue;
    CHAR   lcsFilename[MAX_PATH];
} 
alias LOGCOLORSPACEA * LPLOGCOLORSPACEA;
struct LOGCOLORSPACEW {
    DWORD lcsSignature;
    DWORD lcsVersion;
    DWORD lcsSize;
    LCSCSTYPE lcsCSType;
    LCSGAMUTMATCH lcsIntent;
    CIEXYZTRIPLE lcsEndpoints;
    DWORD lcsGammaRed;
    DWORD lcsGammaGreen;
    DWORD lcsGammaBlue;
    WCHAR  lcsFilename[MAX_PATH];
} 
alias LOGCOLORSPACEW * LPLOGCOLORSPACEW;


/* structures for defining DIBs */
struct BITMAPCOREHEADER {
        DWORD   bcSize;                 /* used to get to color table */
        WORD    bcWidth;
        WORD    bcHeight;
        WORD    bcPlanes;
        WORD    bcBitCount;
} 
alias BITMAPCOREHEADER * LPBITMAPCOREHEADER,PBITMAPCOREHEADER;

struct BITMAPINFOHEADER {
        DWORD      biSize;
        LONG       biWidth;
        LONG       biHeight;
        WORD       biPlanes;
        WORD       biBitCount;
        DWORD      biCompression;
        DWORD      biSizeImage;
        LONG       biXPelsPerMeter;
        LONG       biYPelsPerMeter;
        DWORD      biClrUsed;
        DWORD      biClrImportant;
} 
alias BITMAPINFOHEADER * LPBITMAPINFOHEADER,PBITMAPINFOHEADER;


struct BITMAPV4HEADER {
        DWORD        bV4Size;
        LONG         bV4Width;
        LONG         bV4Height;
        WORD         bV4Planes;
        WORD         bV4BitCount;
        DWORD        bV4V4Compression;
        DWORD        bV4SizeImage;
        LONG         bV4XPelsPerMeter;
        LONG         bV4YPelsPerMeter;
        DWORD        bV4ClrUsed;
        DWORD        bV4ClrImportant;
        DWORD        bV4RedMask;
        DWORD        bV4GreenMask;
        DWORD        bV4BlueMask;
        DWORD        bV4AlphaMask;
        DWORD        bV4CSType;
        CIEXYZTRIPLE bV4Endpoints;
        DWORD        bV4GammaRed;
        DWORD        bV4GammaGreen;
        DWORD        bV4GammaBlue;
}
alias BITMAPV4HEADER * LPBITMAPV4HEADER,PBITMAPV4HEADER;

enum : uint {
/* constants for the biCompression field */
BI_RGB        =0,
BI_RLE8       =1,
BI_RLE4       =2,
BI_BITFIELDS  =3
}

struct BITMAPINFO {
    BITMAPINFOHEADER    bmiHeader;
    RGBQUAD             bmiColors[1];
} 
alias BITMAPINFO * LPBITMAPINFO,PBITMAPINFO;

struct BITMAPCOREINFO {
    BITMAPCOREHEADER    bmciHeader;
    RGBTRIPLE           bmciColors[1];
} 
alias BITMAPCOREINFO * LPBITMAPCOREINFO,PBITMAPCOREINFO;

//#include <pshpack2.h>
struct BITMAPFILEHEADER {
        WORD    bfType;
        DWORD   bfSize;
        WORD    bfReserved1;
        WORD    bfReserved2;
        DWORD   bfOffBits;
} 
alias BITMAPFILEHEADER * LPBITMAPFILEHEADER,PBITMAPFILEHEADER;
//#include <poppack.h>

//#define MAKEPOINTS(l)       (*((POINTS  *)&(l)))

struct FONTSIGNATURE {
    DWORD fsUsb[4];
    DWORD fsCsb[2];
} 
alias FONTSIGNATURE * PFONTSIGNATURE,LPFONTSIGNATURE;

struct CHARSETINFO {
    UINT ciCharset;
    UINT ciACP;
    FONTSIGNATURE fs;
} 
alias CHARSETINFO * PCHARSETINFO,NPCHARSETINFO,LPCHARSETINFO;

enum {
TCI_SRCCHARSET  =1,
TCI_SRCCODEPAGE =2,
TCI_SRCFONTSIG  =3
}

struct LOCALESIGNATURE {
    DWORD lsUsb[4];
    DWORD lsCsbDefault[2];
    DWORD lsCsbSupported[2];
} 
alias LOCALESIGNATURE * PLOCALESIGNATURE,LPLOCALESIGNATURE;

/* Clipboard Metafile Picture Structure */
struct HANDLETABLE {
    HGDIOBJ     objectHandle[1];
} 
alias HANDLETABLE * PHANDLETABLE,LPHANDLETABLE;

struct METARECORD {
    DWORD       rdSize;
    WORD        rdFunction;
    WORD        rdParm[1];
}
//typedef struct tagMETARECORD UNALIGNED *PMETARECORD;
//typedef struct tagMETARECORD UNALIGNED  *LPMETARECORD;
alias METARECORD * PMETARECORD,LPMETARECORD;

struct METAFILEPICT {
    LONG        mm;
    LONG        xExt;
    LONG        yExt;
    HMETAFILE   hMF;
} 
alias METAFILEPICT * LPMETAFILEPICT;

//#include <pshpack2.h>
struct METAHEADER
{
    WORD        mtType;
    WORD        mtHeaderSize;
    WORD        mtVersion;
    DWORD       mtSize;
    WORD        mtNoObjects;
    DWORD       mtMaxRecord;
    WORD        mtNoParameters;
}
//typedef struct tagMETAHEADER UNALIGNED *PMETAHEADER;
//typedef struct tagMETAHEADER UNALIGNED  *LPMETAHEADER;
alias METAHEADER *PMETAHEADER,LPMETAHEADER;

//#include <poppack.h>

/* Enhanced Metafile structures */
struct ENHMETARECORD {
    DWORD   iType;              // Record type EMR_XXX
    DWORD   nSize;              // Record size in bytes
    DWORD   dParm[1];           // Parameters
} 
alias ENHMETARECORD * PENHMETARECORD,LPENHMETARECORD;

struct ENHMETAHEADER
{
    DWORD   iType;              // Record type EMR_HEADER
    DWORD   nSize;              // Record size in bytes.  This may be greater
                                // than the sizeof(ENHMETAHEADER).
    RECTL   rclBounds;          // Inclusive-inclusive bounds in device units
    RECTL   rclFrame;           // Inclusive-inclusive Picture Frame of metafile in .01 mm units
    DWORD   dSignature;         // Signature.  Must be ENHMETA_SIGNATURE.
    DWORD   nVersion;           // Version number
    DWORD   nBytes;             // Size of the metafile in bytes
    DWORD   nRecords;           // Number of records in the metafile
    WORD    nHandles;           // Number of handles in the handle table
                                // Handle index zero is reserved.
    WORD    sReserved;          // Reserved.  Must be zero.
    DWORD   nDescription;       // Number of chars in the unicode description string
                                // This is 0 if there is no description string
    DWORD   offDescription;     // Offset to the metafile description record.
                                // This is 0 if there is no description string
    DWORD   nPalEntries;        // Number of entries in the metafile palette.
    SIZEL   szlDevice;          // Size of the reference device in pels
    SIZEL   szlMillimeters;     // Size of the reference device in millimeters
    DWORD   cbPixelFormat;      // Size of PIXELFORMATDESCRIPTOR information
                                // This is 0 if no pixel format is set
    DWORD   offPixelFormat;     // Offset to PIXELFORMATDESCRIPTOR
                                // This is 0 if no pixel format is set
    DWORD   bOpenGL;            // TRUE if OpenGL commands are present in
                                // the metafile, otherwise FALSE
} 
alias ENHMETAHEADER * PENHMETAHEADER,LPENHMETAHEADER;

enum {
/* tmPitchAndFamily flags */
TMPF_FIXED_PITCH    =0x01,
TMPF_VECTOR         =0x02,
TMPF_DEVICE         =0x08,
TMPF_TRUETYPE       =0x04
}

struct TEXTMETRICA
{
    LONG        tmHeight;
    LONG        tmAscent;
    LONG        tmDescent;
    LONG        tmInternalLeading;
    LONG        tmExternalLeading;
    LONG        tmAveCharWidth;
    LONG        tmMaxCharWidth;
    LONG        tmWeight;
    LONG        tmOverhang;
    LONG        tmDigitizedAspectX;
    LONG        tmDigitizedAspectY;
    BYTE        tmFirstChar;
    BYTE        tmLastChar;
    BYTE        tmDefaultChar;
    BYTE        tmBreakChar;
    BYTE        tmItalic;
    BYTE        tmUnderlined;
    BYTE        tmStruckOut;
    BYTE        tmPitchAndFamily;
    BYTE        tmCharSet;
} 
alias TEXTMETRICA * PTEXTMETRICA,NPTEXTMETRICA,LPTEXTMETRICA;

struct TEXTMETRICW {
    LONG        tmHeight;
    LONG        tmAscent;
    LONG        tmDescent;
    LONG        tmInternalLeading;
    LONG        tmExternalLeading;
    LONG        tmAveCharWidth;
    LONG        tmMaxCharWidth;
    LONG        tmWeight;
    LONG        tmOverhang;
    LONG        tmDigitizedAspectX;
    LONG        tmDigitizedAspectY;
    WCHAR       tmFirstChar;
    WCHAR       tmLastChar;
    WCHAR       tmDefaultChar;
    WCHAR       tmBreakChar;
    BYTE        tmItalic;
    BYTE        tmUnderlined;
    BYTE        tmStruckOut;
    BYTE        tmPitchAndFamily;
    BYTE        tmCharSet;
} 
alias TEXTMETRICW * PTEXTMETRICW,NPTEXTMETRICW,LPTEXTMETRICW;

enum : uint {
/* ntmFlags field flags */
NTM_REGULAR     =0x00000040,
NTM_BOLD        =0x00000020,
NTM_ITALIC      =0x00000001
}

//#include <pshpack4.h>
struct NEWTEXTMETRICA {
    LONG        tmHeight;
    LONG        tmAscent;
    LONG        tmDescent;
    LONG        tmInternalLeading;
    LONG        tmExternalLeading;
    LONG        tmAveCharWidth;
    LONG        tmMaxCharWidth;
    LONG        tmWeight;
    LONG        tmOverhang;
    LONG        tmDigitizedAspectX;
    LONG        tmDigitizedAspectY;
    BYTE        tmFirstChar;
    BYTE        tmLastChar;
    BYTE        tmDefaultChar;
    BYTE        tmBreakChar;
    BYTE        tmItalic;
    BYTE        tmUnderlined;
    BYTE        tmStruckOut;
    BYTE        tmPitchAndFamily;
    BYTE        tmCharSet;
    DWORD   ntmFlags;
    UINT    ntmSizeEM;
    UINT    ntmCellHeight;
    UINT    ntmAvgWidth;
} 
alias NEWTEXTMETRICA * PNEWTEXTMETRICA,NPNEWTEXTMETRICA,LPNEWTEXTMETRICA;

struct NEWTEXTMETRICW {
    LONG        tmHeight;
    LONG        tmAscent;
    LONG        tmDescent;
    LONG        tmInternalLeading;
    LONG        tmExternalLeading;
    LONG        tmAveCharWidth;
    LONG        tmMaxCharWidth;
    LONG        tmWeight;
    LONG        tmOverhang;
    LONG        tmDigitizedAspectX;
    LONG        tmDigitizedAspectY;
    WCHAR       tmFirstChar;
    WCHAR       tmLastChar;
    WCHAR       tmDefaultChar;
    WCHAR       tmBreakChar;
    BYTE        tmItalic;
    BYTE        tmUnderlined;
    BYTE        tmStruckOut;
    BYTE        tmPitchAndFamily;
    BYTE        tmCharSet;
    DWORD   ntmFlags;
    UINT    ntmSizeEM;
    UINT    ntmCellHeight;
    UINT    ntmAvgWidth;
} 
alias NEWTEXTMETRICW * PNEWTEXTMETRICW,NPNEWTEXTMETRICW,LPNEWTEXTMETRICW;


//#include <poppack.h>

struct NEWTEXTMETRICEXA {
    NEWTEXTMETRICA  ntmTm;
    FONTSIGNATURE   ntmFontSig;
}
struct NEWTEXTMETRICEXW {
    NEWTEXTMETRICW  ntmTm;
    FONTSIGNATURE   ntmFontSig;
}


/* GDI Logical Objects: */
/* Pel Array */
struct PELARRAY {
    LONG        paXCount;
    LONG        paYCount;
    LONG        paXExt;
    LONG        paYExt;
    BYTE        paRGBs;
} 
alias PELARRAY * PPELARRAY,NPPELARRAY,LPPELARRAY;

/* Logical Brush (or Pattern) */
struct LOGBRUSH {
    UINT        lbStyle;
    COLORREF    lbColor;
    LONG        lbHatch;
} 
alias LOGBRUSH * PLOGBRUSH,NPLOGBRUSH,LPLOGBRUSH;

alias LOGBRUSH   PATTERN;
alias  PATTERN * PPATTERN,NPPATTERN,LPPATTERN;

/* Logical Pen */
struct LOGPEN {
    UINT        lopnStyle;
    POINT       lopnWidth;
    COLORREF    lopnColor;
} 
alias LOGPEN * PLOGPEN,NPLOGPEN,LPLOGPEN;

struct EXTLOGPEN {
    DWORD       elpPenStyle;
    DWORD       elpWidth;
    UINT        elpBrushStyle;
    COLORREF    elpColor;
    LONG        elpHatch;
    DWORD       elpNumEntries;
    DWORD       elpStyleEntry[1];
} 
alias EXTLOGPEN * PEXTLOGPEN,NPEXTLOGPEN,LPEXTLOGPEN;

version(STANDALONE) {
struct PALETTEENTRY {
    BYTE        peRed;
    BYTE        peGreen;
    BYTE        peBlue;
    BYTE        peFlags;
} 
alias PALETTEENTRY * PPALETTEENTRY,LPPALETTEENTRY;
}

/* Logical Palette */
struct LOGPALETTE {
    WORD        palVersion;
    WORD        palNumEntries;
    PALETTEENTRY        palPalEntry[1];
} 
alias LOGPALETTE * PLOGPALETTE,NPLOGPALETTE,LPLOGPALETTE;

enum {
/* Logical Font */
LF_FACESIZE         = 32,
LF_FULLFACESIZE     =64
}

struct LOGFONTA
{
    LONG      lfHeight;
    LONG      lfWidth;
    LONG      lfEscapement;
    LONG      lfOrientation;
    LONG      lfWeight;
    BYTE      lfItalic;
    BYTE      lfUnderline;
    BYTE      lfStrikeOut;
    BYTE      lfCharSet;
    BYTE      lfOutPrecision;
    BYTE      lfClipPrecision;
    BYTE      lfQuality;
    BYTE      lfPitchAndFamily;
    CHAR      lfFaceName[LF_FACESIZE];
} 
alias LOGFONTA * PLOGFONTA,NPLOGFONTA,LPLOGFONTA;

struct LOGFONTW
{
    LONG      lfHeight;
    LONG      lfWidth;
    LONG      lfEscapement;
    LONG      lfOrientation;
    LONG      lfWeight;
    BYTE      lfItalic;
    BYTE      lfUnderline;
    BYTE      lfStrikeOut;
    BYTE      lfCharSet;
    BYTE      lfOutPrecision;
    BYTE      lfClipPrecision;
    BYTE      lfQuality;
    BYTE      lfPitchAndFamily;
    WCHAR     lfFaceName[LF_FACESIZE];
} 
alias LOGFONTW * PLOGFONTW,NPLOGFONTW,LPLOGFONTW;



/* Structure passed to FONTENUMPROC */
struct ENUMLOGFONTA {
    LOGFONTA elfLogFont;
    BYTE     elfFullName[LF_FULLFACESIZE];
    BYTE     elfStyle[LF_FACESIZE];
} 
alias ENUMLOGFONTA * LPENUMLOGFONTA;
/* Structure passed to FONTENUMPROC */
struct ENUMLOGFONTW {
    LOGFONTW elfLogFont;
    WCHAR    elfFullName[LF_FULLFACESIZE];
    WCHAR    elfStyle[LF_FACESIZE];
} 
alias ENUMLOGFONTW * LPENUMLOGFONTW;

struct ENUMLOGFONTEXA {
    LOGFONTA    elfLogFont;
    BYTE        elfFullName[LF_FULLFACESIZE];
    BYTE        elfStyle[LF_FACESIZE];
    BYTE        elfScript[LF_FACESIZE];
} 
alias ENUMLOGFONTEXA * LPENUMLOGFONTEXA;
struct ENUMLOGFONTEXW {
    LOGFONTW    elfLogFont;
    WCHAR       elfFullName[LF_FULLFACESIZE];
    WCHAR       elfStyle[LF_FACESIZE];
    WCHAR       elfScript[LF_FACESIZE];
} 
alias ENUMLOGFONTEXW * LPENUMLOGFONTEXW;

enum {
OUT_DEFAULT_PRECIS          =0,
OUT_STRING_PRECIS           =1,
OUT_CHARACTER_PRECIS        =2,
OUT_STROKE_PRECIS           =3,
OUT_TT_PRECIS               =4,
OUT_DEVICE_PRECIS           =5,
OUT_RASTER_PRECIS           =6,
OUT_TT_ONLY_PRECIS          =7,
OUT_OUTLINE_PRECIS          =8,
OUT_SCREEN_OUTLINE_PRECIS   =9
}
enum {
CLIP_DEFAULT_PRECIS     =0,
CLIP_CHARACTER_PRECIS   =1,
CLIP_STROKE_PRECIS      =2,
CLIP_MASK               =0xf,
CLIP_LH_ANGLES          =(1<<4),
CLIP_TT_ALWAYS          =(2<<4),
CLIP_EMBEDDED           =(8<<4)
}

enum {
DEFAULT_QUALITY         =0,
DRAFT_QUALITY           =1,
PROOF_QUALITY           =2,
NONANTIALIASED_QUALITY  =3,
ANTIALIASED_QUALITY     =4
}

enum {
DEFAULT_PITCH           =0,
FIXED_PITCH             =1,
VARIABLE_PITCH          =2,
MONO_FONT               =8

}

enum {
ANSI_CHARSET            =0,
DEFAULT_CHARSET         =1,
SYMBOL_CHARSET          =2,
SHIFTJIS_CHARSET        =128,
HANGEUL_CHARSET         =129,
GB2312_CHARSET          =134,
CHINESEBIG5_CHARSET     =136,
OEM_CHARSET             =255,
JOHAB_CHARSET           =130,
HEBREW_CHARSET          =177,
ARABIC_CHARSET          =178,
GREEK_CHARSET           =161,
TURKISH_CHARSET         =162,
VIETNAMESE_CHARSET      =163,
THAI_CHARSET            =222,
EASTEUROPE_CHARSET      =238,
RUSSIAN_CHARSET         =204,

MAC_CHARSET             =77,
BALTIC_CHARSET          =186
}

enum : uint {
FS_LATIN1               =0x00000001,
FS_LATIN2               =0x00000002,
FS_CYRILLIC             =0x00000004,
FS_GREEK                =0x00000008,
FS_TURKISH              =0x00000010,
FS_HEBREW               =0x00000020,
FS_ARABIC               =0x00000040,
FS_BALTIC               =0x00000080,
FS_VIETNAMESE           =0x00000100,
FS_THAI                 =0x00010000,
FS_JISJAPAN             =0x00020000,
FS_CHINESESIMP          =0x00040000,
FS_WANSUNG              =0x00080000,
FS_CHINESETRAD          =0x00100000,
FS_JOHAB                =0x00200000,
FS_SYMBOL               =0x80000000
}

enum {
/* Font Families */
FF_DONTCARE         =(0<<4),  /* Don't care or don't know. */
FF_ROMAN            =(1<<4),  /* Variable stroke width, serifed. */
                                    /* Times Roman, Century Schoolbook, etc. */
FF_SWISS            =(2<<4),  /* Variable stroke width, sans-serifed. */
                                    /* Helvetica, Swiss, etc. */
FF_MODERN           =(3<<4),  /* Constant stroke width, serifed or sans-serifed. */
                                    /* Pica, Elite, Courier, etc. */
FF_SCRIPT           =(4<<4),  /* Cursive, etc. */
FF_DECORATIVE       =(5<<4)  /* Old English, etc. */
}

enum {
/* Font Weights */
FW_DONTCARE         =0,
FW_THIN             =100,
FW_EXTRALIGHT       =200,
FW_LIGHT            =300,
FW_NORMAL           =400,
FW_MEDIUM           =500,
FW_SEMIBOLD         =600,
FW_BOLD             =700,
FW_EXTRABOLD        =800,
FW_HEAVY            =900,

FW_ULTRALIGHT       =FW_EXTRALIGHT,
FW_REGULAR          =FW_NORMAL,
FW_DEMIBOLD         =FW_SEMIBOLD,
FW_ULTRABOLD        =FW_EXTRABOLD,
FW_BLACK            =FW_HEAVY
}

enum {
PANOSE_COUNT               =10,
PAN_FAMILYTYPE_INDEX        =0,
PAN_SERIFSTYLE_INDEX        =1,
PAN_WEIGHT_INDEX            =2,
PAN_PROPORTION_INDEX        =3,
PAN_CONTRAST_INDEX          =4,
PAN_STROKEVARIATION_INDEX   =5,
PAN_ARMSTYLE_INDEX          =6,
PAN_LETTERFORM_INDEX        =7,
PAN_MIDLINE_INDEX           =8,
PAN_XHEIGHT_INDEX           =9,
PAN_CULTURE_LATIN           =0
}

struct PANOSE {
    BYTE    bFamilyType;
    BYTE    bSerifStyle;
    BYTE    bWeight;
    BYTE    bProportion;
    BYTE    bContrast;
    BYTE    bStrokeVariation;
    BYTE    bArmStyle;
    BYTE    bLetterform;
    BYTE    bMidline;
    BYTE    bXHeight;
} 
alias PANOSE * LPPANOSE;

enum {
PAN_ANY                         =0, /* Any                            */
PAN_NO_FIT                      =1 /* No Fit                         */
}

enum {
PAN_FAMILY_TEXT_DISPLAY         =2, /* Text and Display               */
PAN_FAMILY_SCRIPT               =3, /* Script                         */
PAN_FAMILY_DECORATIVE           =4, /* Decorative                     */
PAN_FAMILY_PICTORIAL            =5 /* Pictorial                      */
}

enum {
PAN_SERIF_COVE                  =2, /* Cove                           */
PAN_SERIF_OBTUSE_COVE           =3, /* Obtuse Cove                    */
PAN_SERIF_SQUARE_COVE           =4, /* Square Cove                    */
PAN_SERIF_OBTUSE_SQUARE_COVE    =5, /* Obtuse Square Cove             */
PAN_SERIF_SQUARE                =6, /* Square                         */
PAN_SERIF_THIN                  =7, /* Thin                           */
PAN_SERIF_BONE                  =8, /* Bone                           */
PAN_SERIF_EXAGGERATED           =9, /* Exaggerated                    */
PAN_SERIF_TRIANGLE             =10, /* Triangle                       */
PAN_SERIF_NORMAL_SANS          =11, /* Normal Sans                    */
PAN_SERIF_OBTUSE_SANS          =12, /* Obtuse Sans                    */
PAN_SERIF_PERP_SANS            =13, /* Prep Sans                      */
PAN_SERIF_FLARED               =14, /* Flared                         */
PAN_SERIF_ROUNDED              =15 /* Rounded                        */
}
enum {
PAN_WEIGHT_VERY_LIGHT           =2, /* Very Light                     */
PAN_WEIGHT_LIGHT                =3, /* Light                          */
PAN_WEIGHT_THIN                 =4, /* Thin                           */
PAN_WEIGHT_BOOK                 =5, /* Book                           */
PAN_WEIGHT_MEDIUM               =6, /* Medium                         */
PAN_WEIGHT_DEMI                 =7, /* Demi                           */
PAN_WEIGHT_BOLD                 =8, /* Bold                           */
PAN_WEIGHT_HEAVY                =9, /* Heavy                          */
PAN_WEIGHT_BLACK               =10, /* Black                          */
PAN_WEIGHT_NORD                =11, /* Nord                           */
}

enum {
PAN_PROP_OLD_STYLE              =2, /* Old Style                      */
PAN_PROP_MODERN                 =3, /* Modern                         */
PAN_PROP_EVEN_WIDTH             =4, /* Even Width                     */
PAN_PROP_EXPANDED               =5, /* Expanded                       */
PAN_PROP_CONDENSED              =6, /* Condensed                      */
PAN_PROP_VERY_EXPANDED          =7, /* Very Expanded                  */
PAN_PROP_VERY_CONDENSED         =8, /* Very Condensed                 */
PAN_PROP_MONOSPACED             =9  /* Monospaced                     */
}

enum {
PAN_CONTRAST_NONE               =2, /* None                           */
PAN_CONTRAST_VERY_LOW           =3, /* Very Low                       */
PAN_CONTRAST_LOW                =4, /* Low                            */
PAN_CONTRAST_MEDIUM_LOW         =5, /* Medium Low                     */
PAN_CONTRAST_MEDIUM             =6, /* Medium                         */
PAN_CONTRAST_MEDIUM_HIGH        =7, /* Mediim High                    */
PAN_CONTRAST_HIGH               =8, /* High                           */
PAN_CONTRAST_VERY_HIGH          =9  /* Very High                      */
}

enum {
PAN_STROKE_GRADUAL_DIAG         =2, /* Gradual/Diagonal               */
PAN_STROKE_GRADUAL_TRAN         =3, /* Gradual/Transitional           */
PAN_STROKE_GRADUAL_VERT         =4, /* Gradual/Vertical               */
PAN_STROKE_GRADUAL_HORZ         =5, /* Gradual/Horizontal             */
PAN_STROKE_RAPID_VERT           =6, /* Rapid/Vertical                 */
PAN_STROKE_RAPID_HORZ           =7, /* Rapid/Horizontal               */
PAN_STROKE_INSTANT_VERT         =8  /* Instant/Vertical               */
}

enum {
PAN_STRAIGHT_ARMS_HORZ          =2, /* Straight Arms/Horizontal       */
PAN_STRAIGHT_ARMS_WEDGE         =3, /* Straight Arms/Wedge            */
PAN_STRAIGHT_ARMS_VERT          =4, /* Straight Arms/Vertical         */
PAN_STRAIGHT_ARMS_SINGLE_SERIF  =5, /* Straight Arms/Single-Serif     */
PAN_STRAIGHT_ARMS_DOUBLE_SERIF  =6, /* Straight Arms/Double-Serif     */
PAN_BENT_ARMS_HORZ              =7, /* Non-Straight Arms/Horizontal   */
PAN_BENT_ARMS_WEDGE             =8, /* Non-Straight Arms/Wedge        */
PAN_BENT_ARMS_VERT              =9, /* Non-Straight Arms/Vertical     */
PAN_BENT_ARMS_SINGLE_SERIF     =10, /* Non-Straight Arms/Single-Serif */
PAN_BENT_ARMS_DOUBLE_SERIF     =11  /* Non-Straight Arms/Double-Serif */
}

enum {
PAN_LETT_NORMAL_CONTACT         =2, /* Normal/Contact                 */
PAN_LETT_NORMAL_WEIGHTED        =3, /* Normal/Weighted                */
PAN_LETT_NORMAL_BOXED           =4, /* Normal/Boxed                   */
PAN_LETT_NORMAL_FLATTENED       =5, /* Normal/Flattened               */
PAN_LETT_NORMAL_ROUNDED         =6, /* Normal/Rounded                 */
PAN_LETT_NORMAL_OFF_CENTER      =7, /* Normal/Off Center              */
PAN_LETT_NORMAL_SQUARE          =8, /* Normal/Square                  */
PAN_LETT_OBLIQUE_CONTACT        =9, /* Oblique/Contact                */
PAN_LETT_OBLIQUE_WEIGHTED      =10, /* Oblique/Weighted               */
PAN_LETT_OBLIQUE_BOXED         =11, /* Oblique/Boxed                  */
PAN_LETT_OBLIQUE_FLATTENED     =12, /* Oblique/Flattened              */
PAN_LETT_OBLIQUE_ROUNDED       =13, /* Oblique/Rounded                */
PAN_LETT_OBLIQUE_OFF_CENTER    =14, /* Oblique/Off Center             */
PAN_LETT_OBLIQUE_SQUARE        =15  /* Oblique/Square                 */
}

enum {
PAN_MIDLINE_STANDARD_TRIMMED    =2, /* Standard/Trimmed               */
PAN_MIDLINE_STANDARD_POINTED    =3, /* Standard/Pointed               */
PAN_MIDLINE_STANDARD_SERIFED    =4, /* Standard/Serifed               */
PAN_MIDLINE_HIGH_TRIMMED        =5, /* High/Trimmed                   */
PAN_MIDLINE_HIGH_POINTED        =6, /* High/Pointed                   */
PAN_MIDLINE_HIGH_SERIFED        =7, /* High/Serifed                   */
PAN_MIDLINE_CONSTANT_TRIMMED    =8, /* Constant/Trimmed               */
PAN_MIDLINE_CONSTANT_POINTED    =9, /* Constant/Pointed               */
PAN_MIDLINE_CONSTANT_SERIFED   =10, /* Constant/Serifed               */
PAN_MIDLINE_LOW_TRIMMED        =11, /* Low/Trimmed                    */
PAN_MIDLINE_LOW_POINTED        =12, /* Low/Pointed                    */
PAN_MIDLINE_LOW_SERIFED        =13  /* Low/Serifed                    */
}

enum {
PAN_XHEIGHT_CONSTANT_SMALL      =2, /* Constant/Small                 */
PAN_XHEIGHT_CONSTANT_STD        =3, /* Constant/Standard              */
PAN_XHEIGHT_CONSTANT_LARGE      =4, /* Constant/Large                 */
PAN_XHEIGHT_DUCKING_SMALL       =5, /* Ducking/Small                  */
PAN_XHEIGHT_DUCKING_STD         =6, /* Ducking/Standard               */
PAN_XHEIGHT_DUCKING_LARGE       =7  /* Ducking/Large                  */
}

enum { ELF_VENDOR_SIZE     = 4 }

/* The extended logical font       */
/* An extension of the ENUMLOGFONT */
struct EXTLOGFONTA {
    LOGFONTA    elfLogFont;
    BYTE        elfFullName[LF_FULLFACESIZE];
    BYTE        elfStyle[LF_FACESIZE];
    DWORD       elfVersion;     /* 0 for the first release of NT */
    DWORD       elfStyleSize;
    DWORD       elfMatch;
    DWORD       elfReserved;
    BYTE        elfVendorId[ELF_VENDOR_SIZE];
    DWORD       elfCulture;     /* 0 for Latin                   */
    PANOSE      elfPanose;
} 
alias EXTLOGFONTA * PEXTLOGFONTA,NPEXTLOGFONTA,LPEXTLOGFONTA;
struct EXTLOGFONTW {
    LOGFONTW    elfLogFont;
    WCHAR       elfFullName[LF_FULLFACESIZE];
    WCHAR       elfStyle[LF_FACESIZE];
    DWORD       elfVersion;     /* 0 for the first release of NT */
    DWORD       elfStyleSize;
    DWORD       elfMatch;
    DWORD       elfReserved;
    BYTE        elfVendorId[ELF_VENDOR_SIZE];
    DWORD       elfCulture;     /* 0 for Latin                   */
    PANOSE      elfPanose;
} 
alias EXTLOGFONTW * PEXTLOGFONTW,NPEXTLOGFONTW,LPEXTLOGFONTW;


enum {
ELF_VERSION         = 0,
ELF_CULTURE_LATIN   = 0
}

enum {
/* EnumFonts Masks */
RASTER_FONTTYPE     =0x0001,
DEVICE_FONTTYPE     =0x002,
TRUETYPE_FONTTYPE   =0x004
}

//#define RGB(r,g,b)          ((COLORREF)(((BYTE)(r)|((WORD)((BYTE)(g))<<8))|(((DWORD)(BYTE)(b))<<16)))
//#define PALETTERGB(r,g,b)   (0x02000000 | RGB(r,g,b))
//#define PALETTEINDEX(i)     ((COLORREF)(0x01000000 | (DWORD)(WORD)(i)))

enum {
/* palette entry flags */
PC_RESERVED     =0x01,    /* palette index used for animation */
PC_EXPLICIT     =0x02,    /* palette index is explicit to device */
PC_NOCOLLAPSE   =0x04    /* do not match color to system palette */
}

//#define GetRValue(rgb)      ((BYTE)(rgb))
//#define GetGValue(rgb)      ((BYTE)(((WORD)(rgb)) >> 8))
//#define GetBValue(rgb)      ((BYTE)((rgb)>>16))

enum {
/* Background Modes */
TRANSPARENT         =1,
OPAQUE              =2,
BKMODE_LAST         =2
}

enum {
/* Graphics Modes */
GM_COMPATIBLE       =1,
GM_ADVANCED         =2,
GM_LAST             =2
}

enum {
/* PolyDraw and GetPath point types */
PT_CLOSEFIGURE      =0x01,
PT_LINETO           =0x02,
PT_BEZIERTO         =0x04,
PT_MOVETO           =0x06
}

enum {
/* Mapping Modes */
MM_TEXT             =1,
MM_LOMETRIC         =2,
MM_HIMETRIC         =3,
MM_LOENGLISH        =4,
MM_HIENGLISH        =5,
MM_TWIPS            =6,
MM_ISOTROPIC        =7,
MM_ANISOTROPIC      =8,

/* Min and Max Mapping Mode values */
MM_MIN              =MM_TEXT,
MM_MAX              =MM_ANISOTROPIC,
MM_MAX_FIXEDSCALE   =MM_TWIPS
}

enum {
/* Coordinate Modes */
ABSOLUTE            =1,
RELATIVE            =2
}

enum {
/* Stock Logical Objects */
WHITE_BRUSH         =0,
LTGRAY_BRUSH        =1,
GRAY_BRUSH          =2,
DKGRAY_BRUSH        =3,
BLACK_BRUSH         =4,
NULL_BRUSH          =5,
HOLLOW_BRUSH        =NULL_BRUSH,
WHITE_PEN           =6,
BLACK_PEN           =7,
NULL_PEN            =8,
OEM_FIXED_FONT      =10,
ANSI_FIXED_FONT     =11,
ANSI_VAR_FONT       =12,
SYSTEM_FONT         =13,
DEVICE_DEFAULT_FONT =14,
DEFAULT_PALETTE     =15,
SYSTEM_FIXED_FONT   =16,
DEFAULT_GUI_FONT    =17,
STOCK_LAST          =17
}

enum : uint {
	CLR_INVALID     = 0xFFFFFFFF
}

enum {
/* Brush Styles */
BS_SOLID            =0,
BS_NULL             =1,
BS_HOLLOW           =BS_NULL,
BS_HATCHED          =2,
BS_PATTERN          =3,
BS_INDEXED          =4,
BS_DIBPATTERN       =5,
BS_DIBPATTERNPT     =6,
BS_PATTERN8X8       =7,
BS_DIBPATTERN8X8    =8,
BS_MONOPATTERN      =9
}

enum {
/* Hatch Styles */
HS_HORIZONTAL       =0,      /* ----- */
HS_VERTICAL         =1,      /* ||||| */
HS_FDIAGONAL        =2,      /* \\\\\ */
HS_BDIAGONAL        =3,      /* ///// */
HS_CROSS            =4,      /* +++++ */
HS_DIAGCROSS        =5       /* xxxxx */
}

enum {
/* Pen Styles */
PS_SOLID            =0,
PS_DASH             =1,       /* -------  */
PS_DOT              =2,       /* .......  */
PS_DASHDOT          =3,       /* _._._._  */
PS_DASHDOTDOT       =4,       /* _.._.._  */
PS_NULL             =5,
PS_INSIDEFRAME      =6,
PS_USERSTYLE        =7,
PS_ALTERNATE        =8,
PS_STYLE_MASK       =0x0000000F,
}

enum {
PS_ENDCAP_ROUND     =0x00000000,
PS_ENDCAP_SQUARE    =0x00000100,
PS_ENDCAP_FLAT      =0x00000200,
PS_ENDCAP_MASK      =0x00000F00
}

enum {
PS_JOIN_ROUND       =0x00000000,
PS_JOIN_BEVEL       =0x00001000,
PS_JOIN_MITER       =0x00002000,
PS_JOIN_MASK        =0x0000F000
}

enum {
PS_COSMETIC         =0x00000000,
PS_GEOMETRIC        =0x00010000,
PS_TYPE_MASK        =0x000F0000
}

enum {
AD_COUNTERCLOCKWISE =1,
AD_CLOCKWISE        =2
}

enum {
/* Device Parameters for GetDeviceCaps() */
DRIVERVERSION =0,     /* Device driver version                    */
TECHNOLOGY    =2,     /* Device classification                    */
HORZSIZE      =4,    /* Horizontal size in millimeters           */
VERTSIZE      =6,     /* Vertical size in millimeters             */
HORZRES       =8,     /* Horizontal width in pixels               */
VERTRES       =10,    /* Vertical height in pixels                */
BITSPIXEL     =12,    /* Number of bits per pixel                 */
PLANES        =14,    /* Number of planes                         */
NUMBRUSHES    =16,    /* Number of brushes the device has         */
NUMPENS       =18,    /* Number of pens the device has            */
NUMMARKERS    =20,    /* Number of markers the device has         */
NUMFONTS      =22,    /* Number of fonts the device has           */
NUMCOLORS     =24,    /* Number of colors the device supports     */
PDEVICESIZE   =26,    /* Size required for device descriptor      */
CURVECAPS     =28,    /* Curve capabilities                       */
LINECAPS      =30,    /* Line capabilities                        */
POLYGONALCAPS =32,    /* Polygonal capabilities                   */
TEXTCAPS      =34,    /* Text capabilities                        */
CLIPCAPS      =36,    /* Clipping capabilities                    */
RASTERCAPS    =38,    /* Bitblt capabilities                      */
ASPECTX       =40,   /* Length of the X leg                      */
ASPECTY       =42,    /* Length of the Y leg                      */
ASPECTXY      =44,    /* Length of the hypotenuse                 */

LOGPIXELSX    =88,    /* Logical pixels/inch in X                 */
LOGPIXELSY    =90,    /* Logical pixels/inch in Y                 */

SIZEPALETTE  =104,    /* Number of entries in physical palette    */
NUMRESERVED  =106,    /* Number of reserved entries in palette    */
COLORRES     =108,    /* Actual color resolution                  */


// Printing related DeviceCaps. These replace the appropriate Escapes

PHYSICALWIDTH   =110, /* Physical Width in device units           */
PHYSICALHEIGHT  =111, /* Physical Height in device units          */
PHYSICALOFFSETX =112, /* Physical Printable Area x margin         */
PHYSICALOFFSETY =113, /* Physical Printable Area y margin         */
SCALINGFACTORX  =114, /* Scaling factor x                         */
SCALINGFACTORY  =115, /* Scaling factor y                         */

// Display driver specific

VREFRESH        =116,  /* Current vertical refresh rate of the    */
                             /* display device (for displays only) in Hz*/
DESKTOPVERTRES  =117,  /* Horizontal width of entire desktop in   */
                             /* pixels                                  */
DESKTOPHORZRES  =118,  /* Vertical height of entire desktop in    */
                             /* pixels                                  */
BLTALIGNMENT    =119  /* Preferred blt alignment                 */
}

/* Device Capability Masks: */

enum {
/* Device Technologies */
DT_PLOTTER          =0,   /* Vector plotter                   */
DT_RASDISPLAY       =1,   /* Raster display                   */
DT_RASPRINTER       =2,   /* Raster printer                   */
DT_RASCAMERA        =3,   /* Raster camera                    */
DT_CHARSTREAM       =4,   /* Character-stream, PLP            */
DT_METAFILE         =5,   /* Metafile, VDM                    */
DT_DISPFILE         =6   /* Display-file                     */
}

enum {
/* Curve Capabilities */
CC_NONE             =0,   /* Curves not supported             */
CC_CIRCLES          =1,   /* Can do circles                   */
CC_PIE              =2,   /* Can do pie wedges                */
CC_CHORD            =4,   /* Can do chord arcs                */
CC_ELLIPSES         =8,   /* Can do ellipese                  */
CC_WIDE             =16,  /* Can do wide lines                */
CC_STYLED           =32,  /* Can do styled lines              */
CC_WIDESTYLED       =64,  /* Can do wide styled lines         */
CC_INTERIORS        =128, /* Can do interiors                 */
CC_ROUNDRECT        =256  /*                                  */
}

enum {
/* Line Capabilities */
LC_NONE             =0,   /* Lines not supported              */
LC_POLYLINE         =2,   /* Can do polylines                 */
LC_MARKER           =4,   /* Can do markers                   */
LC_POLYMARKER       =8,   /* Can do polymarkers               */
LC_WIDE             =16,  /* Can do wide lines                */
LC_STYLED           =32,  /* Can do styled lines              */
LC_WIDESTYLED       =64,  /* Can do wide styled lines         */
LC_INTERIORS        =128  /* Can do interiors                 */
}

enum {
/* Polygonal Capabilities */
PC_NONE             =0,   /* Polygonals not supported         */
PC_POLYGON          =1,   /* Can do polygons                  */
PC_RECTANGLE        =2,   /* Can do rectangles                */
PC_WINDPOLYGON      =4,   /* Can do winding polygons          */
PC_TRAPEZOID        =4,   /* Can do trapezoids                */
PC_SCANLINE         =8,   /* Can do scanlines                 */
PC_WIDE             =16,  /* Can do wide borders              */
PC_STYLED           =32,  /* Can do styled borders            */
PC_WIDESTYLED       =64,  /* Can do wide styled borders       */
PC_INTERIORS        =128, /* Can do interiors                 */
PC_POLYPOLYGON      =256, /* Can do polypolygons              */
PC_PATHS            =512, /* Can do paths                     */
}

enum {
/* Clipping Capabilities */
CP_NONE             =0,   /* No clipping of output            */
CP_RECTANGLE        =1,   /* Output clipped to rects          */
CP_REGION           =2   /* obsolete                         */
}

enum {
/* Text Capabilities */
TC_OP_CHARACTER     =0x00000001,  /* Can do OutputPrecision   CHARACTER      */
TC_OP_STROKE        =0x00000002,  /* Can do OutputPrecision   STROKE         */
TC_CP_STROKE        =0x00000004,  /* Can do ClipPrecision     STROKE         */
TC_CR_90            =0x00000008,  /* Can do CharRotAbility    90             */
TC_CR_ANY           =0x00000010,  /* Can do CharRotAbility    ANY            */
TC_SF_X_YINDEP      =0x00000020,  /* Can do ScaleFreedom      X_YINDEPENDENT */
TC_SA_DOUBLE        =0x00000040,  /* Can do ScaleAbility      DOUBLE         */
TC_SA_INTEGER       =0x00000080,  /* Can do ScaleAbility      INTEGER        */
TC_SA_CONTIN        =0x00000100,  /* Can do ScaleAbility      CONTINUOUS     */
TC_EA_DOUBLE        =0x00000200,  /* Can do EmboldenAbility   DOUBLE         */
TC_IA_ABLE          =0x00000400,  /* Can do ItalisizeAbility  ABLE           */
TC_UA_ABLE          =0x00000800,  /* Can do UnderlineAbility  ABLE           */
TC_SO_ABLE          =0x00001000,  /* Can do StrikeOutAbility  ABLE           */
TC_RA_ABLE          =0x00002000,  /* Can do RasterFontAble    ABLE           */
TC_VA_ABLE          =0x00004000,  /* Can do VectorFontAble    ABLE           */
TC_RESERVED         =0x00008000,
TC_SCROLLBLT        =0x00010000  /* Don't do text scroll with blt           */
}

enum {
/* Raster Capabilities */
RC_NONE = 0,
RC_BITBLT           =1,       /* Can do standard BLT.             */
RC_BANDING          =2,       /* Device requires banding support  */
RC_SCALING          =4,      /* Device requires scaling support  */
RC_BITMAP64         =8,       /* Device can support >64K bitmap   */
RC_GDI20_OUTPUT     =0x0010,      /* has 2.0 output calls         */
RC_GDI20_STATE      =0x0020,
RC_SAVEBITMAP       =0x0040,
RC_DI_BITMAP        =0x0080,      /* supports DIB to memory       */
RC_PALETTE          =0x0100,      /* supports a palette           */
RC_DIBTODEV         =0x0200,      /* supports DIBitsToDevice      */
RC_BIGFONT          =0x0400,      /* supports >64K fonts          */
RC_STRETCHBLT       =0x0800,      /* supports StretchBlt          */
RC_FLOODFILL        =0x1000,      /* supports FloodFill           */
RC_STRETCHDIB       =0x2000,      /* supports StretchDIBits       */
RC_OP_DX_OUTPUT     =0x4000,
RC_DEVBITS          =0x8000
}

enum {
/* DIB color table identifiers */
DIB_RGB_COLORS      =0, /* color table in RGBs */
DIB_PAL_COLORS      =1 /* color table in palette indices */
}

enum {
/* constants for Get/SetSystemPaletteUse() */
SYSPAL_ERROR    =0,
SYSPAL_STATIC   =1,
SYSPAL_NOSTATIC =2
}

enum {
/* constants for CreateDIBitmap */
CBM_INIT        = 0x04L   /* initialize bitmap */
}

enum {
/* ExtFloodFill style flags */
FLOODFILLBORDER   =0,
FLOODFILLSURFACE  =1
}

enum {
/* size of a device name string */
CCHDEVICENAME = 32
}

enum {
/* size of a form name string */
CCHFORMNAME = 32
}

struct DEVMODEA {
    BYTE   dmDeviceName[CCHDEVICENAME];
    WORD dmSpecVersion;
    WORD dmDriverVersion;
    WORD dmSize;
    WORD dmDriverExtra;
    DWORD dmFields;
    short dmOrientation;
    short dmPaperSize;
    short dmPaperLength;
    short dmPaperWidth;
    short dmScale;
    short dmCopies;
    short dmDefaultSource;
    short dmPrintQuality;
    short dmColor;
    short dmDuplex;
    short dmYResolution;
    short dmTTOption;
    short dmCollate;
    BYTE   dmFormName[CCHFORMNAME];
    WORD   dmLogPixels;
    DWORD  dmBitsPerPel;
    DWORD  dmPelsWidth;
    DWORD  dmPelsHeight;
    DWORD  dmDisplayFlags;
    DWORD  dmDisplayFrequency;
    DWORD  dmICMMethod;
    DWORD  dmICMIntent;
    DWORD  dmMediaType;
    DWORD  dmDitherType;
    DWORD  dmICCManufacturer;
    DWORD  dmICCModel;
    DWORD  dmPanningWidth;
    DWORD  dmPanningHeight;
} 
alias DEVMODEA * PDEVMODEA,NPDEVMODEA,LPDEVMODEA;
struct DEVMODEW {
    WCHAR  dmDeviceName[CCHDEVICENAME];
    WORD dmSpecVersion;
    WORD dmDriverVersion;
    WORD dmSize;
    WORD dmDriverExtra;
    DWORD dmFields;
    short dmOrientation;
    short dmPaperSize;
    short dmPaperLength;
    short dmPaperWidth;
    short dmScale;
    short dmCopies;
    short dmDefaultSource;
    short dmPrintQuality;
    short dmColor;
    short dmDuplex;
    short dmYResolution;
    short dmTTOption;
    short dmCollate;
    WCHAR  dmFormName[CCHFORMNAME];
    WORD   dmLogPixels;
    DWORD  dmBitsPerPel;
    DWORD  dmPelsWidth;
    DWORD  dmPelsHeight;
    DWORD  dmDisplayFlags;
    DWORD  dmDisplayFrequency;
    DWORD  dmICMMethod;
    DWORD  dmICMIntent;
    DWORD  dmMediaType;
    DWORD  dmDitherType;
    DWORD  dmICCManufacturer;
    DWORD  dmICCModel;
    DWORD  dmPanningWidth;
    DWORD  dmPanningHeight;
} 
alias DEVMODEW * PDEVMODEW,NPDEVMODEW,LPDEVMODEW;

enum {
DM_SPECVERSION  = 0x0401
}

enum : uint {
/* field selection bits */
DM_ORIENTATION      =0x00000001,
DM_PAPERSIZE        =0x00000002,
DM_PAPERLENGTH      =0x00000004,
DM_PAPERWIDTH       =0x00000008,
DM_SCALE            =0x00000010,
DM_COPIES           =0x00000100,
DM_DEFAULTSOURCE    =0x00000200,
DM_PRINTQUALITY     =0x00000400,
DM_COLOR            =0x00000800,
DM_DUPLEX           =0x00001000,
DM_YRESOLUTION      =0x00002000,
DM_TTOPTION         =0x00004000,
DM_COLLATE          =0x00008000,
DM_FORMNAME         =0x00010000,
DM_LOGPIXELS        =0x00020000,
DM_BITSPERPEL       =0x00040000,
DM_PELSWIDTH        =0x00080000,
DM_PELSHEIGHT       =0x00100000,
DM_DISPLAYFLAGS     =0x00200000,
DM_DISPLAYFREQUENCY =0x00400000,
DM_PANNINGWIDTH     =0x00800000,
DM_PANNINGHEIGHT    =0x01000000,
DM_ICMMETHOD        =0x02000000,
DM_ICMINTENT        =0x04000000,
DM_MEDIATYPE        =0x08000000,
DM_DITHERTYPE       =0x10000000,
DM_ICCMANUFACTURER  =0x20000000,
DM_ICCMODEL         =0x40000000
}

enum {
/* orientation selections */
DMORIENT_PORTRAIT   =1,
DMORIENT_LANDSCAPE  =2
}

enum {
/* paper selections */
DMPAPER_LETTER              = 1,  /* Letter 8 1/2 x 11 in               */
DMPAPER_FIRST               = DMPAPER_LETTER,
DMPAPER_LETTERSMALL         = 2,  /* Letter Small 8 1/2 x 11 in         */
DMPAPER_TABLOID             = 3,  /* Tabloid 11 x 17 in                 */
DMPAPER_LEDGER              = 4,  /* Ledger 17 x 11 in                  */
DMPAPER_LEGAL               = 5,  /* Legal 8 1/2 x 14 in                */
DMPAPER_STATEMENT           = 6,  /* Statement 5 1/2 x 8 1/2 in         */
DMPAPER_EXECUTIVE           = 7,  /* Executive 7 1/4 x 10 1/2 in        */
DMPAPER_A3                  = 8,  /* A3 297 x 420 mm                    */
DMPAPER_A4                  = 9,  /* A4 210 x 297 mm                    */
DMPAPER_A4SMALL             =10,  /* A4 Small 210 x 297 mm              */
DMPAPER_A5                  =11,  /* A5 148 x 210 mm                    */
DMPAPER_B4                 = 12,  /* B4 (JIS) 250 x 354                 */
DMPAPER_B5                  =13,  /* B5 (JIS) 182 x 257 mm              */
DMPAPER_FOLIO               =14,  /* Folio 8 1/2 x 13 in                */
DMPAPER_QUARTO              =15,  /* Quarto 215 x 275 mm                */
DMPAPER_10X14               =16,  /* 10x14 in                           */
DMPAPER_11X17               =17,  /* 11x17 in                           */
DMPAPER_NOTE                =18,  /* Note 8 1/2 x 11 in                 */
DMPAPER_ENV_9               =19,  /* Envelope #9 3 7/8 x 8 7/8          */
DMPAPER_ENV_10              =20,  /* Envelope #10 4 1/8 x 9 1/2         */
DMPAPER_ENV_11              =21,  /* Envelope #11 4 1/2 x 10 3/8        */
DMPAPER_ENV_12              =22,  /* Envelope #12 4 \276 x 11           */
DMPAPER_ENV_14              =23,  /* Envelope #14 5 x 11 1/2            */
DMPAPER_CSHEET              =24,  /* C size sheet                       */
DMPAPER_DSHEET              =25,  /* D size sheet                       */
DMPAPER_ESHEET              =26,  /* E size sheet                       */
DMPAPER_ENV_DL              =27,  /* Envelope DL 110 x 220mm            */
DMPAPER_ENV_C5              =28,  /* Envelope C5 162 x 229 mm           */
DMPAPER_ENV_C3              =29,  /* Envelope C3  324 x 458 mm          */
DMPAPER_ENV_C4              =30,  /* Envelope C4  229 x 324 mm          */
DMPAPER_ENV_C6              =31,  /* Envelope C6  114 x 162 mm          */
DMPAPER_ENV_C65             =32,  /* Envelope C65 114 x 229 mm          */
DMPAPER_ENV_B4              =33,  /* Envelope B4  250 x 353 mm          */
DMPAPER_ENV_B5              =34,  /* Envelope B5  176 x 250 mm          */
DMPAPER_ENV_B6              =35,  /* Envelope B6  176 x 125 mm          */
DMPAPER_ENV_ITALY           =36,  /* Envelope 110 x 230 mm              */
DMPAPER_ENV_MONARCH         =37,  /* Envelope Monarch 3.875 x 7.5 in    */
DMPAPER_ENV_PERSONAL        =38,  /* 6 3/4 Envelope 3 5/8 x 6 1/2 in    */
DMPAPER_FANFOLD_US          =39,  /* US Std Fanfold 14 7/8 x 11 in      */
DMPAPER_FANFOLD_STD_GERMAN  =40,  /* German Std Fanfold 8 1/2 x 12 in   */
DMPAPER_FANFOLD_LGL_GERMAN  =41,  /* German Legal Fanfold 8 1/2 x 13 in */
DMPAPER_ISO_B4              =42,  /* B4 (ISO) 250 x 353 mm              */
DMPAPER_JAPANESE_POSTCARD   =43,  /* Japanese Postcard 100 x 148 mm     */
DMPAPER_9X11                =44,  /* 9 x 11 in                          */
DMPAPER_10X11               =45,  /* 10 x 11 in                         */
DMPAPER_15X11               =46,  /* 15 x 11 in                         */
DMPAPER_ENV_INVITE          =47,  /* Envelope Invite 220 x 220 mm       */
DMPAPER_RESERVED_48         =48,  /* RESERVED--DO NOT USE               */
DMPAPER_RESERVED_49         =49,  /* RESERVED--DO NOT USE               */
DMPAPER_LETTER_EXTRA        =50,  /* Letter Extra 9 \275 x 12 in        */
DMPAPER_LEGAL_EXTRA         =51,  /* Legal Extra 9 \275 x 15 in         */
DMPAPER_TABLOID_EXTRA       =52,  /* Tabloid Extra 11.69 x 18 in        */
DMPAPER_A4_EXTRA            =53,  /* A4 Extra 9.27 x 12.69 in           */
DMPAPER_LETTER_TRANSVERSE   =54,  /* Letter Transverse 8 \275 x 11 in   */
DMPAPER_A4_TRANSVERSE       =55,  /* A4 Transverse 210 x 297 mm         */
DMPAPER_LETTER_EXTRA_TRANSVERSE =56, /* Letter Extra Transverse 9\275 x 12 in */
DMPAPER_A_PLUS              =57,  /* SuperA/SuperA/A4 227 x 356 mm      */
DMPAPER_B_PLUS              =58,  /* SuperB/SuperB/A3 305 x 487 mm      */
DMPAPER_LETTER_PLUS         =59, /* Letter Plus 8.5 x 12.69 in         */
DMPAPER_A4_PLUS             =60,  /* A4 Plus 210 x 330 mm               */
DMPAPER_A5_TRANSVERSE       =61,  /* A5 Transverse 148 x 210 mm         */
DMPAPER_B5_TRANSVERSE       =62,  /* B5 (JIS) Transverse 182 x 257 mm   */
DMPAPER_A3_EXTRA            =63,  /* A3 Extra 322 x 445 mm              */
DMPAPER_A5_EXTRA            =64,  /* A5 Extra 174 x 235 mm              */
DMPAPER_B5_EXTRA            =65,  /* B5 (ISO) Extra 201 x 276 mm        */
DMPAPER_A2                  =66,  /* A2 420 x 594 mm                    */
DMPAPER_A3_TRANSVERSE       =67,  /* A3 Transverse 297 x 420 mm         */
DMPAPER_A3_EXTRA_TRANSVERSE =68,  /* A3 Extra Transverse 322 x 445 mm   */
DMPAPER_LAST                =DMPAPER_A3_EXTRA_TRANSVERSE,
DMPAPER_USER                =256
}

enum {
/* bin selections */
DMBIN_UPPER         =1,
DMBIN_FIRST         =DMBIN_UPPER,
DMBIN_ONLYONE       =1,
DMBIN_LOWER         =2,
DMBIN_MIDDLE        =3,
DMBIN_MANUAL        =4,
DMBIN_ENVELOPE      =5,
DMBIN_ENVMANUAL     =6,
DMBIN_AUTO          =7,
DMBIN_TRACTOR       =8,
DMBIN_SMALLFMT      =9,
DMBIN_LARGEFMT      =10,
DMBIN_LARGECAPACITY =11,
DMBIN_CASSETTE      =14,
DMBIN_FORMSOURCE    =15,
DMBIN_LAST          =DMBIN_FORMSOURCE,

DMBIN_USER          =256     /* device specific bins start here */
}


enum {
/* print qualities */
DMRES_DRAFT         =(-1),
DMRES_LOW           =(-2),
DMRES_MEDIUM        =(-3),
DMRES_HIGH          =(-4)
}

enum {
/* color enable/disable for color printers */
DMCOLOR_MONOCHROME  =1,
DMCOLOR_COLOR       =2
}

enum {
/* duplex enable */
DMDUP_SIMPLEX    =1,
DMDUP_VERTICAL   =2,
DMDUP_HORIZONTAL =3
}

enum {
/* TrueType options */
DMTT_BITMAP     =1,       /* print TT fonts as graphics */
DMTT_DOWNLOAD   =2,       /* download TT fonts as soft fonts */
DMTT_SUBDEV     =3,       /* substitute device fonts for TT fonts */
DMTT_DOWNLOAD_OUTLINE =4 /* download TT fonts as outline soft fonts */
}

enum {
/* Collation selections */
DMCOLLATE_FALSE  =0,
DMCOLLATE_TRUE   =1
}

/* DEVMODE dmDisplayFlags flags */

//#define DM_GRAYSCALE    0x00000001 /* This flag is no longer valid */
//#define DM_INTERLACED   0x00000002 /* This flag is no longer valid */
enum { DMDISPLAYFLAGS_TEXTMODE = 0x00000004 }

enum {
/* ICM methods */
DMICMMETHOD_NONE    =1,   /* ICM disabled */
DMICMMETHOD_SYSTEM  =2,   /* ICM handled by system */
DMICMMETHOD_DRIVER  =3,   /* ICM handled by driver */
DMICMMETHOD_DEVICE  =4,   /* ICM handled by device */

DMICMMETHOD_USER  =256   /* Device-specific methods start here */
}

enum {
/* ICM Intents */
DMICM_SATURATE      =1,   /* Maximize color saturation */
DMICM_CONTRAST      =2,   /* Maximize color contrast */
DMICM_COLORMETRIC   =3,   /* Use specific color metric */

DMICM_USER        =256   /* Device-specific intents start here */
}

enum {
/* Media types */
DMMEDIA_STANDARD      =1,   /* Standard paper */
DMMEDIA_TRANSPARENCY  =2,   /* Transparency */
DMMEDIA_GLOSSY        =3,   /* Glossy paper */

DMMEDIA_USER        =256   /* Device-specific media start here */
}

enum {
/* Dither types */
DMDITHER_NONE       =1,   /* No dithering */
DMDITHER_COARSE     =2,   /* Dither with a coarse brush */
DMDITHER_FINE       =3,   /* Dither with a fine brush */
DMDITHER_LINEART    =4,   /* LineArt dithering */
DMDITHER_GRAYSCALE  =5,   /* Device does grayscaling */

DMDITHER_USER     =256   /* Device-specific dithers start here */
}

/* GetRegionData/ExtCreateRegion */

enum { RDH_RECTANGLES  =1 }

struct RGNDATAHEADER {
    DWORD   dwSize;
    DWORD   iType;
    DWORD   nCount;
    DWORD   nRgnSize;
    RECT    rcBound;
} 
alias RGNDATAHEADER * PRGNDATAHEADER;

struct RGNDATA {
    RGNDATAHEADER   rdh;
    char            Buffer[1];
} 
alias RGNDATA * PRGNDATA,NPRGNDATA,LPRGNDATA;

struct ABC {
    int     abcA;
    UINT    abcB;
    int     abcC;
} 
alias ABC * PABC,NPABC,LPABC;

struct ABCFLOAT {
    FLOAT   abcfA;
    FLOAT   abcfB;
    FLOAT   abcfC;
} 
alias ABCFLOAT * PABCFLOAT,NPABCFLOAT,LPABCFLOAT;

struct OUTLINETEXTMETRICA {
    UINT    otmSize;
    TEXTMETRICA otmTextMetrics;
    BYTE    otmFiller;
    PANOSE  otmPanoseNumber;
    UINT    otmfsSelection;
    UINT    otmfsType;
     int    otmsCharSlopeRise;
     int    otmsCharSlopeRun;
     int    otmItalicAngle;
    UINT    otmEMSquare;
     int    otmAscent;
     int    otmDescent;
    UINT    otmLineGap;
    UINT    otmsCapEmHeight;
    UINT    otmsXHeight;
    RECT    otmrcFontBox;
     int    otmMacAscent;
     int    otmMacDescent;
    UINT    otmMacLineGap;
    UINT    otmusMinimumPPEM;
    POINT   otmptSubscriptSize;
    POINT   otmptSubscriptOffset;
    POINT   otmptSuperscriptSize;
    POINT   otmptSuperscriptOffset;
    UINT    otmsStrikeoutSize;
     int    otmsStrikeoutPosition;
     int    otmsUnderscoreSize;
     int    otmsUnderscorePosition;
    PSTR    otmpFamilyName;
    PSTR    otmpFaceName;
    PSTR    otmpStyleName;
    PSTR    otmpFullName;
} 
alias OUTLINETEXTMETRICA * POUTLINETEXTMETRICA,NPOUTLINETEXTMETRICA,LPOUTLINETEXTMETRICA;
struct OUTLINETEXTMETRICW {
    UINT    otmSize;
    TEXTMETRICW otmTextMetrics;
    BYTE    otmFiller;
    PANOSE  otmPanoseNumber;
    UINT    otmfsSelection;
    UINT    otmfsType;
     int    otmsCharSlopeRise;
     int    otmsCharSlopeRun;
     int    otmItalicAngle;
    UINT    otmEMSquare;
     int    otmAscent;
     int    otmDescent;
    UINT    otmLineGap;
    UINT    otmsCapEmHeight;
    UINT    otmsXHeight;
    RECT    otmrcFontBox;
     int    otmMacAscent;
     int    otmMacDescent;
    UINT    otmMacLineGap;
    UINT    otmusMinimumPPEM;
    POINT   otmptSubscriptSize;
    POINT   otmptSubscriptOffset;
    POINT   otmptSuperscriptSize;
    POINT   otmptSuperscriptOffset;
    UINT    otmsStrikeoutSize;
     int    otmsStrikeoutPosition;
     int    otmsUnderscoreSize;
     int    otmsUnderscorePosition;
    PSTR    otmpFamilyName;
    PSTR    otmpFaceName;
    PSTR    otmpStyleName;
    PSTR    otmpFullName;
} 
alias OUTLINETEXTMETRICW * POUTLINETEXTMETRICW,NPOUTLINETEXTMETRICW,LPOUTLINETEXTMETRICW;

struct POLYTEXTA
{
    int       x;
    int       y;
    UINT      n;
    LPCSTR    lpstr;
    UINT      uiFlags;
    RECT      rcl;
    int      *pdx;
} 
alias POLYTEXTA * PPOLYTEXTA,NPPOLYTEXTA,LPPOLYTEXTA;
struct POLYTEXTW
{
    int       x;
    int       y;
    UINT      n;
    LPCWSTR   lpstr;
    UINT      uiFlags;
    RECT      rcl;
    int      *pdx;
} 
alias POLYTEXTW * PPOLYTEXTW,NPPOLYTEXTW,LPPOLYTEXTW;

struct FIXED {
    WORD    fract;
    short   value;
}

struct MAT2 {
     FIXED  eM11;
     FIXED  eM12;
     FIXED  eM21;
     FIXED  eM22;
} 
alias MAT2 * LPMAT2;

struct GLYPHMETRICS {
    UINT    gmBlackBoxX;
    UINT    gmBlackBoxY;
    POINT   gmptGlyphOrigin;
    short   gmCellIncX;
    short   gmCellIncY;
} 
alias GLYPHMETRICS * LPGLYPHMETRICS;

enum {
//  GetGlyphOutline constants
GGO_METRICS        =0,
GGO_BITMAP         =1,
GGO_NATIVE         =2,
GGO_GRAY2_BITMAP   =4,
GGO_GRAY4_BITMAP   =5,
GGO_GRAY8_BITMAP   =6,
}
enum { GGO_GLYPH_INDEX    =0x0080 }

enum { TT_POLYGON_TYPE   = 24 }

enum {
TT_PRIM_LINE       =1,
TT_PRIM_QSPLINE    =2
}

struct POINTFX
{
    FIXED x;
    FIXED y;
} 
alias POINTFX * LPPOINTFX;

struct TTPOLYCURVE
{
    WORD    wType;
    WORD    cpfx;
    POINTFX apfx[1];
} 
alias TTPOLYCURVE * LPTTPOLYCURVE;

struct TTPOLYGONHEADER
{
    DWORD   cb;
    DWORD   dwType;
    POINTFX pfxStart;
} 
alias TTPOLYGONHEADER * LPTTPOLYGONHEADER;


enum {
GCP_DBCS           =0x0001,
GCP_REORDER        =0x0002,
GCP_USEKERNING     =0x0008,
GCP_GLYPHSHAPE     =0x0010,
GCP_LIGATE         =0x0020,
GCP_GLYPHINDEXING  =0x0080,
GCP_DIACRITIC      =0x0100,
GCP_KASHIDA        =0x0400,
GCP_ERROR          =0x8000,
FLI_MASK           =0x103B
}

enum : uint {
GCP_JUSTIFY        =0x00010000,
GCP_NODIACRITICS   =0x00020000,
FLI_GLYPHS         =0x00040000,
GCP_CLASSIN        =0x00080000,
GCP_MAXEXTENT      =0x00100000,
GCP_JUSTIFYIN      =0x00200000,
GCP_DISPLAYZWG      =0x00400000,
GCP_SYMSWAPOFF      =0x00800000,
GCP_NUMERICOVERRIDE =0x01000000,
GCP_NEUTRALOVERRIDE =0x02000000,
GCP_NUMERICSLATIN   =0x04000000,
GCP_NUMERICSLOCAL   =0x08000000
}

enum {
GCPCLASS_LATIN                  =1,
GCPCLASS_HEBREW                 =2,
GCPCLASS_ARABIC                 =2,
GCPCLASS_NEUTRAL                =3,
GCPCLASS_LOCALNUMBER            =4,
GCPCLASS_LATINNUMBER            =5,
GCPCLASS_LATINNUMERICTERMINATOR =6,
GCPCLASS_LATINNUMERICSEPARATOR  =7,
GCPCLASS_NUMERICSEPARATOR       =8,
GCPCLASS_PREBOUNDLTR         =0x80,
GCPCLASS_PREBOUNDRTL         =0x40,
GCPCLASS_POSTBOUNDLTR        =0x20,
GCPCLASS_POSTBOUNDRTL        =0x10
}

enum {
GCPGLYPH_LINKBEFORE          =0x8000,
GCPGLYPH_LINKAFTER           =0x4000
}

struct GCP_RESULTSA {
    DWORD   lStructSize;
    LPSTR     lpOutString;
    UINT *lpOrder;
    int *lpDx;
    int *lpCaretPos;
    LPSTR   lpClass;
    LPWSTR  lpGlyphs;
    UINT    nGlyphs;
    int     nMaxFit;
} 
alias GCP_RESULTSA * LPGCP_RESULTSA;
struct GCP_RESULTSW {
    DWORD   lStructSize;
    LPWSTR    lpOutString;
    UINT *lpOrder;
    int *lpDx;
    int *lpCaretPos;
    LPSTR   lpClass;
    LPWSTR  lpGlyphs;
    UINT    nGlyphs;
    int     nMaxFit;
} 
alias GCP_RESULTSW * LPGCP_RESULTSW;

struct RASTERIZER_STATUS {
    short   nSize;
    short   wFlags;
    short   nLanguageID;
} 
alias RASTERIZER_STATUS * LPRASTERIZER_STATUS;

enum {
/* bits defined in wFlags of RASTERIZER_STATUS */
TT_AVAILABLE    =0x0001,
TT_ENABLED      =0x0002
}

/* Pixel format descriptor */
struct PIXELFORMATDESCRIPTOR
{
    WORD  nSize;
    WORD  nVersion;
    DWORD dwFlags;
    BYTE  iPixelType;
    BYTE  cColorBits;
    BYTE  cRedBits;
    BYTE  cRedShift;
    BYTE  cGreenBits;
    BYTE  cGreenShift;
    BYTE  cBlueBits;
    BYTE  cBlueShift;
    BYTE  cAlphaBits;
    BYTE  cAlphaShift;
    BYTE  cAccumBits;
    BYTE  cAccumRedBits;
    BYTE  cAccumGreenBits;
    BYTE  cAccumBlueBits;
    BYTE  cAccumAlphaBits;
    BYTE  cDepthBits;
    BYTE  cStencilBits;
    BYTE  cAuxBuffers;
    BYTE  iLayerType;
    BYTE  bReserved;
    DWORD dwLayerMask;
    DWORD dwVisibleMask;
    DWORD dwDamageMask;
} 
alias PIXELFORMATDESCRIPTOR * PPIXELFORMATDESCRIPTOR,LPPIXELFORMATDESCRIPTOR;

enum {
/* pixel types */
PFD_TYPE_RGBA        =0,
PFD_TYPE_COLORINDEX  =1
}

enum {
/* layer types */
PFD_MAIN_PLANE       =0,
PFD_OVERLAY_PLANE    =1,
PFD_UNDERLAY_PLANE   =(-1)
}

enum {
/* PIXELFORMATDESCRIPTOR flags */
PFD_DOUBLEBUFFER            =0x00000001,
PFD_STEREO                  =0x00000002,
PFD_DRAW_TO_WINDOW          =0x00000004,
PFD_DRAW_TO_BITMAP          =0x00000008,
PFD_SUPPORT_GDI             =0x00000010,
PFD_SUPPORT_OPENGL          =0x00000020,
PFD_GENERIC_FORMAT          =0x00000040,
PFD_NEED_PALETTE            =0x00000080,
PFD_NEED_SYSTEM_PALETTE     =0x00000100,
PFD_SWAP_EXCHANGE           =0x00000200,
PFD_SWAP_COPY               =0x00000400,
PFD_SWAP_LAYER_BUFFERS      =0x00000800,
PFD_GENERIC_ACCELERATED     =0x00001000
}

enum : uint {
/* PIXELFORMATDESCRIPTOR flags for use in ChoosePixelFormat only */
PFD_DEPTH_DONTCARE          =0x20000000,
PFD_DOUBLEBUFFER_DONTCARE   =0x40000000,
PFD_STEREO_DONTCARE         =0x80000000
}

//alias int (CALLBACK* OLDFONTENUMPROCA)(CONST LOGFONTA *, CONST TEXTMETRICA *, DWORD, LPARAM);
//alias int (CALLBACK* OLDFONTENUMPROCW)(CONST LOGFONTW *, CONST TEXTMETRICW *, DWORD, LPARAM);
alias int (* OLDFONTENUMPROCA)(LOGFONTA *, TEXTMETRICA *, DWORD, LPARAM);
alias int (* OLDFONTENUMPROCW)(LOGFONTW *, TEXTMETRICW *, DWORD, LPARAM);

alias OLDFONTENUMPROCA    FONTENUMPROCA;
alias  OLDFONTENUMPROCW    FONTENUMPROCW;

alias int (* GOBJENUMPROC)(LPVOID, LPARAM);
alias VOID (* LINEDDAPROC)(int, int, LPARAM);

int AddFontResourceA(LPCSTR);
int AddFontResourceW(LPCWSTR);

//BOOL  AnimatePalette(HPALETTE, UINT, UINT, CONST PALETTEENTRY *);
BOOL  AnimatePalette(HPALETTE, UINT, UINT, PALETTEENTRY *);
BOOL  Arc(HDC, int, int, int, int, int, int, int, int);
BOOL  BitBlt(HDC, int, int, int, int, HDC, int, int, DWORD);
BOOL  CancelDC(HDC);
BOOL  Chord(HDC, int, int, int, int, int, int, int, int);
int   ChoosePixelFormat(HDC, PIXELFORMATDESCRIPTOR *);
//int   ChoosePixelFormat(HDC, CONST PIXELFORMATDESCRIPTOR *);
HMETAFILE  CloseMetaFile(HDC);
int     CombineRgn(HRGN, HRGN, HRGN, int);
HMETAFILE CopyMetaFileA(HMETAFILE, LPCSTR);
HMETAFILE CopyMetaFileW(HMETAFILE, LPCWSTR);
//HBITMAP CreateBitmap(int, int, UINT, UINT, CONST VOID *);
//HBITMAP CreateBitmapIndirect(CONST BITMAP *);
//HBRUSH  CreateBrushIndirect(CONST LOGBRUSH *);
HBITMAP CreateBitmap(int, int, UINT, UINT, VOID *);
HBITMAP CreateBitmapIndirect(BITMAP *);
HBRUSH  CreateBrushIndirect(LOGBRUSH *);
HBITMAP CreateCompatibleBitmap(HDC, int, int);
HBITMAP CreateDiscardableBitmap(HDC, int, int);
HDC     CreateCompatibleDC(HDC);
HDC     CreateDCA(LPCSTR, LPCSTR , LPCSTR , DEVMODEA *);
HDC     CreateDCW(LPCWSTR, LPCWSTR , LPCWSTR , DEVMODEW *);
//HDC     CreateDCA(LPCSTR, LPCSTR , LPCSTR , CONST DEVMODEA *);
//HDC     CreateDCW(LPCWSTR, LPCWSTR , LPCWSTR , CONST DEVMODEW *);
HBITMAP CreateDIBitmap(HDC, BITMAPINFOHEADER *, DWORD, VOID *, BITMAPINFO *, UINT);
//HBITMAP CreateDIBitmap(HDC, CONST BITMAPINFOHEADER *, DWORD, CONST VOID *, CONST BITMAPINFO *, UINT);
HBRUSH  CreateDIBPatternBrush(HGLOBAL, UINT);
HBRUSH  CreateDIBPatternBrushPt(VOID *, UINT);
//HBRUSH  CreateDIBPatternBrushPt(CONST VOID *, UINT);
HRGN    CreateEllipticRgn(int, int, int, int);
HRGN    CreateEllipticRgnIndirect(RECT *);
//HRGN    CreateEllipticRgnIndirect(CONST RECT *);
HFONT   CreateFontIndirectA(LOGFONTA *);
HFONT   CreateFontIndirectW(LOGFONTW *);
/*
HFONT   CreateFontA(int, int, int, int, int, DWORD,
                             DWORD, DWORD, DWORD, DWORD, DWORD,
                             DWORD, DWORD, LPCSTR);
 */
HFONT   CreateFontW(int, int, int, int, int, DWORD,
                             DWORD, DWORD, DWORD, DWORD, DWORD,
                             DWORD, DWORD, LPCWSTR);

HBRUSH  CreateHatchBrush(int, COLORREF);
HDC     CreateICA(LPCSTR, LPCSTR , LPCSTR , DEVMODEA *);
HDC     CreateICW(LPCWSTR, LPCWSTR , LPCWSTR , DEVMODEW *);
//HDC     CreateICA(LPCSTR, LPCSTR , LPCSTR , CONST DEVMODEA *);
//HDC     CreateICW(LPCWSTR, LPCWSTR , LPCWSTR , CONST DEVMODEW *);
HDC     CreateMetaFileA(LPCSTR);
HDC     CreateMetaFileW(LPCWSTR);
HPALETTE CreatePalette(LOGPALETTE *);
//HPALETTE WINAPI CreatePalette(CONST LOGPALETTE *);
HPEN    CreatePen(int, int, COLORREF);
HPEN    CreatePenIndirect(LOGPEN *);
//HPEN    WINAPI CreatePenIndirect(CONST LOGPEN *);
//HRGN    WINAPI CreatePolyPolygonRgn(CONST POINT *, CONST INT *, int, int);
HRGN    CreatePolyPolygonRgn(POINT *, INT *, int, int);
HBRUSH  CreatePatternBrush(HBITMAP);
HRGN    CreateRectRgn(int, int, int, int);
HRGN    CreateRectRgnIndirect(RECT *);
//HRGN    WINAPI CreateRectRgnIndirect(CONST RECT *);
HRGN    CreateRoundRectRgn(int, int, int, int, int, int);
BOOL    CreateScalableFontResourceA(DWORD, LPCSTR, LPCSTR, LPCSTR);
BOOL    CreateScalableFontResourceW(DWORD, LPCWSTR, LPCWSTR, LPCWSTR);
HBRUSH  CreateSolidBrush(COLORREF);

BOOL DeleteDC(HDC);
BOOL DeleteMetaFile(HMETAFILE);
BOOL DeleteObject(HGDIOBJ);
int  DescribePixelFormat(HDC, int, UINT, LPPIXELFORMATDESCRIPTOR);

/* define types of pointers to ExtDeviceMode() and DeviceCapabilities()
 * functions for Win 3.1 compatibility
 */

enum {
/* mode selections for the device mode function */
DM_UPDATE           =1,
DM_COPY             =2,
DM_PROMPT           =4,
DM_MODIFY           =8,

DM_IN_BUFFER        =DM_MODIFY,
DM_IN_PROMPT        =DM_PROMPT,
DM_OUT_BUFFER       =DM_COPY,
DM_OUT_DEFAULT      =DM_UPDATE
}

enum {
/* device capabilities indices */
DC_FIELDS           =1,
DC_PAPERS           =2,
DC_PAPERSIZE        =3,
DC_MINEXTENT        =4,
DC_MAXEXTENT        =5,
DC_BINS             =6,
DC_DUPLEX           =7,
DC_SIZE             =8,
DC_EXTRA            =9,
DC_VERSION          =10,
DC_DRIVER           =11,
DC_BINNAMES         =12,
DC_ENUMRESOLUTIONS  =13,
DC_FILEDEPENDENCIES =14,
DC_TRUETYPE         =15,
DC_PAPERNAMES       =16,
DC_ORIENTATION      =17,
DC_COPIES           =18,
DC_BINADJUST            =19,
DC_EMF_COMPLIANT        =20,
DC_DATATYPE_PRODUCED    =21,
DC_COLLATE              =22
}

enum : uint {
/* bit fields of the return value (DWORD) for DC_TRUETYPE */
DCTT_BITMAP             =0x0000001,
DCTT_DOWNLOAD           =0x0000002,
DCTT_SUBDEV             =0x0000004,
DCTT_DOWNLOAD_OUTLINE   =0x0000008
}

enum {
/* return values for DC_BINADJUST */
DCBA_FACEUPNONE       =0x0000,
DCBA_FACEUPCENTER     =0x0001,
DCBA_FACEUPLEFT       =0x0002,
DCBA_FACEUPRIGHT      =0x0003,
DCBA_FACEDOWNNONE     =0x0100,
DCBA_FACEDOWNCENTER   =0x0101,
DCBA_FACEDOWNLEFT     =0x0102,
DCBA_FACEDOWNRIGHT    =0x0103
}

//int  DeviceCapabilitiesA(LPCSTR, LPCSTR, WORD,LPSTR, CONST DEVMODEA *);
//int  DeviceCapabilitiesW(LPCWSTR, LPCWSTR, WORD,LPWSTR, CONST DEVMODEW *);
int  DeviceCapabilitiesA(LPCSTR, LPCSTR, WORD,LPSTR, DEVMODEA *);
int  DeviceCapabilitiesW(LPCWSTR, LPCWSTR, WORD,LPWSTR, DEVMODEW *);

int  DrawEscape(HDC, int, int, LPCSTR);
BOOL Ellipse(HDC, int, int, int, int);

int  EnumFontFamiliesExA(HDC, LPLOGFONTA,FONTENUMPROCA, LPARAM,DWORD);
int  EnumFontFamiliesExW(HDC, LPLOGFONTW,FONTENUMPROCW, LPARAM,DWORD);

int EnumFontFamiliesA(HDC, LPCSTR, FONTENUMPROCA, LPARAM);
int EnumFontFamiliesW(HDC, LPCWSTR, FONTENUMPROCW, LPARAM);
int  EnumFontsA(HDC, LPCSTR,  FONTENUMPROCA, LPARAM);
int  EnumFontsW(HDC, LPCWSTR,  FONTENUMPROCW, LPARAM);

int  EnumObjects(HDC, int, GOBJENUMPROC, LPARAM);

BOOL EqualRgn(HRGN, HRGN);
int  Escape(HDC, int, int, LPCSTR, LPVOID);
int  ExtEscape(HDC, int, int, LPCSTR, int, LPSTR);
int  ExcludeClipRect(HDC, int, int, int, int);
//HRGN ExtCreateRegion(CONST XFORM *, DWORD, CONST RGNDATA *);
HRGN ExtCreateRegion(XFORM *, DWORD, RGNDATA *);
BOOL  ExtFloodFill(HDC, int, int, COLORREF, UINT);
BOOL   FillRgn(HDC, HRGN, HBRUSH);
BOOL   FloodFill(HDC, int, int, COLORREF);
BOOL   FrameRgn(HDC, HRGN, HBRUSH, int, int);
int   GetROP2(HDC);
BOOL  GetAspectRatioFilterEx(HDC, LPSIZE);
COLORREF GetBkColor(HDC);
int   GetBkMode(HDC);
LONG  GetBitmapBits(HBITMAP, LONG, LPVOID);
BOOL  GetBitmapDimensionEx(HBITMAP, LPSIZE);
UINT  GetBoundsRect(HDC, LPRECT, UINT);

BOOL  GetBrushOrgEx(HDC, LPPOINT);

BOOL  GetCharWidthA(HDC, UINT, UINT, LPINT);
BOOL  GetCharWidthW(HDC, UINT, UINT, LPINT);
BOOL  GetCharWidth32A(HDC, UINT, UINT, LPINT);
BOOL  GetCharWidth32W(HDC, UINT, UINT, LPINT);
BOOL  GetCharWidthFloatA(HDC, UINT, UINT, PFLOAT);
BOOL  GetCharWidthFloatW(HDC, UINT, UINT, PFLOAT);

BOOL  GetCharABCWidthsA(HDC, UINT, UINT, LPABC);
BOOL  GetCharABCWidthsW(HDC, UINT, UINT, LPABC);
BOOL  GetCharABCWidthsFloatA(HDC, UINT, UINT, LPABCFLOAT);
BOOL  GetCharABCWidthsFloatW(HDC, UINT, UINT, LPABCFLOAT);

int   GetClipBox(HDC, LPRECT);
int   GetClipRgn(HDC, HRGN);
int   GetMetaRgn(HDC, HRGN);
HGDIOBJ GetCurrentObject(HDC, UINT);
BOOL  GetCurrentPositionEx(HDC, LPPOINT);
int   GetDeviceCaps(HDC, int);
int   GetDIBits(HDC, HBITMAP, UINT, UINT, LPVOID, LPBITMAPINFO, UINT);
DWORD GetFontData(HDC, DWORD, DWORD, LPVOID, DWORD);
DWORD GetGlyphOutlineA(HDC, UINT, UINT, LPGLYPHMETRICS, DWORD, LPVOID, MAT2 *);
DWORD GetGlyphOutlineW(HDC, UINT, UINT, LPGLYPHMETRICS, DWORD, LPVOID, MAT2 *);
int   GetGraphicsMode(HDC);
int   GetMapMode(HDC);
UINT  GetMetaFileBitsEx(HMETAFILE, UINT, LPVOID);
HMETAFILE GetMetaFileA(LPCSTR);
HMETAFILE GetMetaFileW(LPCWSTR);
COLORREF GetNearestColor(HDC, COLORREF);
UINT  GetNearestPaletteIndex(HPALETTE, COLORREF);
DWORD GetObjectType(HGDIOBJ h);

UINT GetOutlineTextMetricsA(HDC, UINT, LPOUTLINETEXTMETRICA);
UINT GetOutlineTextMetricsW(HDC, UINT, LPOUTLINETEXTMETRICW);


UINT  GetPaletteEntries(HPALETTE, UINT, UINT, LPPALETTEENTRY);
COLORREF GetPixel(HDC, int, int);
int   GetPixelFormat(HDC);
int   GetPolyFillMode(HDC);
BOOL  GetRasterizerCaps(LPRASTERIZER_STATUS, UINT);
DWORD GetRegionData(HRGN, DWORD, LPRGNDATA);
int   GetRgnBox(HRGN, LPRECT);
HGDIOBJ GetStockObject(int);
int   GetStretchBltMode(HDC);
UINT  GetSystemPaletteEntries(HDC, UINT, UINT, LPPALETTEENTRY);
UINT  GetSystemPaletteUse(HDC);
int   GetTextCharacterExtra(HDC);
UINT  GetTextAlign(HDC);
COLORREF GetTextColor(HDC);

BOOL  GetTextExtentPointA(HDC,LPCSTR,int,LPSIZE);
BOOL  GetTextExtentPointW(HDC,LPCWSTR,int,LPSIZE);

BOOL  GetTextExtentPoint32A(HDC,LPCSTR,int,LPSIZE);
BOOL  GetTextExtentPoint32W(HDC,LPCWSTR,int,LPSIZE);

BOOL  GetTextExtentExPointA(HDC,LPCSTR,int,int,LPINT,LPINT,LPSIZE);
BOOL  GetTextExtentExPointW(HDC,LPCWSTR,int,int,LPINT,LPINT,LPSIZE);

int GetTextCharset(HDC hdc);
int GetTextCharsetInfo(HDC hdc, LPFONTSIGNATURE lpSig, DWORD dwFlags);
BOOL TranslateCharsetInfo( DWORD *lpSrc, LPCHARSETINFO lpCs, DWORD dwFlags);
DWORD GetFontLanguageInfo( HDC );
DWORD GetCharacterPlacementA(HDC, LPCSTR, int, int, LPGCP_RESULTSA, DWORD);
DWORD GetCharacterPlacementW(HDC, LPCWSTR, int, int, LPGCP_RESULTSW, DWORD);

BOOL  GetViewportExtEx(HDC, LPSIZE);
BOOL  GetViewportOrgEx(HDC, LPPOINT);
BOOL  GetWindowExtEx(HDC, LPSIZE);
BOOL  GetWindowOrgEx(HDC, LPPOINT);

int  IntersectClipRect(HDC, int, int, int, int);
BOOL InvertRgn(HDC, HRGN);
BOOL LineDDA(int, int, int, int, LINEDDAPROC, LPARAM);
BOOL LineTo(HDC, int, int);
BOOL MaskBlt(HDC, int, int, int, int,
              HDC, int, int, HBITMAP, int, int, DWORD);
//BOOL PlgBlt(HDC, CONST POINT *, HDC, int, int, int,int, HBITMAP, int, int);
BOOL PlgBlt(HDC, POINT *, HDC, int, int, int, int, HBITMAP, int, int);

int  OffsetClipRgn(HDC, int, int);
int  OffsetRgn(HRGN, int, int);
BOOL PatBlt(HDC, int, int, int, int, DWORD);
BOOL Pie(HDC, int, int, int, int, int, int, int, int);
BOOL PlayMetaFile(HDC, HMETAFILE);
BOOL PaintRgn(HDC, HRGN);
BOOL PolyPolygon(HDC, POINT *, INT *, int);
//BOOL PolyPolygon(HDC, CONST POINT *, CONST INT *, int);
BOOL PtInRegion(HRGN, int, int);
BOOL PtVisible(HDC, int, int);
//BOOL RectInRegion(HRGN, CONST RECT *);
//BOOL RectVisible(HDC, CONST RECT *);
BOOL RectInRegion(HRGN, RECT *);
BOOL RectVisible(HDC, RECT *);
BOOL Rectangle(HDC, int, int, int, int);
BOOL RestoreDC(HDC, int);
//HDC  ResetDCA(HDC, CONST DEVMODEA *);
//HDC  ResetDCW(HDC, CONST DEVMODEW *);
HDC  ResetDCA(HDC, DEVMODEA *);
HDC  ResetDCW(HDC, DEVMODEW *);
UINT RealizePalette(HDC);
BOOL RemoveFontResourceA(LPCSTR);
BOOL RemoveFontResourceW(LPCWSTR);
BOOL RoundRect(HDC, int, int, int, int, int, int);
BOOL ResizePalette(HPALETTE, UINT);

int  SaveDC(HDC);
int  SelectClipRgn(HDC, HRGN);
int  ExtSelectClipRgn(HDC, HRGN, int);
int  SetMetaRgn(HDC);
version( STANDALONE ) {
HGDIOBJ SelectObject(HDC, HGDIOBJ);
}
HPALETTE SelectPalette(HDC, HPALETTE, BOOL);
COLORREF SetBkColor(HDC, COLORREF);
int   SetBkMode(HDC, int);
//LONG  SetBitmapBits(HBITMAP, DWORD, CONST VOID *);
LONG  SetBitmapBits(HBITMAP, DWORD, VOID *);

//UINT  SetBoundsRect(HDC, CONST RECT *, UINT);
UINT  SetBoundsRect(HDC, RECT *, UINT);
//int   SetDIBits(HDC, HBITMAP, UINT, UINT, CONST VOID *, CONST BITMAPINFO *, UINT);
int   SetDIBits(HDC, HBITMAP, UINT, UINT, VOID *, BITMAPINFO *, UINT);
//int   SetDIBitsToDevice(HDC, int, int, DWORD, DWORD, int,
//        int, UINT, UINT, CONST VOID *, CONST BITMAPINFO *, UINT);
int   SetDIBitsToDevice(HDC, int, int, DWORD, DWORD, int,
        int, UINT, UINT, VOID *, BITMAPINFO *, UINT);
DWORD SetMapperFlags(HDC, DWORD);
int   SetGraphicsMode(HDC hdc, int iMode);
int   SetMapMode(HDC, int);
//HMETAFILE   SetMetaFileBitsEx(UINT, CONST BYTE *);
HMETAFILE   SetMetaFileBitsEx(UINT, BYTE *);
//UINT  SetPaletteEntries(HPALETTE, UINT, UINT, CONST PALETTEENTRY *);
UINT  SetPaletteEntries(HPALETTE, UINT, UINT, PALETTEENTRY *);
COLORREF SetPixel(HDC, int, int, COLORREF);
BOOL  SetPixelV(HDC, int, int, COLORREF);
//BOOL  SetPixelFormat(HDC, int, CONST PIXELFORMATDESCRIPTOR *);
BOOL  SetPixelFormat(HDC, int, PIXELFORMATDESCRIPTOR *);
int   SetPolyFillMode(HDC, int);
BOOL  StretchBlt(HDC, int, int, int, int, HDC, int, int, int, int, DWORD);
BOOL  SetRectRgn(HRGN, int, int, int, int);
//int   StretchDIBits(HDC, int, int, int, int, int, int, int, int, CONST
//        VOID *, CONST BITMAPINFO *, UINT, DWORD);
int   StretchDIBits(HDC, int, int, int, int, int, int, int, int, 
        VOID *, BITMAPINFO *, UINT, DWORD);
int   SetROP2(HDC, int);
int   SetStretchBltMode(HDC, int);
UINT  SetSystemPaletteUse(HDC, UINT);
int   SetTextCharacterExtra(HDC, int);
COLORREF SetTextColor(HDC, COLORREF);
UINT  SetTextAlign(HDC, UINT);
BOOL  SetTextJustification(HDC, int, int);
BOOL  UpdateColors(HDC);


BOOL  PlayMetaFileRecord(HDC, LPHANDLETABLE, LPMETARECORD, UINT);
alias int (* MFENUMPROC)(HDC, HANDLETABLE *, METARECORD *, int, LPARAM);
BOOL  EnumMetaFile(HDC, HMETAFILE, MFENUMPROC, LPARAM);

alias int (* ENHMFENUMPROC)(HDC, HANDLETABLE *, ENHMETARECORD *, int, LPARAM);

// Enhanced Metafile Function Declarations
HENHMETAFILE CloseEnhMetaFile(HDC);
HENHMETAFILE CopyEnhMetaFileA(HENHMETAFILE, LPCSTR);
HENHMETAFILE CopyEnhMetaFileW(HENHMETAFILE, LPCWSTR);
//HDC   CreateEnhMetaFileA(HDC, LPCSTR, CONST RECT *, LPCSTR);
//HDC   CreateEnhMetaFileW(HDC, LPCWSTR, CONST RECT *, LPCWSTR);
HDC   CreateEnhMetaFileA(HDC, LPCSTR, RECT *, LPCSTR);
HDC   CreateEnhMetaFileW(HDC, LPCWSTR, RECT *, LPCWSTR);
BOOL  DeleteEnhMetaFile(HENHMETAFILE);
//BOOL  EnumEnhMetaFile(HDC, HENHMETAFILE, ENHMFENUMPROC,LPVOID, CONST RECT *);
BOOL  EnumEnhMetaFile(HDC, HENHMETAFILE, ENHMFENUMPROC,LPVOID, RECT *);
HENHMETAFILE  GetEnhMetaFileA(LPCSTR);
HENHMETAFILE  GetEnhMetaFileW(LPCWSTR);
UINT  GetEnhMetaFileBits(HENHMETAFILE, UINT, LPBYTE);
UINT  GetEnhMetaFileDescriptionA(HENHMETAFILE, UINT, LPSTR );
UINT  GetEnhMetaFileDescriptionW(HENHMETAFILE, UINT, LPWSTR );
UINT  GetEnhMetaFileHeader(HENHMETAFILE, UINT, LPENHMETAHEADER );
UINT  GetEnhMetaFilePaletteEntries(HENHMETAFILE, UINT, LPPALETTEENTRY );
UINT  GetEnhMetaFilePixelFormat(HENHMETAFILE, UINT,
                                                 PIXELFORMATDESCRIPTOR *);
UINT  GetWinMetaFileBits(HENHMETAFILE, UINT, LPBYTE, INT, HDC);
BOOL  PlayEnhMetaFile(HDC, HENHMETAFILE, RECT *);
BOOL  PlayEnhMetaFileRecord(HDC, LPHANDLETABLE, ENHMETARECORD *, UINT);
HENHMETAFILE  SetEnhMetaFileBits(UINT, BYTE *);
HENHMETAFILE  SetWinMetaFileBits(UINT, BYTE *, HDC, METAFILEPICT *);
BOOL  GdiComment(HDC, UINT, BYTE *);


BOOL GetTextMetricsA(HDC, LPTEXTMETRICA);
BOOL GetTextMetricsW(HDC, LPTEXTMETRICW);


/* new GDI */
struct DIBSECTION {
    BITMAP              dsBm;
    BITMAPINFOHEADER    dsBmih;
    DWORD               dsBitfields[3];
    HANDLE              dshSection;
    DWORD               dsOffset;
} 
alias DIBSECTION * LPDIBSECTION,PDIBSECTION;

BOOL AngleArc(HDC, int, int, DWORD, FLOAT, FLOAT);
//BOOL PolyPolyline(HDC, CONST POINT *, CONST DWORD *, DWORD);
BOOL PolyPolyline(HDC, POINT *, DWORD *, DWORD);
BOOL GetWorldTransform(HDC, LPXFORM);
//BOOL SetWorldTransform(HDC, CONST XFORM *);
BOOL SetWorldTransform(HDC, XFORM *);
//BOOL ModifyWorldTransform(HDC, CONST XFORM *, DWORD);
//BOOL CombineTransform(LPXFORM, CONST XFORM *, CONST XFORM *);
BOOL ModifyWorldTransform(HDC, XFORM *, DWORD);
BOOL CombineTransform(LPXFORM, XFORM *, XFORM *);
//HBITMAP CreateDIBSection(HDC, CONST BITMAPINFO *, UINT, VOID **, HANDLE, DWORD);
HBITMAP CreateDIBSection(HDC, BITMAPINFO *, UINT, VOID **, HANDLE, DWORD);
UINT GetDIBColorTable(HDC, UINT, UINT, RGBQUAD *);
UINT SetDIBColorTable(HDC, UINT, UINT, RGBQUAD *);
//UINT SetDIBColorTable(HDC, UINT, UINT, CONST RGBQUAD *);

enum {
/* Flags value for COLORADJUSTMENT */
CA_NEGATIVE                 =0x0001,
CA_LOG_FILTER               =0x0002
}

enum {
/* IlluminantIndex values */
ILLUMINANT_DEVICE_DEFAULT   =0,
ILLUMINANT_A                =1,
ILLUMINANT_B                =2,
ILLUMINANT_C                =3,
ILLUMINANT_D50              =4,
ILLUMINANT_D55              =5,
ILLUMINANT_D65              =6,
ILLUMINANT_D75              =7,
ILLUMINANT_F2               =8,
ILLUMINANT_MAX_INDEX        =ILLUMINANT_F2,

ILLUMINANT_TUNGSTEN         =ILLUMINANT_A,
ILLUMINANT_DAYLIGHT         =ILLUMINANT_C,
ILLUMINANT_FLUORESCENT      =ILLUMINANT_F2,
ILLUMINANT_NTSC             =ILLUMINANT_C
}

enum : WORD {
/* Min and max for RedGamma, GreenGamma, BlueGamma */
RGB_GAMMA_MIN               =(WORD)02500,
RGB_GAMMA_MAX               =(WORD)65000,

/* Min and max for ReferenceBlack and ReferenceWhite */
REFERENCE_WHITE_MIN         =(WORD)6000,
REFERENCE_WHITE_MAX         =(WORD)10000,
REFERENCE_BLACK_MIN         =(WORD)0,
REFERENCE_BLACK_MAX         =(WORD)4000,
}

enum : SHORT {
/* Min and max for Contrast, Brightness, Colorfulness, RedGreenTint */
COLOR_ADJ_MIN               =(SHORT)-100,
COLOR_ADJ_MAX               =(SHORT)100
}

struct  COLORADJUSTMENT {
    WORD   caSize;
    WORD   caFlags;
    WORD   caIlluminantIndex;
    WORD   caRedGamma;
    WORD   caGreenGamma;
    WORD   caBlueGamma;
    WORD   caReferenceBlack;
    WORD   caReferenceWhite;
    SHORT  caContrast;
    SHORT  caBrightness;
    SHORT  caColorfulness;
    SHORT  caRedGreenTint;
} 
alias COLORADJUSTMENT * PCOLORADJUSTMENT,LPCOLORADJUSTMENT;

//BOOL SetColorAdjustment(HDC, CONST COLORADJUSTMENT *);
BOOL SetColorAdjustment(HDC, COLORADJUSTMENT *);
BOOL GetColorAdjustment(HDC, LPCOLORADJUSTMENT);
HPALETTE CreateHalftonePalette(HDC);

alias BOOL (* ABORTPROC)(HDC, int);

struct DOCINFOA {
    int     cbSize;
    LPCSTR   lpszDocName;
    LPCSTR   lpszOutput;
    LPCSTR   lpszDatatype;
    DWORD    fwType;
} 
alias DOCINFOA * LPDOCINFOA;
struct DOCINFOW {
    int     cbSize;
    LPCWSTR  lpszDocName;
    LPCWSTR  lpszOutput;
    LPCWSTR  lpszDatatype;
    DWORD    fwType;
} 
alias DOCINFOW * LPDOCINFOW;

enum { DI_APPBANDING   = 0x0001 }

//int StartDocA(HDC, CONST DOCINFOA *);
//int StartDocW(HDC, CONST DOCINFOW *);
int StartDocA(HDC, DOCINFOA *);
int StartDocW(HDC, DOCINFOW *);
int EndDoc(HDC);
int StartPage(HDC);
int EndPage(HDC);
int AbortDoc(HDC);
int SetAbortProc(HDC, ABORTPROC);

BOOL AbortPath(HDC);
BOOL ArcTo(HDC, int, int, int, int, int, int,int, int);
BOOL BeginPath(HDC);
BOOL CloseFigure(HDC);
BOOL EndPath(HDC);
BOOL FillPath(HDC);
BOOL FlattenPath(HDC);
int  GetPath(HDC, LPPOINT, LPBYTE, int);
HRGN PathToRegion(HDC);
//BOOL PolyDraw(HDC, CONST POINT *, CONST BYTE *, int);
BOOL PolyDraw(HDC, POINT *, BYTE *, int);
BOOL SelectClipPath(HDC, int);
int  SetArcDirection(HDC, int);
BOOL SetMiterLimit(HDC, FLOAT, PFLOAT);
BOOL StrokeAndFillPath(HDC);
BOOL StrokePath(HDC);
BOOL WidenPath(HDC);
//HPEN ExtCreatePen(DWORD, DWORD, CONST LOGBRUSH *, DWORD, CONST DWORD *);
HPEN ExtCreatePen(DWORD, DWORD, LOGBRUSH *, DWORD, DWORD *);
BOOL GetMiterLimit(HDC, PFLOAT);
int  GetArcDirection(HDC);

int   GetObjectA(HGDIOBJ, int, LPVOID);
int   GetObjectW(HGDIOBJ, int, LPVOID);

BOOL  MoveToEx(HDC, int, int, LPPOINT);
//BOOL  TextOutA(HDC, int, int, LPCSTR, int);
BOOL  TextOutW(HDC, int, int, LPCWSTR, int);
BOOL  ExtTextOutA(HDC, int, int, UINT, RECT *,LPCSTR, UINT, INT *);
BOOL  ExtTextOutW(HDC, int, int, UINT, RECT *,LPCWSTR, UINT, INT *);
//BOOL  ExtTextOutA(HDC, int, int, UINT, CONST RECT *,LPCSTR, UINT, CONST INT *);
//BOOL  ExtTextOutW(HDC, int, int, UINT, CONST RECT *,LPCWSTR, UINT, CONST INT *);
BOOL  PolyTextOutA(HDC, POLYTEXTA *, int);
BOOL  PolyTextOutW(HDC, POLYTEXTW *, int);
//BOOL  PolyTextOutA(HDC, CONST POLYTEXTA *, int);
//BOOL  PolyTextOutW(HDC, CONST POLYTEXTW *, int);

HRGN  CreatePolygonRgn(POINT *, int, int);
//HRGN  CreatePolygonRgn(CONST POINT *, int, int);
BOOL  DPtoLP(HDC, LPPOINT, int);
BOOL  LPtoDP(HDC, LPPOINT, int);
//BOOL  Polygon(HDC, CONST POINT *, int);
//BOOL  Polyline(HDC, CONST POINT *, int);
BOOL  Polygon(HDC, POINT *, int);
BOOL  Polyline(HDC, POINT *, int);

//BOOL  PolyBezier(HDC, CONST POINT *, DWORD);
//BOOL  PolyBezierTo(HDC, CONST POINT *, DWORD);
//BOOL  PolylineTo(HDC, CONST POINT *, DWORD);
BOOL  PolyBezier(HDC, POINT *, DWORD);
BOOL  PolyBezierTo(HDC, POINT *, DWORD);
BOOL  PolylineTo(HDC, POINT *, DWORD);

BOOL  SetViewportExtEx(HDC, int, int, LPSIZE);
BOOL  SetViewportOrgEx(HDC, int, int, LPPOINT);
BOOL  SetWindowExtEx(HDC, int, int, LPSIZE);
BOOL  SetWindowOrgEx(HDC, int, int, LPPOINT);

BOOL  OffsetViewportOrgEx(HDC, int, int, LPPOINT);
BOOL  OffsetWindowOrgEx(HDC, int, int, LPPOINT);
BOOL  ScaleViewportExtEx(HDC, int, int, int, int, LPSIZE);
BOOL  ScaleWindowExtEx(HDC, int, int, int, int, LPSIZE);
BOOL  SetBitmapDimensionEx(HBITMAP, int, int, LPSIZE);
BOOL  SetBrushOrgEx(HDC, int, int, LPPOINT);

int   GetTextFaceA(HDC, int, LPSTR);
int   GetTextFaceW(HDC, int, LPWSTR);

enum { FONTMAPPER_MAX = 10 }

struct KERNINGPAIR {
   WORD wFirst;
   WORD wSecond;
   int  iKernAmount;
} 
alias KERNINGPAIR * LPKERNINGPAIR;

DWORD GetKerningPairsA(HDC, DWORD, LPKERNINGPAIR);
DWORD GetKerningPairsW(HDC, DWORD, LPKERNINGPAIR);

BOOL  GetDCOrgEx(HDC,LPPOINT);
BOOL  FixBrushOrgEx(HDC,int,int,LPPOINT);
BOOL  UnrealizeObject(HGDIOBJ);

BOOL  GdiFlush();
DWORD GdiSetBatchLimit(DWORD);
DWORD GdiGetBatchLimit();

enum {
ICM_OFF   =1,
ICM_ON    =2,
ICM_QUERY =3
}
int SetICMMode(HDC, int);
BOOL CheckColorsInGamut(HDC,LPVOID,LPVOID,DWORD);
HANDLE GetColorSpace(HDC);
BOOL GetLogColorSpaceA(HCOLORSPACE,LPLOGCOLORSPACEA,DWORD);
BOOL GetLogColorSpaceW(HCOLORSPACE,LPLOGCOLORSPACEW,DWORD);
HCOLORSPACE CreateColorSpaceA(LPLOGCOLORSPACEA);
HCOLORSPACE CreateColorSpaceW(LPLOGCOLORSPACEW);
BOOL SetColorSpace(HDC,HCOLORSPACE);
BOOL DeleteColorSpace(HCOLORSPACE);
BOOL GetICMProfileA(HDC,LPDWORD,LPSTR);
BOOL GetICMProfileW(HDC,LPDWORD,LPWSTR);
BOOL SetICMProfileA(HDC,LPSTR);
BOOL SetICMProfileW(HDC,LPWSTR);
BOOL GetDeviceGammaRamp(HDC,LPVOID);
BOOL SetDeviceGammaRamp(HDC,LPVOID);
BOOL ColorMatchToTarget(HDC,HDC,DWORD);
alias int (* ICMENUMPROCA)(LPSTR, LPARAM);
alias int (* ICMENUMPROCW)(LPWSTR, LPARAM);
int EnumICMProfilesA(HDC,ICMENUMPROCA,LPARAM);
int EnumICMProfilesW(HDC,ICMENUMPROCW,LPARAM);


// Enhanced metafile constants.

enum : uint { ENHMETA_SIGNATURE       =0x464D4520 }

// Stock object flag used in the object handle index in the enhanced
// metafile records.
// E.g. The object handle index (META_STOCK_OBJECT | BLACK_BRUSH)
// represents the stock object BLACK_BRUSH.

enum : uint { ENHMETA_STOCK_OBJECT    = 0x80000000 }

enum {
// Enhanced metafile record types.
EMR_HEADER                     = 1,
EMR_POLYBEZIER                 = 2,
EMR_POLYGON                    = 3,
EMR_POLYLINE                   = 4,
EMR_POLYBEZIERTO               = 5,
EMR_POLYLINETO                 = 6,
EMR_POLYPOLYLINE               = 7,
EMR_POLYPOLYGON                = 8,
EMR_SETWINDOWEXTEX             = 9,
EMR_SETWINDOWORGEX             = 10,
EMR_SETVIEWPORTEXTEX           = 11,
EMR_SETVIEWPORTORGEX           = 12,
EMR_SETBRUSHORGEX              = 13,
EMR_EOF                        = 14,
EMR_SETPIXELV                  = 15,
EMR_SETMAPPERFLAGS             = 16,
EMR_SETMAPMODE                 = 17,
EMR_SETBKMODE                  = 18,
EMR_SETPOLYFILLMODE            = 19,
EMR_SETROP2                    = 20,
EMR_SETSTRETCHBLTMODE          = 21,
EMR_SETTEXTALIGN               = 22,
EMR_SETCOLORADJUSTMENT         = 23,
EMR_SETTEXTCOLOR               = 24,
EMR_SETBKCOLOR                 = 25,
EMR_OFFSETCLIPRGN              = 26,
EMR_MOVETOEX                   = 27,
EMR_SETMETARGN                 = 28,
EMR_EXCLUDECLIPRECT            = 29,
EMR_INTERSECTCLIPRECT          = 30,
EMR_SCALEVIEWPORTEXTEX         = 31,
EMR_SCALEWINDOWEXTEX           = 32,
EMR_SAVEDC                     = 33,
EMR_RESTOREDC                  = 34,
EMR_SETWORLDTRANSFORM          = 35,
EMR_MODIFYWORLDTRANSFORM       = 36,
EMR_SELECTOBJECT               = 37,
EMR_CREATEPEN                  = 38,
EMR_CREATEBRUSHINDIRECT        = 39,
EMR_DELETEOBJECT               = 40,
EMR_ANGLEARC                   = 41,
EMR_ELLIPSE                    = 42,
EMR_RECTANGLE                  = 43,
EMR_ROUNDRECT                  = 44,
EMR_ARC                        = 45,
EMR_CHORD                      = 46,
EMR_PIE                        = 47,
EMR_SELECTPALETTE              = 48,
EMR_CREATEPALETTE              = 49,
EMR_SETPALETTEENTRIES          = 50,
EMR_RESIZEPALETTE              = 51,
EMR_REALIZEPALETTE             = 52,
EMR_EXTFLOODFILL               = 53,
EMR_LINETO                     = 54,
EMR_ARCTO                      = 55,
EMR_POLYDRAW                   = 56,
EMR_SETARCDIRECTION            = 57,
EMR_SETMITERLIMIT              = 58,
EMR_BEGINPATH                  = 59,
EMR_ENDPATH                    = 60,
EMR_CLOSEFIGURE                = 61,
EMR_FILLPATH                   = 62,
EMR_STROKEANDFILLPATH          = 63,
EMR_STROKEPATH                 = 64,
EMR_FLATTENPATH                = 65,
EMR_WIDENPATH                  = 66,
EMR_SELECTCLIPPATH             = 67,
EMR_ABORTPATH                  = 68,

EMR_GDICOMMENT                 = 70,
EMR_FILLRGN                    = 71,
EMR_FRAMERGN                   = 72,
EMR_INVERTRGN                  = 73,
EMR_PAINTRGN                   = 74,
EMR_EXTSELECTCLIPRGN           = 75,
EMR_BITBLT                     = 76,
EMR_STRETCHBLT                 = 77,
EMR_MASKBLT                    = 78,
EMR_PLGBLT                     = 79,
EMR_SETDIBITSTODEVICE          = 80,
EMR_STRETCHDIBITS              = 81,
EMR_EXTCREATEFONTINDIRECTW     = 82,
EMR_EXTTEXTOUTA                = 83,
EMR_EXTTEXTOUTW                = 84,
EMR_POLYBEZIER16               = 85,
EMR_POLYGON16                  = 86,
EMR_POLYLINE16                 = 87,
EMR_POLYBEZIERTO16             = 88,
EMR_POLYLINETO16               = 89,
EMR_POLYPOLYLINE16             = 90,
EMR_POLYPOLYGON16              = 91,
EMR_POLYDRAW16                 = 92,
EMR_CREATEMONOBRUSH            = 93,
EMR_CREATEDIBPATTERNBRUSHPT    = 94,
EMR_EXTCREATEPEN               = 95,
EMR_POLYTEXTOUTA               = 96,
EMR_POLYTEXTOUTW               = 97,
EMR_SETICMMODE                 = 98,
EMR_CREATECOLORSPACE           = 99,
EMR_SETCOLORSPACE              =100,
EMR_DELETECOLORSPACE           =101,
EMR_GLSRECORD                  =102,
EMR_GLSBOUNDEDRECORD           =103,
EMR_PIXELFORMAT                =104,
EMR_MIN                        = 1,
EMR_MAX                        =104
}

// Base record type for the enhanced metafile.
struct EMR
{
    DWORD   iType;              // Enhanced metafile record type
    DWORD   nSize;              // Length of the record in bytes.
                                // This must be a multiple of 4.
} 
alias EMR * PEMR;

// Base text record type for the enhanced metafile.
struct EMRTEXT
{
    POINTL  ptlReference;
    DWORD   nChars;
    DWORD   offString;          // Offset to the string
    DWORD   fOptions;
    RECTL   rcl;
    DWORD   offDx;              // Offset to the inter-character spacing array.
                                // This is always given.
} 
alias EMRTEXT * PEMRTEXT;

// Record structures for the enhanced metafile.

struct ABORTPATH
{
    EMR     emr;
} 

alias ABORTPATH EMRABORTPATH,EMRBEGINPATH,EMRENDPATH,EMRCLOSEFIGURE,EMRFLATTENPATH,EMRWIDENPATH,EMRSETMETARGN,EMRSAVEDC,EMRREALIZEPALETTE;
alias ABORTPATH * PEMRABORTPATH,PEMRBEGINPATH,PEMRENDPATH,PEMRCLOSEFIGURE,PEMRFLATTENPATH,PEMRWIDENPATH,PEMRSETMETARGN,PEMRSAVEDC,PEMRREALIZEPALETTE;

struct EMRSELECTCLIPPATH
{
    EMR     emr;
    DWORD   iMode;
} 
alias EMRSELECTCLIPPATH EMRSETBKMODE,EMRSETMAPMODE,EMRSETPOLYFILLMODE,EMRSETROP2,EMRSETSTRETCHBLTMODE,EMRSETICMMODE,EMRSETTEXTALIGN;
alias EMRSELECTCLIPPATH * PEMRSELECTCLIPPATH,PEMRSETBKMODE,PEMRSETMAPMODE,PEMRSETPOLYFILLMODE,PEMRSETROP2,PEMRSETSTRETCHBLTMODE,PEMRSETICMMODE,PEMRSETTEXTALIGN;

struct EMRSETMITERLIMIT
{
    EMR     emr;
    FLOAT   eMiterLimit;
} 
alias EMRSETMITERLIMIT * PEMRSETMITERLIMIT;

struct EMRRESTOREDC
{
    EMR     emr;
    LONG    iRelative;          // Specifies a relative instance
} 
alias EMRRESTOREDC * PEMRRESTOREDC;

struct EMRSETARCDIRECTION
{
    EMR     emr;
    DWORD   iArcDirection;      // Specifies the arc direction in the
                                // advanced graphics mode.
} 
alias EMRSETARCDIRECTION * PEMRSETARCDIRECTION;

struct EMRSETMAPPERFLAGS
{
    EMR     emr;
    DWORD   dwFlags;
} 
alias EMRSETMAPPERFLAGS * PEMRSETMAPPERFLAGS;

struct EMRSETTEXTCOLOR
{
    EMR     emr;
    COLORREF crColor;
} 
alias EMRSETTEXTCOLOR EMRSETBKCOLOR;
alias EMRSETTEXTCOLOR * PEMRSETBKCOLOR,PEMRSETTEXTCOLOR;

struct EMRSELECTOBJECT
{
    EMR     emr;
    DWORD   ihObject;           // Object handle index
} 
alias EMRSELECTOBJECT EMRDELETEOBJECT;
alias EMRSELECTOBJECT * PEMRSELECTOBJECT,PEMRDELETEOBJECT;

struct EMRSELECTCOLORSPACE
{
    EMR     emr;
    DWORD   ihCS;               // ColorSpace handle index
} 
alias EMRSELECTCOLORSPACE EMRDELETECOLORSPACE;
alias EMRSELECTCOLORSPACE * PEMRSELECTCOLORSPACE,PEMRDELETECOLORSPACE;

struct EMRSELECTPALETTE
{
    EMR     emr;
    DWORD   ihPal;              // Palette handle index, background mode only
} 
alias EMRSELECTPALETTE * PEMRSELECTPALETTE;

struct EMRRESIZEPALETTE
{
    EMR     emr;
    DWORD   ihPal;              // Palette handle index
    DWORD   cEntries;
} 
alias EMRRESIZEPALETTE * PEMRRESIZEPALETTE;

struct EMRSETPALETTEENTRIES
{
    EMR     emr;
    DWORD   ihPal;              // Palette handle index
    DWORD   iStart;
    DWORD   cEntries;
    PALETTEENTRY aPalEntries[1];// The peFlags fields do not contain any flags
} 
alias EMRSETPALETTEENTRIES * PEMRSETPALETTEENTRIES;

struct EMRSETCOLORADJUSTMENT
{
    EMR     emr;
    COLORADJUSTMENT ColorAdjustment;
} 
alias EMRSETCOLORADJUSTMENT * PEMRSETCOLORADJUSTMENT;

struct EMRGDICOMMENT
{
    EMR     emr;
    DWORD   cbData;             // Size of data in bytes
    BYTE    Data[1];
} 
alias EMRGDICOMMENT * PEMRGDICOMMENT;

struct EMREOF
{
    EMR     emr;
    DWORD   nPalEntries;        // Number of palette entries
    DWORD   offPalEntries;      // Offset to the palette entries
    DWORD   nSizeLast;          // Same as nSize and must be the last DWORD
                                // of the record.  The palette entries,
                                // if exist, precede this field.
} 
alias EMREOF * PEMREOF;

struct EMRLINETO
{
    EMR     emr;
    POINTL  ptl;
} 
alias EMRLINETO EMRMOVETOEX;
alias EMRLINETO * PEMRLINETO,PEMRMOVETOEX;

struct EMROFFSETCLIPRGN
{
    EMR     emr;
    POINTL  ptlOffset;
} 
alias EMROFFSETCLIPRGN * PEMROFFSETCLIPRGN;

struct EMRFILLPATH
{
    EMR     emr;
    RECTL   rclBounds;          // Inclusive-inclusive bounds in device units
} 
alias EMRFILLPATH EMRSTROKEANDFILLPATH,EMRSTROKEPATH;
alias EMRFILLPATH * PEMRFILLPATH,PEMRSTROKEANDFILLPATH,PEMRSTROKEPATH;

struct EMREXCLUDECLIPRECT
{
    EMR     emr;
    RECTL   rclClip;
} 
alias EMREXCLUDECLIPRECT EMRINTERSECTCLIPRECT;
alias EMREXCLUDECLIPRECT * PEMREXCLUDECLIPRECT,PEMRINTERSECTCLIPRECT;

struct EMRSETVIEWPORTORGEX
{
    EMR     emr;
    POINTL  ptlOrigin;
} 
alias EMRSETVIEWPORTORGEX EMRSETWINDOWORGEX,EMRSETBRUSHORGEX;
alias EMRSETVIEWPORTORGEX * PEMRSETVIEWPORTORGEX,PEMRSETWINDOWORGEX,PEMRSETBRUSHORGEX;

struct EMRSETVIEWPORTEXTEX
{
    EMR     emr;
    SIZEL   szlExtent;
} 
alias EMRSETVIEWPORTEXTEX EMRSETWINDOWEXTEX;
alias EMRSETVIEWPORTEXTEX * PEMRSETVIEWPORTEXTEX,PEMRSETWINDOWEXTEX;

struct EMRSCALEVIEWPORTEXTEX
{
    EMR     emr;
    LONG    xNum;
    LONG    xDenom;
    LONG    yNum;
    LONG    yDenom;
} 
alias EMRSCALEVIEWPORTEXTEX EMRSCALEWINDOWEXTEX;
alias EMRSCALEVIEWPORTEXTEX * PEMRSCALEVIEWPORTEXTEX,PEMRSCALEWINDOWEXTEX;

struct EMRSETWORLDTRANSFORM
{
    EMR     emr;
    XFORM   xform;
} 
alias EMRSETWORLDTRANSFORM * PEMRSETWORLDTRANSFORM;

struct EMRMODIFYWORLDTRANSFORM
{
    EMR     emr;
    XFORM   xform;
    DWORD   iMode;
} 
alias EMRMODIFYWORLDTRANSFORM * PEMRMODIFYWORLDTRANSFORM;

struct EMRSETPIXELV
{
    EMR     emr;
    POINTL  ptlPixel;
    COLORREF crColor;
} 
alias EMRSETPIXELV * PEMRSETPIXELV;

struct EMREXTFLOODFILL
{
    EMR     emr;
    POINTL  ptlStart;
    COLORREF crColor;
    DWORD   iMode;
} 
alias EMREXTFLOODFILL * PEMREXTFLOODFILL;

struct EMRELLIPSE
{
    EMR     emr;
    RECTL   rclBox;             // Inclusive-inclusive bounding rectangle
} 
alias EMRELLIPSE EMRRECTANGLE;
alias EMRELLIPSE * PEMRELLIPSE,PEMRRECTANGLE;

struct EMRROUNDRECT
{
    EMR     emr;
    RECTL   rclBox;             // Inclusive-inclusive bounding rectangle
    SIZEL   szlCorner;
} 
alias EMRROUNDRECT * PEMRROUNDRECT;

struct EMRARC
{
    EMR     emr;
    RECTL   rclBox;             // Inclusive-inclusive bounding rectangle
    POINTL  ptlStart;
    POINTL  ptlEnd;
} 
alias EMRARC EMRARCTO,EMRCHORD,EMRPIE;
alias EMRARC * PEMRARC,PEMRARCTO,PEMRCHORD,PEMRPIE;

struct EMRANGLEARC
{
    EMR     emr;
    POINTL  ptlCenter;
    DWORD   nRadius;
    FLOAT   eStartAngle;
    FLOAT   eSweepAngle;
} 
alias EMRANGLEARC * PEMRANGLEARC;

struct EMRPOLYLINE
{
    EMR     emr;
    RECTL   rclBounds;          // Inclusive-inclusive bounds in device units
    DWORD   cptl;
    POINTL  aptl[1];
} 
alias EMRPOLYLINE EMRPOLYBEZIER,EMRPOLYGON,EMRPOLYBEZIERTO,EMRPOLYLINETO;
alias EMRPOLYLINE * PEMRPOLYLINE,PEMRPOLYBEZIER,PEMRPOLYGON,PEMRPOLYBEZIERTO,PEMRPOLYLINETO;

struct EMRPOLYLINE16
{
    EMR     emr;
    RECTL   rclBounds;          // Inclusive-inclusive bounds in device units
    DWORD   cpts;
    POINTS  apts[1];
} 
alias EMRPOLYLINE16 EMRPOLYBEZIER16,EMRPOLYGON16,EMRPOLYBEZIERTO16,EMRPOLYLINETO16;
alias EMRPOLYLINE16 * PEMRPOLYLINE16,PEMRPOLYBEZIER16,PEMRPOLYGON16,PEMRPOLYBEZIERTO16,PEMRPOLYLINETO16;

struct EMRPOLYDRAW
{
    EMR     emr;
    RECTL   rclBounds;          // Inclusive-inclusive bounds in device units
    DWORD   cptl;               // Number of points
    POINTL  aptl[1];            // Array of points
    BYTE    abTypes[1];         // Array of point types
} 
alias EMRPOLYDRAW * PEMRPOLYDRAW;

struct EMRPOLYDRAW16
{
    EMR     emr;
    RECTL   rclBounds;          // Inclusive-inclusive bounds in device units
    DWORD   cpts;               // Number of points
    POINTS  apts[1];            // Array of points
    BYTE    abTypes[1];         // Array of point types
} 
alias EMRPOLYDRAW16 * PEMRPOLYDRAW16;

struct EMRPOLYPOLYLINE
{
    EMR     emr;
    RECTL   rclBounds;          // Inclusive-inclusive bounds in device units
    DWORD   nPolys;             // Number of polys
    DWORD   cptl;               // Total number of points in all polys
    DWORD   aPolyCounts[1];     // Array of point counts for each poly
    POINTL  aptl[1];            // Array of points
} 
alias EMRPOLYPOLYLINE EMRPOLYPOLYGON;
alias EMRPOLYPOLYLINE * PEMRPOLYPOLYLINE,PEMRPOLYPOLYGON;

struct EMRPOLYPOLYLINE16
{
    EMR     emr;
    RECTL   rclBounds;          // Inclusive-inclusive bounds in device units
    DWORD   nPolys;             // Number of polys
    DWORD   cpts;               // Total number of points in all polys
    DWORD   aPolyCounts[1];     // Array of point counts for each poly
    POINTS  apts[1];            // Array of points
} 
alias EMRPOLYPOLYLINE16 EMRPOLYPOLYGON16;
alias EMRPOLYPOLYLINE16 * PEMRPOLYPOLYLINE16,PEMRPOLYPOLYGON16;

struct EMRINVERTRGN
{
    EMR     emr;
    RECTL   rclBounds;          // Inclusive-inclusive bounds in device units
    DWORD   cbRgnData;          // Size of region data in bytes
    BYTE    RgnData[1];
} 
alias EMRINVERTRGN EMRPAINTRGN;
alias EMRINVERTRGN * PEMRINVERTRGN,PEMRPAINTRGN;

struct EMRFILLRGN
{
    EMR     emr;
    RECTL   rclBounds;          // Inclusive-inclusive bounds in device units
    DWORD   cbRgnData;          // Size of region data in bytes
    DWORD   ihBrush;            // Brush handle index
    BYTE    RgnData[1];
} 
alias EMRFILLRGN * PEMRFILLRGN;

struct EMRFRAMERGN
{
    EMR     emr;
    RECTL   rclBounds;          // Inclusive-inclusive bounds in device units
    DWORD   cbRgnData;          // Size of region data in bytes
    DWORD   ihBrush;            // Brush handle index
    SIZEL   szlStroke;
    BYTE    RgnData[1];
} 
alias EMRFRAMERGN * PEMRFRAMERGN;

struct EMREXTSELECTCLIPRGN
{
    EMR     emr;
    DWORD   cbRgnData;          // Size of region data in bytes
    DWORD   iMode;
    BYTE    RgnData[1];
} 
alias EMREXTSELECTCLIPRGN * PEMREXTSELECTCLIPRGN;

struct EMREXTTEXTOUTA
{
    EMR     emr;
    RECTL   rclBounds;          // Inclusive-inclusive bounds in device units
    DWORD   iGraphicsMode;      // Current graphics mode
    FLOAT   exScale;            // X and Y scales from Page units to .01mm units
    FLOAT   eyScale;            //   if graphics mode is GM_COMPATIBLE.
    EMRTEXT emrtext;            // This is followed by the string and spacing
                                // array
} 
alias EMREXTTEXTOUTA EMREXTTEXTOUTW;
alias EMREXTTEXTOUTA * PEMREXTTEXTOUTA,PEMREXTTEXTOUTW;

struct EMRPOLYTEXTOUTA
{
    EMR     emr;
    RECTL   rclBounds;          // Inclusive-inclusive bounds in device units
    DWORD   iGraphicsMode;      // Current graphics mode
    FLOAT   exScale;            // X and Y scales from Page units to .01mm units
    FLOAT   eyScale;            //   if graphics mode is GM_COMPATIBLE.
    LONG    cStrings;
    EMRTEXT aemrtext[1];        // Array of EMRTEXT structures.  This is
                                // followed by the strings and spacing arrays.
} 
alias EMRPOLYTEXTOUTA EMRPOLYTEXTOUTW;
alias EMRPOLYTEXTOUTA * PEMRPOLYTEXTOUTA,PEMRPOLYTEXTOUTW;

struct EMRBITBLT
{
    EMR     emr;
    RECTL   rclBounds;          // Inclusive-inclusive bounds in device units
    LONG    xDest;
    LONG    yDest;
    LONG    cxDest;
    LONG    cyDest;
    DWORD   dwRop;
    LONG    xSrc;
    LONG    ySrc;
    XFORM   xformSrc;           // Source DC transform
    COLORREF crBkColorSrc;      // Source DC BkColor in RGB
    DWORD   iUsageSrc;          // Source bitmap info color table usage
                                // (DIB_RGB_COLORS)
    DWORD   offBmiSrc;          // Offset to the source BITMAPINFO structure
    DWORD   cbBmiSrc;           // Size of the source BITMAPINFO structure
    DWORD   offBitsSrc;         // Offset to the source bitmap bits
    DWORD   cbBitsSrc;          // Size of the source bitmap bits
} 
alias EMRBITBLT *PEMRBITBLT;

struct EMRSTRETCHBLT {
    EMR     emr;
    RECTL   rclBounds;          // Inclusive-inclusive bounds in device units
    LONG    xDest;
    LONG    yDest;
    LONG    cxDest;
    LONG    cyDest;
    DWORD   dwRop;
    LONG    xSrc;
    LONG    ySrc;
    XFORM   xformSrc;           // Source DC transform
    COLORREF crBkColorSrc;      // Source DC BkColor in RGB
    DWORD   iUsageSrc;          // Source bitmap info color table usage
                                // (DIB_RGB_COLORS)
    DWORD   offBmiSrc;          // Offset to the source BITMAPINFO structure
    DWORD   cbBmiSrc;           // Size of the source BITMAPINFO structure
    DWORD   offBitsSrc;         // Offset to the source bitmap bits
    DWORD   cbBitsSrc;          // Size of the source bitmap bits
    LONG    cxSrc;
    LONG    cySrc;
} 
alias EMRSTRETCHBLT * PEMRSTRETCHBLT;

struct EMRMASKBLT {
    EMR     emr;
    RECTL   rclBounds;          // Inclusive-inclusive bounds in device units
    LONG    xDest;
    LONG    yDest;
    LONG    cxDest;
    LONG    cyDest;
    DWORD   dwRop;
    LONG    xSrc;
    LONG    ySrc;
    XFORM   xformSrc;           // Source DC transform
    COLORREF crBkColorSrc;      // Source DC BkColor in RGB
    DWORD   iUsageSrc;          // Source bitmap info color table usage
                                // (DIB_RGB_COLORS)
    DWORD   offBmiSrc;          // Offset to the source BITMAPINFO structure
    DWORD   cbBmiSrc;           // Size of the source BITMAPINFO structure
    DWORD   offBitsSrc;         // Offset to the source bitmap bits
    DWORD   cbBitsSrc;          // Size of the source bitmap bits
    LONG    xMask;
    LONG    yMask;
    DWORD   iUsageMask;         // Mask bitmap info color table usage
    DWORD   offBmiMask;         // Offset to the mask BITMAPINFO structure if any
    DWORD   cbBmiMask;          // Size of the mask BITMAPINFO structure if any
    DWORD   offBitsMask;        // Offset to the mask bitmap bits if any
    DWORD   cbBitsMask;         // Size of the mask bitmap bits if any
} 
alias EMRMASKBLT * PEMRMASKBLT;

struct EMRPLGBLT {
    EMR     emr;
    RECTL   rclBounds;          // Inclusive-inclusive bounds in device units
    POINTL  aptlDest[3];
    LONG    xSrc;
    LONG    ySrc;
    LONG    cxSrc;
    LONG    cySrc;
    XFORM   xformSrc;           // Source DC transform
    COLORREF crBkColorSrc;      // Source DC BkColor in RGB
    DWORD   iUsageSrc;          // Source bitmap info color table usage
                                // (DIB_RGB_COLORS)
    DWORD   offBmiSrc;          // Offset to the source BITMAPINFO structure
    DWORD   cbBmiSrc;           // Size of the source BITMAPINFO structure
    DWORD   offBitsSrc;         // Offset to the source bitmap bits
    DWORD   cbBitsSrc;          // Size of the source bitmap bits
    LONG    xMask;
    LONG    yMask;
    DWORD   iUsageMask;         // Mask bitmap info color table usage
    DWORD   offBmiMask;         // Offset to the mask BITMAPINFO structure if any
    DWORD   cbBmiMask;          // Size of the mask BITMAPINFO structure if any
    DWORD   offBitsMask;        // Offset to the mask bitmap bits if any
    DWORD   cbBitsMask;         // Size of the mask bitmap bits if any
} 
alias EMRPLGBLT * PEMRPLGBLT;

struct EMRSETDIBITSTODEVICE {
    EMR     emr;
    RECTL   rclBounds;          // Inclusive-inclusive bounds in device units
    LONG    xDest;
    LONG    yDest;
    LONG    xSrc;
    LONG    ySrc;
    LONG    cxSrc;
    LONG    cySrc;
    DWORD   offBmiSrc;          // Offset to the source BITMAPINFO structure
    DWORD   cbBmiSrc;           // Size of the source BITMAPINFO structure
    DWORD   offBitsSrc;         // Offset to the source bitmap bits
    DWORD   cbBitsSrc;          // Size of the source bitmap bits
    DWORD   iUsageSrc;          // Source bitmap info color table usage
    DWORD   iStartScan;
    DWORD   cScans;
} 
alias EMRSETDIBITSTODEVICE * PEMRSETDIBITSTODEVICE;

struct EMRSTRETCHDIBITS {
    EMR     emr;
    RECTL   rclBounds;          // Inclusive-inclusive bounds in device units
    LONG    xDest;
    LONG    yDest;
    LONG    xSrc;
    LONG    ySrc;
    LONG    cxSrc;
    LONG    cySrc;
    DWORD   offBmiSrc;          // Offset to the source BITMAPINFO structure
    DWORD   cbBmiSrc;           // Size of the source BITMAPINFO structure
    DWORD   offBitsSrc;         // Offset to the source bitmap bits
    DWORD   cbBitsSrc;          // Size of the source bitmap bits
    DWORD   iUsageSrc;          // Source bitmap info color table usage
    DWORD   dwRop;
    LONG    cxDest;
    LONG    cyDest;
} 
alias EMRSTRETCHDIBITS * PEMRSTRETCHDIBITS;

struct EMREXTCREATEFONTINDIRECTW {
    EMR     emr;
    DWORD   ihFont;             // Font handle index
    EXTLOGFONTW elfw;
} 
alias EMREXTCREATEFONTINDIRECTW * PEMREXTCREATEFONTINDIRECTW;

struct EMRCREATEPALETTE
{
    EMR     emr;
    DWORD   ihPal;              // Palette handle index
    LOGPALETTE lgpl;            // The peFlags fields in the palette entries
                                // do not contain any flags
} 
alias EMRCREATEPALETTE * PEMRCREATEPALETTE;

struct EMRCREATECOLORSPACE
{
    EMR             emr;
    DWORD           ihCS;       // ColorSpace handle index
    LOGCOLORSPACEW  lcs;
} 
alias EMRCREATECOLORSPACE * PEMRCREATECOLORSPACE;


struct EMRCREATEPEN
{
    EMR     emr;
    DWORD   ihPen;              // Pen handle index
    LOGPEN  lopn;
} 
alias EMRCREATEPEN * PEMRCREATEPEN;

struct EMREXTCREATEPEN
{
    EMR     emr;
    DWORD   ihPen;              // Pen handle index
    DWORD   offBmi;             // Offset to the BITMAPINFO structure if any
    DWORD   cbBmi;              // Size of the BITMAPINFO structure if any
                                // The bitmap info is followed by the bitmap
                                // bits to form a packed DIB.
    DWORD   offBits;            // Offset to the brush bitmap bits if any
    DWORD   cbBits;             // Size of the brush bitmap bits if any
    EXTLOGPEN elp;              // The extended pen with the style array.
} 
alias EMREXTCREATEPEN * PEMREXTCREATEPEN;

struct EMRCREATEBRUSHINDIRECT
{
    EMR     emr;
    DWORD   ihBrush;            // Brush handle index
    LOGBRUSH lb;                // The style must be BS_SOLID, BS_HOLLOW,
                                // BS_NULL or BS_HATCHED.
} 
alias EMRCREATEBRUSHINDIRECT * PEMRCREATEBRUSHINDIRECT;

struct EMRCREATEMONOBRUSH
{
    EMR     emr;
    DWORD   ihBrush;            // Brush handle index
    DWORD   iUsage;             // Bitmap info color table usage
    DWORD   offBmi;             // Offset to the BITMAPINFO structure
    DWORD   cbBmi;              // Size of the BITMAPINFO structure
    DWORD   offBits;            // Offset to the bitmap bits
    DWORD   cbBits;             // Size of the bitmap bits
} 
alias EMRCREATEMONOBRUSH * PEMRCREATEMONOBRUSH;

struct EMRCREATEDIBPATTERNBRUSHPT
{
    EMR     emr;
    DWORD   ihBrush;            // Brush handle index
    DWORD   iUsage;             // Bitmap info color table usage
    DWORD   offBmi;             // Offset to the BITMAPINFO structure
    DWORD   cbBmi;              // Size of the BITMAPINFO structure
                                // The bitmap info is followed by the bitmap
                                // bits to form a packed DIB.
    DWORD   offBits;            // Offset to the bitmap bits
    DWORD   cbBits;             // Size of the bitmap bits
} 
alias EMRCREATEDIBPATTERNBRUSHPT * PEMRCREATEDIBPATTERNBRUSHPT;

struct EMRFORMAT
{
    DWORD   dSignature;         // Format signature, e.g. ENHMETA_SIGNATURE.
    DWORD   nVersion;           // Format version number.
    DWORD   cbData;             // Size of data in bytes.
    DWORD   offData;            // Offset to data from GDICOMMENT_IDENTIFIER.
                                // It must begin at a DWORD offset.
} 
alias EMRFORMAT * PEMRFORMAT;

struct EMRGLSRECORD
{
    EMR     emr;
    DWORD   cbData;             // Size of data in bytes
    BYTE    Data[1];
} 
alias EMRGLSRECORD * PEMRGLSRECORD;

struct EMRGLSBOUNDEDRECORD
{
    EMR     emr;
    RECTL   rclBounds;          // Bounds in recording coordinates
    DWORD   cbData;             // Size of data in bytes
    BYTE    Data[1];
} 
alias EMRGLSBOUNDEDRECORD * PEMRGLSBOUNDEDRECORD;

struct EMRPIXELFORMAT
{
    EMR     emr;
    PIXELFORMATDESCRIPTOR pfd;
} 
alias EMRPIXELFORMAT * PEMRPIXELFORMAT;

enum : uint {
GDICOMMENT_IDENTIFIER           =0x43494447,
GDICOMMENT_WINDOWS_METAFILE     =0x80000001,
GDICOMMENT_BEGINGROUP           =0x00000002,
GDICOMMENT_ENDGROUP             =0x00000003,
GDICOMMENT_MULTIFORMATS         =0x40000004
}
enum { EPS_SIGNATURE                   =0x46535045 }



// OpenGL wgl prototypes

BOOL  wglCopyContext(HGLRC, HGLRC, UINT);
HGLRC wglCreateContext(HDC);
HGLRC wglCreateLayerContext(HDC, int);
BOOL  wglDeleteContext(HGLRC);
HGLRC wglGetCurrentContext();
HDC   wglGetCurrentDC();
PROC  wglGetProcAddress(LPCSTR);
BOOL  wglMakeCurrent(HDC, HGLRC);
BOOL  wglShareLists(HGLRC, HGLRC);
BOOL  wglUseFontBitmapsA(HDC, DWORD, DWORD, DWORD);
BOOL  wglUseFontBitmapsW(HDC, DWORD, DWORD, DWORD);
BOOL  SwapBuffers(HDC);

struct POINTFLOAT {
    FLOAT   x;
    FLOAT   y;
} 
alias POINTFLOAT * PPOINTFLOAT;

struct GLYPHMETRICSFLOAT {
    FLOAT       gmfBlackBoxX;
    FLOAT       gmfBlackBoxY;
    POINTFLOAT  gmfptGlyphOrigin;
    FLOAT       gmfCellIncX;
    FLOAT       gmfCellIncY;
} 
alias GLYPHMETRICSFLOAT * PGLYPHMETRICSFLOAT,LPGLYPHMETRICSFLOAT;

enum {
WGL_FONT_LINES      =0,
WGL_FONT_POLYGONS   =1
}
BOOL  wglUseFontOutlinesA(HDC, DWORD, DWORD, DWORD, FLOAT,
                                           FLOAT, int, LPGLYPHMETRICSFLOAT);
BOOL  wglUseFontOutlinesW(HDC, DWORD, DWORD, DWORD, FLOAT,
                                           FLOAT, int, LPGLYPHMETRICSFLOAT);

/* Layer plane descriptor */
struct LAYERPLANEDESCRIPTOR { // lpd
    WORD  nSize;
    WORD  nVersion;
    DWORD dwFlags;
    BYTE  iPixelType;
    BYTE  cColorBits;
    BYTE  cRedBits;
    BYTE  cRedShift;
    BYTE  cGreenBits;
    BYTE  cGreenShift;
    BYTE  cBlueBits;
    BYTE  cBlueShift;
    BYTE  cAlphaBits;
    BYTE  cAlphaShift;
    BYTE  cAccumBits;
    BYTE  cAccumRedBits;
    BYTE  cAccumGreenBits;
    BYTE  cAccumBlueBits;
    BYTE  cAccumAlphaBits;
    BYTE  cDepthBits;
    BYTE  cStencilBits;
    BYTE  cAuxBuffers;
    BYTE  iLayerPlane;
    BYTE  bReserved;
    COLORREF crTransparent;
} 
alias LAYERPLANEDESCRIPTOR * PLAYERPLANEDESCRIPTOR,LPLAYERPLANEDESCRIPTOR;

enum {
/* LAYERPLANEDESCRIPTOR flags */
LPD_DOUBLEBUFFER        =0x00000001,
LPD_STEREO              =0x00000002,
LPD_SUPPORT_GDI         =0x00000010,
LPD_SUPPORT_OPENGL      =0x00000020,
LPD_SHARE_DEPTH         =0x00000040,
LPD_SHARE_STENCIL       =0x00000080,
LPD_SHARE_ACCUM         =0x00000100,
LPD_SWAP_EXCHANGE       =0x00000200,
LPD_SWAP_COPY           =0x00000400,
LPD_TRANSPARENT         =0x00001000
}

enum {
LPD_TYPE_RGBA        =0,
LPD_TYPE_COLORINDEX  =1
}

enum {
/* wglSwapLayerBuffers flags */
WGL_SWAP_MAIN_PLANE     =0x00000001,
WGL_SWAP_OVERLAY1       =0x00000002,
WGL_SWAP_OVERLAY2       =0x00000004,
WGL_SWAP_OVERLAY3       =0x00000008,
WGL_SWAP_OVERLAY4       =0x00000010,
WGL_SWAP_OVERLAY5       =0x00000020,
WGL_SWAP_OVERLAY6       =0x00000040,
WGL_SWAP_OVERLAY7       =0x00000080,
WGL_SWAP_OVERLAY8       =0x00000100,
WGL_SWAP_OVERLAY9       =0x00000200,
WGL_SWAP_OVERLAY10      =0x00000400,
WGL_SWAP_OVERLAY11      =0x00000800,
WGL_SWAP_OVERLAY12      =0x00001000,
WGL_SWAP_OVERLAY13      =0x00002000,
WGL_SWAP_OVERLAY14      =0x00004000,
WGL_SWAP_OVERLAY15      =0x00008000,
WGL_SWAP_UNDERLAY1      =0x00010000,
WGL_SWAP_UNDERLAY2      =0x00020000,
WGL_SWAP_UNDERLAY3      =0x00040000,
WGL_SWAP_UNDERLAY4      =0x00080000,
WGL_SWAP_UNDERLAY5      =0x00100000,
WGL_SWAP_UNDERLAY6      =0x00200000,
WGL_SWAP_UNDERLAY7      =0x00400000,
WGL_SWAP_UNDERLAY8      =0x00800000,
WGL_SWAP_UNDERLAY9      =0x01000000,
WGL_SWAP_UNDERLAY10     =0x02000000,
WGL_SWAP_UNDERLAY11     =0x04000000,
WGL_SWAP_UNDERLAY12     =0x08000000,
WGL_SWAP_UNDERLAY13     =0x10000000,
WGL_SWAP_UNDERLAY14     =0x20000000,
WGL_SWAP_UNDERLAY15     =0x40000000
}

BOOL wglDescribeLayerPlane(HDC, int, int, UINT,
                                            LPLAYERPLANEDESCRIPTOR);
int  wglSetLayerPaletteEntries(HDC, int, int, int,
                                                COLORREF *);
int  wglGetLayerPaletteEntries(HDC, int, int, int,
                                                COLORREF *);
BOOL wglRealizeLayerPalette(HDC, int, BOOL);
BOOL wglSwapLayerBuffers(HDC, UINT);

} // extern (Windows)
