module winnt;

/*
 * ported to D from ...
 */
version( STANDALONE ) {
} else {
import windows;
import com;
}

import windef;

/*++ BUILD Version: 0093     Increment this if a change has global effects
Copyright (c) 1990-1996  Microsoft Corporation
Module Name:
    winnt.h
Abstract:

    This module defines the 32-Bit Windows types and constants that are
    defined by NT, but exposed through the Win32 API.

Revision History:

--*/
extern (Windows)
{


//#include <ctype.h>  
enum { ANYSIZE_ARRAY = 1 }

//
//  The following are masks for the predefined standard access types
//
enum : uint {
DELETE                           =(0x00010000L),
READ_CONTROL                     =(0x00020000L),
WRITE_DAC                        =(0x00040000L),
WRITE_OWNER                      =(0x00080000L),
SYNCHRONIZE                      =(0x00100000L),

STANDARD_RIGHTS_REQUIRED         =(0x000F0000L),

STANDARD_RIGHTS_READ             =(READ_CONTROL),
STANDARD_RIGHTS_WRITE            =(READ_CONTROL),
STANDARD_RIGHTS_EXECUTE          =(READ_CONTROL),

STANDARD_RIGHTS_ALL              =(0x001F0000L),

SPECIFIC_RIGHTS_ALL              =(0x0000FFFFL),

//
// AccessSystemAcl access type
//

ACCESS_SYSTEM_SECURITY           =(0x01000000L),

//
// MaximumAllowed access type
//

MAXIMUM_ALLOWED                  =(0x02000000L),

//
//  These are the generic rights.
//

GENERIC_READ                     =(0x80000000L),
GENERIC_WRITE                    =(0x40000000L),
GENERIC_EXECUTE                  =(0x20000000L),
GENERIC_ALL                      =(0x10000000L)
}


//
// Basics
//

//
// UNICODE (Wide Character) types
//

/* // in windef.d
typedef wchar_t WCHAR;    // wc,   16-bit UNICODE character

typedef WCHAR *PWCHAR;
typedef WCHAR *LPWCH, *PWCH;
typedef CONST WCHAR *LPCWCH, *PCWCH;
typedef WCHAR *NWPSTR;
typedef WCHAR *LPWSTR, *PWSTR;
typedef CONST WCHAR *LPCWSTR, *PCWSTR;
*/

/*
//
// ANSI (Multi-byte Character) types
//
typedef CHAR *PCHAR;
typedef CHAR *LPCH, *PCH;

typedef CONST CHAR *LPCCH, *PCCH;
typedef CHAR *NPSTR;
typedef CHAR *LPSTR, *PSTR;
typedef CONST CHAR *LPCSTR, *PCSTR;
*/
//
// Neutral ANSI/UNICODE types and macros
//
//#ifdef  UNICODE                     // r_winnt
//#ifndef _TCHAR_DEFINED
//typedef WCHAR TCHAR, *PTCHAR;
//typedef WCHAR TBYTE , *PTBYTE ;
//#define _TCHAR_DEFINED
//#endif /* !_TCHAR_DEFINED */

//typedef LPWSTR LPTCH, PTCH;
//typedef LPWSTR PTSTR, LPTSTR;
//typedef LPCWSTR LPCTSTR;
//typedef LPWSTR LP;
//#define __TEXT(quote) L##quote      // r_winnt

//#else   /* UNICODE */               // r_winnt

//#ifndef _TCHAR_DEFINED
//typedef char TCHAR, *PTCHAR;
//typedef unsigned char TBYTE , *PTBYTE ;
//#define _TCHAR_DEFINED
//#endif /* !_TCHAR_DEFINED */

//typedef LPSTR LPTCH, PTCH;
//typedef LPSTR PTSTR, LPTSTR;
//typedef LPCSTR LPCTSTR;
//#define __TEXT(quote) quote         // r_winnt

//#endif /* UNICODE */                // r_winnt
//#define TEXT(quote) __TEXT(quote)   // r_winnt


//typedef SHORT *PSHORT;  
//typedef LONG *PLONG;    

//typedef void *HANDLE;
//#define DECLARE_HANDLE(name) struct name##__ { int unused; }; typedef struct name##__ *name
//typedef HANDLE *PHANDLE;

/*
//
// Flag (bit) fields
//
typedef BYTE   FCHAR;
typedef WORD   FSHORT;
typedef DWORD  FLONG;

typedef char CCHAR;          
typedef DWORD LCID;         
typedef PDWORD PLCID;       
typedef WORD   LANGID;      
*/

enum : uint {
APPLICATION_ERROR_MASK       =0x20000000,
ERROR_SEVERITY_SUCCESS       =0x00000000,
ERROR_SEVERITY_INFORMATIONAL =0x40000000,
ERROR_SEVERITY_WARNING       =0x80000000,
ERROR_SEVERITY_ERROR         =0xC0000000
}

//
// __int64 is only supported by 2.0 and later midl.
// __midl is set by the 2.0 midl and not by 1.0 midl.
//
/*
#define _DWORDLONG_
#if (!defined(MIDL_PASS) || defined(__midl)) && (!defined(_M_IX86) || (defined(_INTEGRAL_MAX_BITS) && _INTEGRAL_MAX_BITS >= 64))
typedef __int64 LONGLONG;
typedef unsigned __int64 DWORDLONG;

#define MAXLONGLONG                      (0x7fffffffffffffff)
#else
typedef double LONGLONG;
typedef double DWORDLONG;
#endif

typedef LONGLONG *PLONGLONG;
typedef DWORDLONG *PDWORDLONG;

// Update Sequence Number

typedef LONGLONG USN;
#if defined(MIDL_PASS)
typedef struct _LARGE_INTEGER {
#else // MIDL_PASS
typedef union _LARGE_INTEGER {
    struct {
        DWORD LowPart;
        LONG HighPart;
    };
    struct {
        DWORD LowPart;
        LONG HighPart;
    } u;
#endif //MIDL_PASS
    LONGLONG QuadPart;
} LARGE_INTEGER;

typedef LARGE_INTEGER *PLARGE_INTEGER;

#if defined(MIDL_PASS)
typedef struct _ULARGE_INTEGER {
#else // MIDL_PASS
typedef union _ULARGE_INTEGER {
    struct {
        DWORD LowPart;
        DWORD HighPart;
    };
    struct {
        DWORD LowPart;
        DWORD HighPart;
    } u;
#endif //MIDL_PASS
    DWORDLONG QuadPart;
} ULARGE_INTEGER;

typedef ULARGE_INTEGER *PULARGE_INTEGER;
*/
alias long LONGLONG;
alias ulong DWORDLONG;

alias LONGLONG *PLONGLONG;
alias DWORDLONG *PDWORDLONG;
union LARGE_INTEGER {
    struct {
        DWORD LowPart;
        LONG HighPart;
    };
    struct u {
        DWORD LowPart;
        LONG HighPart;
    };
    LONGLONG QuadPart;
}
alias LARGE_INTEGER * PLARGE_INTEGER;
union ULARGE_INTEGER {
    struct {
        DWORD LowPart;
        DWORD HighPart;
    };
    struct u {
        DWORD LowPart;
        DWORD HighPart;
    };
    DWORDLONG QuadPart;
} 
alias ULARGE_INTEGER * PULARGE_INTEGER;

//
// Locally Unique Identifier
//

struct LUID {
    DWORD LowPart;
    LONG HighPart;
} 
alias LUID * PLUID;


//
// Define operations to logically shift an int64 by 0..31 bits and to multiply
// 32-bits by 32-bits to form a 64-bit product.
//

/*

#if defined(MIDL_PASS) || defined(RC_INVOKED)

//
// Midl does not understand inline assembler. Therefore, the Rtl functions
// are used for shifts by 0.31 and multiplies of 32-bits times 32-bits to
// form a 64-bit product.
//

#define Int32x32To64(a, b) ((LONGLONG)((LONG)(a)) * (LONGLONG)((LONG)(b)))
#define UInt32x32To64(a, b) ((DWORDLONG)((DWORD)(a)) * (DWORDLONG)((DWORD)(b)))

#define Int64ShllMod32(a, b) ((DWORDLONG)(a) << (b))
#define Int64ShraMod32(a, b) ((LONGLONG)(a) >> (b))
#define Int64ShrlMod32(a, b) ((DWORDLONG)(a) >> (b))

#if defined (__cplusplus)
extern "C" {
#endif

LONGLONG
NTAPI
Int32x32To64 (
    LONG Multiplier,
    LONG Multiplicand
    );

DWORDLONG
NTAPI
UInt32x32To64 (
    DWORD Multiplier,
    DWORD Multiplicand
    );

DWORDLONG
NTAPI
Int64ShllMod32 (
    DWORDLONG Value,
    DWORD ShiftCount
    );

LONGLONG
NTAPI
Int64ShraMod32 (
    LONGLONG Value,
    DWORD ShiftCount
    );

DWORDLONG
NTAPI
Int64ShrlMod32 (
    DWORDLONG Value,
    DWORD ShiftCount
    );

#if defined (__cplusplus)
};
#endif

#pragma intrinsic(__emul)
#pragma intrinsic(__emulu)

#pragma intrinsic(__ll_lshift)
#pragma intrinsic(__ll_rshift)
#pragma intrinsic(__ull_rshift)

#elif defined(_M_IX86)

//
// The x86 C compiler understands inline assembler. Therefore, inline functions
// that employ inline assembler are used for shifts of 0..31.  The multiplies
// rely on the compiler recognizing the cast of the multiplicand to int64 to
// generate the optimal code inline.
//

#define Int32x32To64( a, b ) (LONGLONG)((LONGLONG)(LONG)(a) * (LONG)(b))
#define UInt32x32To64( a, b ) (DWORDLONG)((DWORDLONG)(DWORD)(a) * (DWORD)(b))

DWORDLONG
NTAPI
Int64ShllMod32 (
    DWORDLONG Value,
    DWORD ShiftCount
    );

LONGLONG
NTAPI
Int64ShraMod32 (
    LONGLONG Value,
    DWORD ShiftCount
    );

DWORDLONG
NTAPI
Int64ShrlMod32 (
    DWORDLONG Value,
    DWORD ShiftCount
    );

#pragma warning(disable:4035)               // re-enable below

__inline DWORDLONG
NTAPI
Int64ShllMod32 (
    DWORDLONG Value,
    DWORD ShiftCount
    )
{
    __asm    {
        mov     ecx, ShiftCount
        mov     eax, dword ptr [Value]
        mov     edx, dword ptr [Value+4]
        shld    edx, eax, cl
        shl     eax, cl
    }
}

__inline LONGLONG
NTAPI
Int64ShraMod32 (
    LONGLONG Value,
    DWORD ShiftCount
    )
{
    __asm {
        mov     ecx, ShiftCount
        mov     eax, dword ptr [Value]
        mov     edx, dword ptr [Value+4]
        shrd    eax, edx, cl
        sar     edx, cl
    }
}

__inline DWORDLONG
NTAPI
Int64ShrlMod32 (
    DWORDLONG Value,
    DWORD ShiftCount
    )
{
    __asm    {
        mov     ecx, ShiftCount
        mov     eax, dword ptr [Value]
        mov     edx, dword ptr [Value+4]
        shrd    eax, edx, cl
        shr     edx, cl
    }
}

#pragma warning(default:4035)

#elif defined(_M_ALPHA)

//
// Alpha has native 64-bit operations that are just as fast as their 32-bit
// counter parts. Therefore, the int64 data type is used directly to form
// shifts of 0..31 and multiplies of 32-bits times 32-bits to form a 64-bit
// product.
//

#define Int32x32To64(a, b) ((LONGLONG)((LONG)(a)) * (LONGLONG)((LONG)(b)))
#define UInt32x32To64(a, b) ((DWORDLONG)((DWORD)(a)) * (DWORDLONG)((DWORD)(b)))

#define Int64ShllMod32(a, b) ((DWORDLONG)(a) << (b))
#define Int64ShraMod32(a, b) ((LONGLONG)(a) >> (b))
#define Int64ShrlMod32(a, b) ((DWORDLONG)(a) >> (b))


#elif defined(_M_PPC)

#define Int32x32To64(a, b) ((LONGLONG)((LONG)(a)) * (LONGLONG)((LONG)(b)))
#define UInt32x32To64(a, b) ((DWORDLONG)((DWORD)(a)) * (DWORDLONG)((DWORD)(b)))

#define Int64ShllMod32(a, b) ((DWORDLONG)(a) << (b))
#define Int64ShraMod32(a, b) ((LONGLONG)(a) >> (b))
#define Int64ShrlMod32(a, b) ((DWORDLONG)(a) >> (b))

#else

#error Must define a target architecture.

#endif
*/

//#define UNICODE_NULL ((WCHAR)0) 
//typedef BYTE  BOOLEAN;           
//typedef BOOLEAN *PBOOLEAN;       
alias BYTE  BOOLEAN;           
alias BOOLEAN * PBOOLEAN;       

//
//  Doubly linked list structure.  Can be used as either a list head, or
//  as link words.
//

struct LIST_ENTRY {
//   LIST_ENTRY * volatile Flink;
//   LIST_ENTRY * volatile Blink;
   LIST_ENTRY * Flink;
   LIST_ENTRY * Blink;
} 
alias LIST_ENTRY * PLIST_ENTRY,PRLIST_ENTRY;

//
//  Singly linked list structure. Can be used as either a list head, or
//  as link words.
//

struct SINGLE_LIST_ENTRY {
    SINGLE_LIST_ENTRY * Next;
} 
alias SINGLE_LIST_ENTRY * PSINGLE_LIST_ENTRY;

//
// Base data structures for OLE support
//
version( STANDALONE ) {

struct GUID {          // size is 16
    DWORD Data1;
    WORD   Data2;
    WORD   Data3;
    BYTE  Data4[8];
}

struct  OBJECTID {     // size is 20
    GUID Lineage;
    DWORD Uniquifier;
}

} // version( STANDALONE )

enum {
MINCHAR     =0x80,
MAXCHAR     =0x7f,
MINSHORT    =0x8000,
MAXSHORT    =0x7fff,
MAXBYTE     =0xff, 
MAXWORD     =0xffff,
MINLONG     =(int)0x80000000,
MAXLONG     =(int)0x7fffffff
}
enum : uint {
MAXDWORD    = 0xffffffff
}
//
// Calculate the byte offset of a field in a structure of type type.
//

//#define FIELD_OFFSET(type, field)    ((LONG)&(((type *)0)->field))


//
// Calculate the address of the base of the structure given its type, and an
// address of a field within the structure.
//
/*
#define CONTAINING_RECORD(address, type, field) ((type *)( \
                                                  (PCHAR)(address) - \
                                                  (PCHAR)(&((type *)0)->field)))
*/
//
//  Language IDs.
//
//  The following two combinations of primary language ID and
//  sublanguage ID have special semantics:
//
//    Primary Language ID   Sublanguage ID      Result
//    -------------------   ---------------     ------------------------
//    LANG_NEUTRAL          SUBLANG_NEUTRAL     Language neutral
//    LANG_NEUTRAL          SUBLANG_DEFAULT     User default language
//    LANG_NEUTRAL          SUBLANG_SYS_DEFAULT System default language
//

//
//  Primary language IDs.
//

enum {
LANG_NEUTRAL                     =0x00,

LANG_AFRIKAANS                   =0x36,
LANG_ALBANIAN                    =0x1c,
LANG_ARABIC                      =0x01,
LANG_BASQUE                      =0x2d,
LANG_BELARUSIAN                  =0x23,
LANG_BULGARIAN                   =0x02,
LANG_CATALAN                     =0x03,
LANG_CHINESE                     =0x04,
LANG_CROATIAN                    =0x1a,
LANG_CZECH                       =0x05,
LANG_DANISH                      =0x06,
LANG_DUTCH                       =0x13,
LANG_ENGLISH                     =0x09,
LANG_ESTONIAN                    =0x25,
LANG_FAEROESE                    =0x38,
LANG_FARSI                       =0x29,
LANG_FINNISH                     =0x0b,
LANG_FRENCH                      =0x0c,
LANG_GERMAN                      =0x07,
LANG_GREEK                       =0x08,
LANG_HEBREW                      =0x0d,
LANG_HUNGARIAN                   =0x0e,
LANG_ICELANDIC                   =0x0f,
LANG_INDONESIAN                  =0x21,
LANG_ITALIAN                     =0x10,
LANG_JAPANESE                    =0x11,
LANG_KOREAN                      =0x12,
LANG_LATVIAN                     =0x26,
LANG_LITHUANIAN                  =0x27,
LANG_NORWEGIAN                   =0x14,
LANG_POLISH                      =0x15,
LANG_PORTUGUESE                  =0x16,
LANG_ROMANIAN                    =0x18,
LANG_RUSSIAN                     =0x19,
LANG_SERBIAN                     =0x1a,
LANG_SLOVAK                      =0x1b,
LANG_SLOVENIAN                   =0x24,
LANG_SPANISH                     =0x0a,
LANG_SWEDISH                     =0x1d,
LANG_THAI                        =0x1e,
LANG_TURKISH                     =0x1f,
LANG_UKRAINIAN                   =0x22,
LANG_VIETNAMESE                  =0x2a
}
//
//  Sublanguage IDs.
//
//  The name immediately following SUBLANG_ dictates which primary
//  language ID that sublanguage ID can be combined with to form a
//  valid language ID.
//
enum {
 SUBLANG_NEUTRAL                  =0x00,    // language neutral
 SUBLANG_DEFAULT                  =0x01,    // user default
 SUBLANG_SYS_DEFAULT              =0x02,    // system default
}
enum {
 SUBLANG_ARABIC_SAUDI_ARABIA      =0x01,    // Arabic (Saudi Arabia)
 SUBLANG_ARABIC_IRAQ              =0x02,    // Arabic (Iraq)
 SUBLANG_ARABIC_EGYPT             =0x03,    // Arabic (Egypt)
 SUBLANG_ARABIC_LIBYA             =0x04,    // Arabic (Libya)
 SUBLANG_ARABIC_ALGERIA           =0x05,    // Arabic (Algeria)
 SUBLANG_ARABIC_MOROCCO           =0x06,    // Arabic (Morocco)
 SUBLANG_ARABIC_TUNISIA           =0x07,    // Arabic (Tunisia)
 SUBLANG_ARABIC_OMAN              =0x08,    // Arabic (Oman)
 SUBLANG_ARABIC_YEMEN             =0x09,    // Arabic (Yemen)
 SUBLANG_ARABIC_SYRIA             =0x0a,    // Arabic (Syria)
 SUBLANG_ARABIC_JORDAN            =0x0b,    // Arabic (Jordan)
 SUBLANG_ARABIC_LEBANON           =0x0c,    // Arabic (Lebanon)
 SUBLANG_ARABIC_KUWAIT            =0x0d,    // Arabic (Kuwait)
 SUBLANG_ARABIC_UAE               =0x0e,    // Arabic (U.A.E)
 SUBLANG_ARABIC_BAHRAIN           =0x0f,    // Arabic (Bahrain)
 SUBLANG_ARABIC_QATAR             =0x10    // Arabic (Qatar)
}
enum {
 SUBLANG_CHINESE_TRADITIONAL      =0x01,    // Chinese (Taiwan)
 SUBLANG_CHINESE_SIMPLIFIED       =0x02,    // Chinese (PR China)
 SUBLANG_CHINESE_HONGKONG         =0x03,    // Chinese (Hong Kong)
 SUBLANG_CHINESE_SINGAPORE        =0x04    // Chinese (Singapore)
}
enum {
 SUBLANG_DUTCH                    =0x01,    // Dutch
 SUBLANG_DUTCH_BELGIAN            =0x02    // Dutch (Belgian)
}
enum {
 SUBLANG_ENGLISH_US               =0x01,    // English (USA)
 SUBLANG_ENGLISH_UK               =0x02,    // English (UK)
 SUBLANG_ENGLISH_AUS              =0x03,    // English (Australian)
 SUBLANG_ENGLISH_CAN              =0x04,    // English (Canadian)
 SUBLANG_ENGLISH_NZ               =0x05,    // English (New Zealand)
 SUBLANG_ENGLISH_EIRE             =0x06,    // English (Irish)
 SUBLANG_ENGLISH_SOUTH_AFRICA     =0x07,    // English (South Africa)
 SUBLANG_ENGLISH_JAMAICA          =0x08,    // English (Jamaica)
 SUBLANG_ENGLISH_CARIBBEAN        =0x09,    // English (Caribbean)
 SUBLANG_ENGLISH_BELIZE           =0x0a,    // English (Belize)
 SUBLANG_ENGLISH_TRINIDAD         =0x0b    // English (Trinidad)
}
enum {
 SUBLANG_FRENCH                   =0x01,    // French
 SUBLANG_FRENCH_BELGIAN           =0x02,    // French (Belgian)
 SUBLANG_FRENCH_CANADIAN          =0x03,    // French (Canadian)
 SUBLANG_FRENCH_SWISS             =0x04,    // French (Swiss)
 SUBLANG_FRENCH_LUXEMBOURG        =0x05    // French (Luxembourg)
}
enum {
 SUBLANG_GERMAN                   =0x01,    // German
 SUBLANG_GERMAN_SWISS             =0x02,    // German (Swiss)
 SUBLANG_GERMAN_AUSTRIAN          =0x03,    // German (Austrian)
 SUBLANG_GERMAN_LUXEMBOURG        =0x04,    // German (Luxembourg)
 SUBLANG_GERMAN_LIECHTENSTEIN     =0x05    // German (Liechtenstein)
}
enum {
 SUBLANG_ITALIAN                  =0x01,    // Italian
 SUBLANG_ITALIAN_SWISS            =0x02    // Italian (Swiss)
}
enum {
 SUBLANG_KOREAN                   =0x01,   // Korean (Extended Wansung)
 SUBLANG_KOREAN_JOHAB             =0x02   // Korean (Johab)
}
enum {
 SUBLANG_NORWEGIAN_BOKMAL         =0x01,    // Norwegian (Bokmal)
 SUBLANG_NORWEGIAN_NYNORSK        =0x02    // Norwegian (Nynorsk)
}
enum {
 SUBLANG_PORTUGUESE               =0x02,    // Portuguese
 SUBLANG_PORTUGUESE_BRAZILIAN     =0x01    // Portuguese (Brazilian)
}
enum {
 SUBLANG_SERBIAN_LATIN            =0x02,    // Serbian (Latin)
 SUBLANG_SERBIAN_CYRILLIC         =0x03    // Serbian (Cyrillic)
}
enum {
 SUBLANG_SPANISH                  =0x01,    // Spanish (Castilian)
 SUBLANG_SPANISH_MEXICAN          =0x02,    // Spanish (Mexican)
 SUBLANG_SPANISH_MODERN           =0x03,    // Spanish (Modern)
 SUBLANG_SPANISH_GUATEMALA        =0x04,    // Spanish (Guatemala)
 SUBLANG_SPANISH_COSTA_RICA       =0x05,    // Spanish (Costa Rica)
 SUBLANG_SPANISH_PANAMA           =0x06,    // Spanish (Panama)
 SUBLANG_SPANISH_DOMINICAN_REPUBLIC =0x07,  // Spanish (Dominican Republic)
 SUBLANG_SPANISH_VENEZUELA        =0x08,    // Spanish (Venezuela)
 SUBLANG_SPANISH_COLOMBIA         =0x09,    // Spanish (Colombia)
 SUBLANG_SPANISH_PERU             =0x0a,    // Spanish (Peru)
 SUBLANG_SPANISH_ARGENTINA        =0x0b,    // Spanish (Argentina)
 SUBLANG_SPANISH_ECUADOR          =0x0c,    // Spanish (Ecuador)
 SUBLANG_SPANISH_CHILE            =0x0d,    // Spanish (Chile)
 SUBLANG_SPANISH_URUGUAY          =0x0e,    // Spanish (Uruguay)
 SUBLANG_SPANISH_PARAGUAY         =0x0f,    // Spanish (Paraguay)
 SUBLANG_SPANISH_BOLIVIA          =0x10,    // Spanish (Bolivia)
 SUBLANG_SPANISH_EL_SALVADOR      =0x11,    // Spanish (El Salvador)
 SUBLANG_SPANISH_HONDURAS         =0x12,    // Spanish (Honduras)
 SUBLANG_SPANISH_NICARAGUA        =0x13,    // Spanish (Nicaragua)
 SUBLANG_SPANISH_PUERTO_RICO      =0x14    // Spanish (Puerto Rico)
}
enum {
 SUBLANG_SWEDISH                  =0x01,    // Swedish
 SUBLANG_SWEDISH_FINLAND          =0x02    // Swedish (Finland)
}

//
//  Sorting IDs.
//
enum {
 SORT_DEFAULT                     =0x0,     // sorting default
}
enum {
 SORT_JAPANESE_XJIS               =0x0,     // Japanese XJIS order
 SORT_JAPANESE_UNICODE            =0x1,     // Japanese Unicode order
}
enum {
 SORT_CHINESE_BIG5                =0x0,     // Chinese BIG5 order
 SORT_CHINESE_PRCP                =0x0,     // PRC Chinese Phonetic order
 SORT_CHINESE_UNICODE             =0x1,     // Chinese Unicode order
 SORT_CHINESE_PRC                 =0x2,     // PRC Chinese Stroke Count order
}
enum {
 SORT_KOREAN_KSC                  =0x0,     // Korean KSC order
 SORT_KOREAN_UNICODE              =0x1,     // Korean Unicode order
}
enum {
 SORT_GERMAN_PHONE_BOOK           =0x1,     // German Phone Book order
}

//
//  A language ID is a 16 bit value which is the combination of a
//  primary language ID and a secondary language ID.  The bits are
//  allocated as follows:
//
//       +-----------------------+-------------------------+
//       |     Sublanguage ID    |   Primary Language ID   |
//       +-----------------------+-------------------------+
//        15                   10 9                       0   bit
//
//
//  Language ID creation/extraction macros:
//
//    MAKELANGID    - construct language id from a primary language id and
//                    a sublanguage id.
//    PRIMARYLANGID - extract primary language id from a language id.
//    SUBLANGID     - extract sublanguage id from a language id.
//

//#define MAKELANGID(p, s)       ((((WORD  )(s)) << 10) | (WORD  )(p))
//#define PRIMARYLANGID(lgid)    ((WORD  )(lgid) & 0x3ff)
//#define SUBLANGID(lgid)        ((WORD  )(lgid) >> 10)


//
//  A locale ID is a 32 bit value which is the combination of a
//  language ID, a sort ID, and a reserved area.  The bits are
//  allocated as follows:
//
//       +-------------+---------+-------------------------+
//       |   Reserved  | Sort ID |      Language ID        |
//       +-------------+---------+-------------------------+
//        31         20 19     16 15                      0   bit
//
//
//  Locale ID creation/extraction macros:
//
//    MAKELCID       - construct locale id from a language id and a sort id.
//    LANGIDFROMLCID - extract language id from a locale id.
//    SORTIDFROMLCID - extract sort id from a locale id.
//
/*
#define NLS_VALID_LOCALE_MASK  0x000fffff

#define MAKELCID(lgid, srtid)  ((DWORD)((((DWORD)((WORD  )(srtid))) << 16) |  \
                                         ((DWORD)((WORD  )(lgid)))))
#define LANGIDFROMLCID(lcid)   ((WORD  )(lcid))
#define SORTIDFROMLCID(lcid)   ((WORD  )((((DWORD)(lcid)) & NLS_VALID_LOCALE_MASK) >> 16))
*/

//
//  Default System and User IDs for language and locale.
//
/*
#define LANG_SYSTEM_DEFAULT    (MAKELANGID(LANG_NEUTRAL, SUBLANG_SYS_DEFAULT))
#define LANG_USER_DEFAULT      (MAKELANGID(LANG_NEUTRAL, SUBLANG_DEFAULT))

#define LOCALE_SYSTEM_DEFAULT  (MAKELCID(LANG_SYSTEM_DEFAULT, SORT_DEFAULT))
#define LOCALE_USER_DEFAULT    (MAKELCID(LANG_USER_DEFAULT, SORT_DEFAULT))

#define LOCALE_NEUTRAL                                                        \
          (MAKELCID(MAKELANGID(LANG_NEUTRAL, SUBLANG_NEUTRAL), SORT_DEFAULT))

*/
// begin_ntminiport begin_ntndis begin_ntminitape

//
// Macros used to eliminate compiler warning generated when formal
// parameters or local variables are not declared.
//
// Use DBG_UNREFERENCED_PARAMETER() when a parameter is not yet
// referenced but will be once the module is completely developed.
//
// Use DBG_UNREFERENCED_LOCAL_VARIABLE() when a local variable is not yet
// referenced but will be once the module is completely developed.
//
// Use UNREFERENCED_PARAMETER() if a parameter will never be referenced.
//
// DBG_UNREFERENCED_PARAMETER and DBG_UNREFERENCED_LOCAL_VARIABLE will
// eventually be made into a null macro to help determine whether there
// is unfinished work.
//

/*

#if ! (defined(lint) || defined(_lint))
#define UNREFERENCED_PARAMETER(P)          (P)
#define DBG_UNREFERENCED_PARAMETER(P)      (P)
#define DBG_UNREFERENCED_LOCAL_VARIABLE(V) (V)

#else // lint or _lint

// Note: lint -e530 says don't complain about uninitialized variables for
// this.  line +e530 turns that checking back on.  Error 527 has to do with
// unreachable code.
#define UNREFERENCED_PARAMETER(P)          \
    \
    { \
        (P) = (P); \
    } \
#define DBG_UNREFERENCED_PARAMETER(P)      \
    \
    { \
        (P) = (P); \
    } \
#define DBG_UNREFERENCED_LOCAL_VARIABLE(V) \
    \
    { \
        (V) = (V); \
    } \

#endif // lint or _lint

*/

enum : DWORD {
 STATUS_WAIT_0                    =((DWORD   )0x00000000),
 STATUS_ABANDONED_WAIT_0          =((DWORD   )0x00000080),    
 STATUS_USER_APC                  =((DWORD   )0x000000C0),    
 STATUS_TIMEOUT                   =((DWORD   )0x00000102),    
 STATUS_PENDING                   =((DWORD   )0x00000103),    
 STATUS_SEGMENT_NOTIFICATION      =((DWORD   )0x40000005),    
 STATUS_GUARD_PAGE_VIOLATION      =((DWORD   )0x80000001),    
 STATUS_DATATYPE_MISALIGNMENT     =((DWORD   )0x80000002),    
 STATUS_BREAKPOINT                =((DWORD   )0x80000003),    
 STATUS_SINGLE_STEP               =((DWORD   )0x80000004),    
 STATUS_ACCESS_VIOLATION          =((DWORD   )0xC0000005),    
 STATUS_IN_PAGE_ERROR             =((DWORD   )0xC0000006),    
 STATUS_INVALID_HANDLE            =((DWORD   )0xC0000008),    
 STATUS_NO_MEMORY                 =((DWORD   )0xC0000017),    
 STATUS_ILLEGAL_INSTRUCTION       =((DWORD   )0xC000001D),    
 STATUS_NONCONTINUABLE_EXCEPTION  =((DWORD   )0xC0000025),    
 STATUS_INVALID_DISPOSITION       =((DWORD   )0xC0000026),    
 STATUS_ARRAY_BOUNDS_EXCEEDED     =((DWORD   )0xC000008C),    
 STATUS_FLOAT_DENORMAL_OPERAND    =((DWORD   )0xC000008D),    
 STATUS_FLOAT_DIVIDE_BY_ZERO      =((DWORD   )0xC000008E),    
 STATUS_FLOAT_INEXACT_RESULT      =((DWORD   )0xC000008F),    
 STATUS_FLOAT_INVALID_OPERATION   =((DWORD   )0xC0000090),    
 STATUS_FLOAT_OVERFLOW            =((DWORD   )0xC0000091),    
 STATUS_FLOAT_STACK_CHECK         =((DWORD   )0xC0000092),    
 STATUS_FLOAT_UNDERFLOW           =((DWORD   )0xC0000093),    
 STATUS_INTEGER_DIVIDE_BY_ZERO    =((DWORD   )0xC0000094),    
 STATUS_INTEGER_OVERFLOW          =((DWORD   )0xC0000095),    
 STATUS_PRIVILEGED_INSTRUCTION    =((DWORD   )0xC0000096),    
 STATUS_STACK_OVERFLOW            =((DWORD   )0xC00000FD),    
 STATUS_CONTROL_C_EXIT            =((DWORD   )0xC000013A)
}

enum {MAXIMUM_WAIT_OBJECTS =64}     // Maximum number of wait objects

//#define MAXIMUM_SUSPEND_COUNT MAXCHAR // Maximum times thread can be suspended
alias DWORD KSPIN_LOCK;  


//TEB * NtCurrentTeb(void);

//
// Define function to return the current Thread Environment Block
//

enum { EXCEPTION_NONCONTINUABLE = 0x1 }    // Noncontinuable exception
enum { EXCEPTION_MAXIMUM_PARAMETERS = 15 } // maximum number of exception parameters

//
// Exception record definition.
//

struct EXCEPTION_RECORD {
    /*lint -e18 */  // Don't complain about different definitions
    DWORD    ExceptionCode;
    /*lint +e18 */  // Resume checking for different definitions
    DWORD ExceptionFlags;
    EXCEPTION_RECORD * ExceptionRecord;
    PVOID ExceptionAddress;
    DWORD NumberParameters;
    DWORD ExceptionInformation[EXCEPTION_MAXIMUM_PARAMETERS];
}

alias EXCEPTION_RECORD * PEXCEPTION_RECORD;

//
// Typedef for pointer returned by exception_info()
//
/*
struct EXCEPTION_POINTERS {
    PEXCEPTION_RECORD ExceptionRecord;
    PCONTEXT ContextRecord;
} EXCEPTION_POINTERS, *PEXCEPTION_POINTERS;
*/
enum {
 PROCESS_TERMINATE         =(0x0001),
 PROCESS_CREATE_THREAD     =(0x0002),  
 PROCESS_VM_OPERATION      =(0x0008),  
 PROCESS_VM_READ           =(0x0010),  
 PROCESS_VM_WRITE          =(0x0020),  
 PROCESS_DUP_HANDLE        =(0x0040),  
 PROCESS_CREATE_PROCESS    =(0x0080),  
 PROCESS_SET_QUOTA         =(0x0100),  
 PROCESS_SET_INFORMATION   =(0x0200),  
 PROCESS_QUERY_INFORMATION =(0x0400),  
 PROCESS_ALL_ACCESS        =(STANDARD_RIGHTS_REQUIRED | SYNCHRONIZE | 0xFFF)
}

enum { MAXIMUM_PROCESSORS = 32 }

enum {
 THREAD_TERMINATE               =(0x0001),
 THREAD_SUSPEND_RESUME          =(0x0002),
 THREAD_GET_CONTEXT             =(0x0008),
 THREAD_SET_CONTEXT             =(0x0010),
 THREAD_SET_INFORMATION         =(0x0020),
 THREAD_QUERY_INFORMATION       =(0x0040), 
 THREAD_SET_THREAD_TOKEN        =(0x0080),
 THREAD_IMPERSONATE             =(0x0100),
 THREAD_DIRECT_IMPERSONATION    =(0x0200),
 THREAD_ALL_ACCESS         =(STANDARD_RIGHTS_REQUIRED | SYNCHRONIZE | 0x3FF)
}

enum { TLS_MINIMUM_AVAILABLE = 64 }
/*
struct NT_TIB {
    EXCEPTION_REGISTRATION_RECORD *ExceptionList;
    PVOID StackBase;
    PVOID StackLimit;
    PVOID SubSystemTib;
    union {
        PVOID FiberData;
        DWORD Version;
    };
    PVOID ArbitraryUserPointer;
    NT_TIB * Self;
} 
alias NT_TIB *PNT_TIB;
*/

version ( STANDALONE ) {

enum {
THREAD_BASE_PRIORITY_LOWRT  =15,  // value that gets a thread to LowRealtime-1
THREAD_BASE_PRIORITY_MAX    =2 ,  // maximum thread base priority boost
THREAD_BASE_PRIORITY_MIN    =-2,  // minimum thread base priority boost
THREAD_BASE_PRIORITY_IDLE   =-15  // value that gets a thread to idle
}

}

struct QUOTA_LIMITS {
    DWORD PagedPoolLimit;
    DWORD NonPagedPoolLimit;
    DWORD MinimumWorkingSetSize;
    DWORD MaximumWorkingSetSize;
    DWORD PagefileLimit;
    LARGE_INTEGER TimeLimit;
}
alias QUOTA_LIMITS * PQUOTA_LIMITS;

enum {
EVENT_MODIFY_STATE      =0x0002,
EVENT_ALL_ACCESS =(STANDARD_RIGHTS_REQUIRED|SYNCHRONIZE|0x3)
}
enum {
MUTANT_QUERY_STATE      =0x0001,
MUTANT_ALL_ACCESS =(STANDARD_RIGHTS_REQUIRED|SYNCHRONIZE|MUTANT_QUERY_STATE)
}
enum {
SEMAPHORE_MODIFY_STATE      =0x0002,
SEMAPHORE_ALL_ACCESS =(STANDARD_RIGHTS_REQUIRED|SYNCHRONIZE|0x3) 
}

enum {
TIME_ZONE_ID_UNKNOWN  =0,
TIME_ZONE_ID_STANDARD =1,
TIME_ZONE_ID_DAYLIGHT =2
}

enum {
PROCESSOR_INTEL_386     =386,
PROCESSOR_INTEL_486     =486,
PROCESSOR_INTEL_PENTIUM =586,
PROCESSOR_MIPS_R4000    =4000,
PROCESSOR_ALPHA_21064   =21064
}

enum {
PROCESSOR_ARCHITECTURE_INTEL =0,
PROCESSOR_ARCHITECTURE_MIPS  =1,
PROCESSOR_ARCHITECTURE_ALPHA =2,
PROCESSOR_ARCHITECTURE_PPC   =3,
PROCESSOR_ARCHITECTURE_UNKNOWN =0xFFFF
}

enum {
PF_FLOATING_POINT_PRECISION_ERRATA  =0,   
PF_FLOATING_POINT_EMULATED          =1,   
PF_COMPARE_EXCHANGE_DOUBLE          =2,   
PF_MMX_INSTRUCTIONS_AVAILABLE       =3   
}

version( STANDALONE ) {
struct MEMORY_BASIC_INFORMATION {
    PVOID BaseAddress;
    PVOID AllocationBase;
    DWORD AllocationProtect;
    DWORD RegionSize;
    DWORD State;
    DWORD Protect;
    DWORD Type;
} 
alias MEMORY_BASIC_INFORMATION * PMEMORY_BASIC_INFORMATION;

enum {
SECTION_QUERY       =0x0001,
SECTION_MAP_WRITE   =0x0002,
SECTION_MAP_READ    =0x0004,
SECTION_MAP_EXECUTE =0x0008,
SECTION_EXTEND_SIZE =0x0010,

SECTION_ALL_ACCESS =(STANDARD_RIGHTS_REQUIRED|SECTION_QUERY|
                            SECTION_MAP_WRITE |
                            SECTION_MAP_READ |
                            SECTION_MAP_EXECUTE |
                            SECTION_EXTEND_SIZE)
}

} // version( STANDALONE ) 

enum {
PAGE_NOACCESS          =0x01,     
PAGE_READONLY          =0x02,     
PAGE_READWRITE         =0x04,     
PAGE_WRITECOPY         =0x08,     
PAGE_EXECUTE           =0x10,     
PAGE_EXECUTE_READ      =0x20,     
PAGE_EXECUTE_READWRITE =0x40,     
PAGE_EXECUTE_WRITECOPY =0x80,     
PAGE_GUARD            =0x100,     
PAGE_NOCACHE          =0x200     
}

enum {
MEM_COMMIT         =  0x1000,     
MEM_RESERVE        =  0x2000,     
MEM_DECOMMIT       =  0x4000,     
MEM_RELEASE        =  0x8000,     
MEM_FREE           = 0x10000,     
MEM_PRIVATE        = 0x20000,     
MEM_MAPPED         = 0x40000,     
MEM_RESET          = 0x80000,     
MEM_TOP_DOWN       =0x100000     
}

enum {
SEC_FILE           =0x800000,     
SEC_IMAGE         =0x1000000,     
SEC_RESERVE       =0x4000000,     
SEC_COMMIT       = 0x8000000,     
SEC_NOCACHE      =0x10000000     
}

enum {
MEM_IMAGE         =SEC_IMAGE     
}

//
// Define access rights to files and directories
//

//
// The FILE_READ_DATA and FILE_WRITE_DATA constants are also defined in
// devioctl.h as FILE_READ_ACCESS and FILE_WRITE_ACCESS. The values for these
// constants *MUST* always be in sync.
// The values are redefined in devioctl.h because they must be available to
// both DOS and NT.
//

enum {
FILE_READ_DATA            =( 0x0001 ),    // file & pipe
FILE_LIST_DIRECTORY       =( 0x0001 ),    // directory

FILE_WRITE_DATA           =( 0x0002 ),    // file & pipe
FILE_ADD_FILE             =( 0x0002 ),    // directory

FILE_APPEND_DATA          =( 0x0004 ),    // file
FILE_ADD_SUBDIRECTORY     =( 0x0004 ),    // directory
FILE_CREATE_PIPE_INSTANCE =( 0x0004 ),    // named pipe

FILE_READ_EA              =( 0x0008 ),    // file & directory

FILE_WRITE_EA             =( 0x0010 ),    // file & directory

FILE_EXECUTE              =( 0x0020 ),    // file
FILE_TRAVERSE             =( 0x0020 ),    // directory

FILE_DELETE_CHILD         =( 0x0040 ),    // directory

FILE_READ_ATTRIBUTES      =( 0x0080 ),    // all

FILE_WRITE_ATTRIBUTES     =( 0x0100 )    // all
}

version( STANDALONE ) {

enum : DWORD {

FILE_ALL_ACCESS =(STANDARD_RIGHTS_REQUIRED | SYNCHRONIZE | 0x1FF),

FILE_GENERIC_READ         =(STANDARD_RIGHTS_READ|FILE_READ_DATA |FILE_READ_ATTRIBUTES|FILE_READ_EA|SYNCHRONIZE),

FILE_GENERIC_WRITE        =(STANDARD_RIGHTS_WRITE|FILE_WRITE_DATA|FILE_WRITE_ATTRIBUTES|FILE_WRITE_EA|FILE_APPEND_DATA|SYNCHRONIZE),

FILE_GENERIC_EXECUTE      =(STANDARD_RIGHTS_EXECUTE|FILE_READ_ATTRIBUTES|FILE_EXECUTE|SYNCHRONIZE),

FILE_SHARE_READ                 =0x00000001  ,
FILE_SHARE_WRITE                =0x00000002,  
FILE_SHARE_DELETE               =0x00000004,  
FILE_ATTRIBUTE_READONLY         =0x00000001,  
FILE_ATTRIBUTE_HIDDEN           =0x00000002,  
FILE_ATTRIBUTE_SYSTEM           =0x00000004,  
FILE_ATTRIBUTE_DIRECTORY        =0x00000010,  
FILE_ATTRIBUTE_ARCHIVE          =0x00000020,  
FILE_ATTRIBUTE_NORMAL           =0x00000080,  
FILE_ATTRIBUTE_TEMPORARY        =0x00000100,  
FILE_ATTRIBUTE_COMPRESSED       =0x00000800 , 
FILE_ATTRIBUTE_OFFLINE          =0x00001000,  
FILE_NOTIFY_CHANGE_FILE_NAME    =0x00000001,   
FILE_NOTIFY_CHANGE_DIR_NAME     =0x00000002,   
FILE_NOTIFY_CHANGE_ATTRIBUTES   =0x00000004,   
FILE_NOTIFY_CHANGE_SIZE         =0x00000008,   
FILE_NOTIFY_CHANGE_LAST_WRITE   =0x00000010,   
FILE_NOTIFY_CHANGE_LAST_ACCESS  =0x00000020,   
FILE_NOTIFY_CHANGE_CREATION     =0x00000040,   
FILE_NOTIFY_CHANGE_SECURITY     =0x00000100,   
FILE_ACTION_ADDED               =0x00000001,   
FILE_ACTION_REMOVED             =0x00000002,   
FILE_ACTION_MODIFIED            =0x00000003,   
FILE_ACTION_RENAMED_OLD_NAME    =0x00000004,   
FILE_ACTION_RENAMED_NEW_NAME    =0x00000005,   
MAILSLOT_NO_MESSAGE             =((DWORD)-1), 
MAILSLOT_WAIT_FOREVER           =((DWORD)-1), 
FILE_CASE_SENSITIVE_SEARCH      =0x00000001 , 
FILE_CASE_PRESERVED_NAMES       =0x00000002,  
FILE_UNICODE_ON_DISK            =0x00000004,  
FILE_PERSISTENT_ACLS            =0x00000008,  
FILE_FILE_COMPRESSION           =0x00000010,  
FILE_VOLUME_IS_COMPRESSED       =0x00008000,  
}

} // version( STANDALONE )

//
// Define the file notification information structure
//

struct FILE_NOTIFY_INFORMATION {
    DWORD NextEntryOffset;
    DWORD Action;
    DWORD FileNameLength;
    WCHAR FileName[1];
} 
alias FILE_NOTIFY_INFORMATION * PFILE_NOTIFY_INFORMATION;

enum : uint {
IO_COMPLETION_MODIFY_STATE  =0x0002  ,
IO_COMPLETION_ALL_ACCESS =(STANDARD_RIGHTS_REQUIRED|SYNCHRONIZE|0x3) ,
DUPLICATE_CLOSE_SOURCE      =0x00000001  ,
DUPLICATE_SAME_ACCESS       =0x00000002  
}
alias PVOID PACCESS_TOKEN;            
alias PVOID PSECURITY_DESCRIPTOR;     
alias PVOID PSID;     
////////////////////////////////////////////////////////////////////////
//                                                                    //
//                             ACCESS MASK                            //
//                                                                    //
////////////////////////////////////////////////////////////////////////

//
//  Define the access mask as a longword sized structure divided up as
//  follows:
//
//       3 3 2 2 2 2 2 2 2 2 2 2 1 1 1 1 1 1 1 1 1 1
//       1 0 9 8 7 6 5 4 3 2 1 0 9 8 7 6 5 4 3 2 1 0 9 8 7 6 5 4 3 2 1 0
//      +---------------+---------------+-------------------------------+
//      |G|G|G|G|Res'd|A| StandardRights|         SpecificRights        |
//      |R|W|E|A|     |S|               |                               |
//      +-+-------------+---------------+-------------------------------+
//
//      typedef struct _ACCESS_MASK {
//          WORD   SpecificRights;
//          BYTE  StandardRights;
//          BYTE  AccessSystemAcl : 1;
//          BYTE  Reserved : 3;
//          BYTE  GenericAll : 1;
//          BYTE  GenericExecute : 1;
//          BYTE  GenericWrite : 1;
//          BYTE  GenericRead : 1;
//      } ACCESS_MASK;
//      typedef ACCESS_MASK *PACCESS_MASK;
//
//  but to make life simple for programmer's we'll allow them to specify
//  a desired access mask by simply OR'ing together mulitple single rights
//  and treat an access mask as a DWORD.  For example
//
//      DesiredAccess = DELETE | READ_CONTROL
//
//  So we'll declare ACCESS_MASK as DWORD
//

// begin_ntddk begin_nthal begin_ntifs
alias DWORD ACCESS_MASK;
alias ACCESS_MASK * PACCESS_MASK;

////////////////////////////////////////////////////////////////////////
//                                                                    //
//                             ACCESS TYPES                           //
//                                                                    //
////////////////////////////////////////////////////////////////////////

//
//  Define the generic mapping array.  This is used to denote the
//  mapping of each generic access right to a specific access mask.
//

struct GENERIC_MAPPING {
    ACCESS_MASK GenericRead;
    ACCESS_MASK GenericWrite;
    ACCESS_MASK GenericExecute;
    ACCESS_MASK GenericAll;
}
alias GENERIC_MAPPING * PGENERIC_MAPPING;

////////////////////////////////////////////////////////////////////////
//                                                                    //
//                        LUID_AND_ATTRIBUTES                         //
//                                                                    //
////////////////////////////////////////////////////////////////////////
//
//


//#include <pshpack4.h>

struct LUID_AND_ATTRIBUTES {
    LUID Luid;
    DWORD Attributes;
} 
alias LUID_AND_ATTRIBUTES * PLUID_AND_ATTRIBUTES;
alias LUID_AND_ATTRIBUTES LUID_AND_ATTRIBUTES_ARRAY[ANYSIZE_ARRAY];
alias LUID_AND_ATTRIBUTES_ARRAY * PLUID_AND_ATTRIBUTES_ARRAY;

//#include <poppack.h>


////////////////////////////////////////////////////////////////////////
//                                                                    //
//              Security Id     (SID)                                 //
//                                                                    //
////////////////////////////////////////////////////////////////////////
//
//
// Pictorially the structure of an SID is as follows:
//
//         1   1   1   1   1   1
//         5   4   3   2   1   0   9   8   7   6   5   4   3   2   1   0
//      +---------------------------------------------------------------+
//      |      SubAuthorityCount        |Reserved1 (SBZ)|   Revision    |
//      +---------------------------------------------------------------+
//      |                   IdentifierAuthority[0]                      |
//      +---------------------------------------------------------------+
//      |                   IdentifierAuthority[1]                      |
//      +---------------------------------------------------------------+
//      |                   IdentifierAuthority[2]                      |
//      +---------------------------------------------------------------+
//      |                                                               |
//      +- -  -  -  -  -  -  -  SubAuthority[]  -  -  -  -  -  -  -  - -+
//      |                                                               |
//      +---------------------------------------------------------------+
//
//


// begin_ntifs

struct SID_IDENTIFIER_AUTHORITY {
    BYTE  Value[6];
} 
alias SID_IDENTIFIER_AUTHORITY *PSID_IDENTIFIER_AUTHORITY;


struct SID {
   BYTE  Revision;
   BYTE  SubAuthorityCount;
   SID_IDENTIFIER_AUTHORITY IdentifierAuthority;
//#ifdef MIDL_PASS
//   [size_is(SubAuthorityCount)] DWORD SubAuthority[*];
//#else // MIDL_PASS
   DWORD SubAuthority[ANYSIZE_ARRAY];
//#endif // MIDL_PASS
} 
alias SID * PISID;

enum {
SID_REVISION                     =(1),    // Current revision level
SID_MAX_SUB_AUTHORITIES          =(15),
SID_RECOMMENDED_SUB_AUTHORITIES  =(1)    // Will change to around 6
}                                                // in a future release.

enum SID_NAME_USE {
    SidTypeUser = 1,
    SidTypeGroup,
    SidTypeDomain,
    SidTypeAlias,
    SidTypeWellKnownGroup,
    SidTypeDeletedAccount,
    SidTypeInvalid,
    SidTypeUnknown
} 
alias SID_NAME_USE * PSID_NAME_USE;

struct SID_AND_ATTRIBUTES {
    PSID Sid;
    DWORD Attributes;
} 
alias SID_AND_ATTRIBUTES * PSID_AND_ATTRIBUTES;

alias SID_AND_ATTRIBUTES SID_AND_ATTRIBUTES_ARRAY[ANYSIZE_ARRAY];
alias SID_AND_ATTRIBUTES_ARRAY *PSID_AND_ATTRIBUTES_ARRAY;


/////////////////////////////////////////////////////////////////////////////
//                                                                         //
// Universal well-known SIDs                                               //
//                                                                         //
//     Null SID                     S-1-0-0                                //
//     World                        S-1-1-0                                //
//     Local                        S-1-2-0                                //
//     Creator Owner ID             S-1-3-0                                //
//     Creator Group ID             S-1-3-1                                //
//     Creator Owner Server ID      S-1-3-2                                //
//     Creator Group Server ID      S-1-3-3                                //
//                                                                         //
//     (Non-unique IDs)             S-1-4                                  //
//                                                                         //
/////////////////////////////////////////////////////////////////////////////

/*
#define SECURITY_NULL_SID_AUTHORITY       {0,0,0,0,0,0}
#define SECURITY_WORLD_SID_AUTHORITY      {0,0,0,0,0,1}
#define SECURITY_LOCAL_SID_AUTHORITY      {0,0,0,0,0,2}
#define SECURITY_CREATOR_SID_AUTHORITY    {0,0,0,0,0,3}
#define SECURITY_NON_UNIQUE_AUTHORITY     {0,0,0,0,0,4}
*/
enum {
SECURITY_NULL_RID                 =(0x00000000L),
SECURITY_WORLD_RID                =(0x00000000L),
SECURITY_LOCAL_RID                =(0X00000000L),

SECURITY_CREATOR_OWNER_RID        =(0x00000000L),
SECURITY_CREATOR_GROUP_RID        =(0x00000001L),

SECURITY_CREATOR_OWNER_SERVER_RID =(0x00000002L),
SECURITY_CREATOR_GROUP_SERVER_RID =(0x00000003L)
}

/////////////////////////////////////////////////////////////////////////////
//                                                                         //
// NT well-known SIDs                                                      //
//                                                                         //
//     NT Authority          S-1-5                                         //
//     Dialup                S-1-5-1                                       //
//                                                                         //
//     Network               S-1-5-2                                       //
//     Batch                 S-1-5-3                                       //
//     Interactive           S-1-5-4                                       //
//     Service               S-1-5-6                                       //
//     AnonymousLogon        S-1-5-7       (aka null logon session)        //
//     Proxy                 S-1-5-8                                       //
//     ServerLogon           S-1-5-8       (aka domain controller account) //
//                                                                         //
//     (Logon IDs)           S-1-5-5-X-Y                                   //
//                                                                         //
//     (NT non-unique IDs)   S-1-5-0x15-...                                //
//                                                                         //
//     (Built-in domain)     s-1-5-0x20                                    //
//                                                                         //
/////////////////////////////////////////////////////////////////////////////


//#define SECURITY_NT_AUTHORITY           {0,0,0,0,0,5}   // ntifs

enum {
SECURITY_DIALUP_RID             =(0x00000001L),
SECURITY_NETWORK_RID            =(0x00000002L),
SECURITY_BATCH_RID              =(0x00000003L),
SECURITY_INTERACTIVE_RID        =(0x00000004L),
SECURITY_SERVICE_RID            =(0x00000006L),
SECURITY_ANONYMOUS_LOGON_RID    =(0x00000007L),
SECURITY_PROXY_RID              =(0x00000008L),
SECURITY_SERVER_LOGON_RID       =(0x00000009L),

SECURITY_LOGON_IDS_RID          =(0x00000005L),
SECURITY_LOGON_IDS_RID_COUNT    =(3L),

SECURITY_LOCAL_SYSTEM_RID       =(0x00000012L),

SECURITY_NT_NON_UNIQUE          =(0x00000015L),

SECURITY_BUILTIN_DOMAIN_RID     =(0x00000020L)
}

/////////////////////////////////////////////////////////////////////////////
//                                                                         //
// well-known domain relative sub-authority values (RIDs)...               //
//                                                                         //
/////////////////////////////////////////////////////////////////////////////

// Well-known users ...
enum {
DOMAIN_USER_RID_ADMIN          =(0x000001F4L),
DOMAIN_USER_RID_GUEST          =(0x000001F5L)
}


enum {
// well-known groups ...
DOMAIN_GROUP_RID_ADMINS        =(0x00000200L),
DOMAIN_GROUP_RID_USERS         =(0x00000201L),
DOMAIN_GROUP_RID_GUESTS        =(0x00000202L)
}



enum {
// well-known aliases ...
DOMAIN_ALIAS_RID_ADMINS        =(0x00000220L),
DOMAIN_ALIAS_RID_USERS         =(0x00000221L),
DOMAIN_ALIAS_RID_GUESTS        =(0x00000222L),
DOMAIN_ALIAS_RID_POWER_USERS   =(0x00000223L),

DOMAIN_ALIAS_RID_ACCOUNT_OPS   =(0x00000224L),
DOMAIN_ALIAS_RID_SYSTEM_OPS    =(0x00000225L),
DOMAIN_ALIAS_RID_PRINT_OPS     =(0x00000226L),
DOMAIN_ALIAS_RID_BACKUP_OPS    =(0x00000227L),

DOMAIN_ALIAS_RID_REPLICATOR    =(0x00000228L)
}

//
// Allocate the System Luid.  The first 1000 LUIDs are reserved.
// Use #999 here (0x3E7 = 999)
//
//#define SYSTEM_LUID                     { 0x3E7, 0x0 }


////////////////////////////////////////////////////////////////////////
//                                                                    //
//                          User and Group related SID attributes     //
//                                                                    //
////////////////////////////////////////////////////////////////////////

enum : uint {
//
// Group attributes
//
SE_GROUP_MANDATORY              =(0x00000001L),
SE_GROUP_ENABLED_BY_DEFAULT     =(0x00000002L),
SE_GROUP_ENABLED                =(0x00000004L),
SE_GROUP_OWNER                  =(0x00000008L),
SE_GROUP_LOGON_ID               =(0xC0000000L)
}



//
// User attributes
//

// (None yet defined.)


////////////////////////////////////////////////////////////////////////
//                                                                    //
//                         ACL  and  ACE                              //
//                                                                    //
////////////////////////////////////////////////////////////////////////

//
//  Define an ACL and the ACE format.  The structure of an ACL header
//  followed by one or more ACEs.  Pictorally the structure of an ACL header
//  is as follows:
//
//       3 3 2 2 2 2 2 2 2 2 2 2 1 1 1 1 1 1 1 1 1 1
//       1 0 9 8 7 6 5 4 3 2 1 0 9 8 7 6 5 4 3 2 1 0 9 8 7 6 5 4 3 2 1 0
//      +-------------------------------+---------------+---------------+
//      |            AclSize            |      Sbz1     |  AclRevision  |
//      +-------------------------------+---------------+---------------+
//      |              Sbz2             |           AceCount            |
//      +-------------------------------+-------------------------------+
//
//  The current AclRevision is defined to be ACL_REVISION.
//
//  AclSize is the size, in bytes, allocated for the ACL.  This includes
//  the ACL header, ACES, and remaining free space in the buffer.
//
//  AceCount is the number of ACES in the ACL.
//

// begin_ntddk begin_ntifs
// This is the *current* ACL revision

enum { ACL_REVISION     = (2) }

// This is the history of ACL revisions.  Add a new one whenever
// ACL_REVISION is updated
enum {
ACL_REVISION1   =(1),
ACL_REVISION2   =(2),
ACL_REVISION3   =(3)
}

struct ACL {
    BYTE  AclRevision;
    BYTE  Sbz1;
    WORD   AclSize;
    WORD   AceCount;
    WORD   Sbz2;
}
alias ACL * PACL;

//
//  The structure of an ACE is a common ace header followed by ace type
//  specific data.  Pictorally the structure of the common ace header is
//  as follows:
//
//       3 3 2 2 2 2 2 2 2 2 2 2 1 1 1 1 1 1 1 1 1 1
//       1 0 9 8 7 6 5 4 3 2 1 0 9 8 7 6 5 4 3 2 1 0 9 8 7 6 5 4 3 2 1 0
//      +---------------+-------+-------+---------------+---------------+
//      |            AceSize            |    AceFlags   |     AceType   |
//      +---------------+-------+-------+---------------+---------------+
//
//  AceType denotes the type of the ace, there are some predefined ace
//  types
//
//  AceSize is the size, in bytes, of ace.
//
//  AceFlags are the Ace flags for audit and inheritance, defined shortly.

struct ACE_HEADER {
    BYTE  AceType;
    BYTE  AceFlags;
    WORD   AceSize;
}
alias ACE_HEADER * PACE_HEADER;

//
//  The following are the predefined ace types that go into the AceType
//  field of an Ace header.
//
enum {
ACCESS_ALLOWED_ACE_TYPE          =(0x0),
ACCESS_DENIED_ACE_TYPE           =(0x1),
SYSTEM_AUDIT_ACE_TYPE            =(0x2),
SYSTEM_ALARM_ACE_TYPE            =(0x3)
}

//
//  The following are the inherit flags that go into the AceFlags field
//  of an Ace header.
//
enum {
OBJECT_INHERIT_ACE                =(0x1),
CONTAINER_INHERIT_ACE             =(0x2),
NO_PROPAGATE_INHERIT_ACE          =(0x4),
INHERIT_ONLY_ACE                  =(0x8),
VALID_INHERIT_FLAGS               =(0xF)
}

//  The following are the currently defined ACE flags that go into the
//  AceFlags field of an ACE header.  Each ACE type has its own set of
//  AceFlags.
//
//  SUCCESSFUL_ACCESS_ACE_FLAG - used only with system audit and alarm ACE
//  types to indicate that a message is generated for successful accesses.
//
//  FAILED_ACCESS_ACE_FLAG - used only with system audit and alarm ACE types
//  to indicate that a message is generated for failed accesses.
//

//
//  SYSTEM_AUDIT and SYSTEM_ALARM AceFlags
//
//  These control the signaling of audit and alarms for success or failure.
//
enum {
SUCCESSFUL_ACCESS_ACE_FLAG       =(0x40),
FAILED_ACCESS_ACE_FLAG           =(0x80)
}


//
//  We'll define the structure of the predefined ACE types.  Pictorally
//  the structure of the predefined ACE's is as follows:
//
//       3 3 2 2 2 2 2 2 2 2 2 2 1 1 1 1 1 1 1 1 1 1
//       1 0 9 8 7 6 5 4 3 2 1 0 9 8 7 6 5 4 3 2 1 0 9 8 7 6 5 4 3 2 1 0
//      +---------------+-------+-------+---------------+---------------+
//      |    AceFlags   | Resd  |Inherit|    AceSize    |     AceType   |
//      +---------------+-------+-------+---------------+---------------+
//      |                              Mask                             |
//      +---------------------------------------------------------------+
//      |                                                               |
//      +                                                               +
//      |                                                               |
//      +                              Sid                              +
//      |                                                               |
//      +                                                               +
//      |                                                               |
//      +---------------------------------------------------------------+
//
//  Mask is the access mask associated with the ACE.  This is either the
//  access allowed, access denied, audit, or alarm mask.
//
//  Sid is the Sid associated with the ACE.
//

//  The following are the four predefined ACE types.

//  Examine the AceType field in the Header to determine
//  which structure is appropriate to use for casting.


struct ACCESS_ALLOWED_ACE {
    ACE_HEADER Header;
    ACCESS_MASK Mask;
    DWORD SidStart;
}

alias ACCESS_ALLOWED_ACE * PACCESS_ALLOWED_ACE;

struct ACCESS_DENIED_ACE {
    ACE_HEADER Header;
    ACCESS_MASK Mask;
    DWORD SidStart;
}
alias ACCESS_DENIED_ACE * PACCESS_DENIED_ACE;

struct SYSTEM_AUDIT_ACE {
    ACE_HEADER Header;
    ACCESS_MASK Mask;
    DWORD SidStart;
}
alias SYSTEM_AUDIT_ACE * PSYSTEM_AUDIT_ACE;

struct SYSTEM_ALARM_ACE {
    ACE_HEADER Header;
    ACCESS_MASK Mask;
    DWORD SidStart;
}
alias SYSTEM_ALARM_ACE * PSYSTEM_ALARM_ACE;

//
//  The following declarations are used for setting and querying information
//  about and ACL.  First are the various information classes available to
//  the user.
//

enum ACL_INFORMATION_CLASS {
    AclRevisionInformation = 1,
    AclSizeInformation
}

//
//  This record is returned/sent if the user is requesting/setting the
//  AclRevisionInformation
//

struct ACL_REVISION_INFORMATION {
    DWORD AclRevision;
}
alias ACL_REVISION_INFORMATION * PACL_REVISION_INFORMATION;

//
//  This record is returned if the user is requesting AclSizeInformation
//

struct ACL_SIZE_INFORMATION {
    DWORD AceCount;
    DWORD AclBytesInUse;
    DWORD AclBytesFree;
}
alias ACL_SIZE_INFORMATION * PACL_SIZE_INFORMATION;


////////////////////////////////////////////////////////////////////////
//                                                                    //
//                             SECURITY_DESCRIPTOR                    //
//                                                                    //
////////////////////////////////////////////////////////////////////////
//
//  Define the Security Descriptor and related data types.
//  This is an opaque data structure.
//

// begin_ntddk begin_ntifs
//
// Current security descriptor revision value
//
enum {
SECURITY_DESCRIPTOR_REVISION     =(1),
SECURITY_DESCRIPTOR_REVISION1    =(1)
}

//
// Minimum length, in bytes, needed to build a security descriptor
// (NOTE: This must manually be kept consistent with the)
// (sizeof(SECURITY_DESCRIPTOR)                         )
//

enum  {SECURITY_DESCRIPTOR_MIN_LENGTH   = (20)}


alias WORD SECURITY_DESCRIPTOR_CONTROL;
alias WORD * PSECURITY_DESCRIPTOR_CONTROL;
enum {
SE_OWNER_DEFAULTED               =(0x0001),
SE_GROUP_DEFAULTED               =(0x0002),
SE_DACL_PRESENT                  =(0x0004),
SE_DACL_DEFAULTED                =(0x0008),
SE_SACL_PRESENT                  =(0x0010),
SE_SACL_DEFAULTED                =(0x0020),
SE_SELF_RELATIVE                 =(0x8000)
}
//
//  Where:
//
//      SE_OWNER_DEFAULTED - This boolean flag, when set, indicates that the
//          SID pointed to by the Owner field was provided by a
//          defaulting mechanism rather than explicitly provided by the
//          original provider of the security descriptor.  This may
//          affect the treatment of the SID with respect to inheritence
//          of an owner.
//
//      SE_GROUP_DEFAULTED - This boolean flag, when set, indicates that the
//          SID in the Group field was provided by a defaulting mechanism
//          rather than explicitly provided by the original provider of
//          the security descriptor.  This may affect the treatment of
//          the SID with respect to inheritence of a primary group.
//
//      SE_DACL_PRESENT - This boolean flag, when set, indicates that the
//          security descriptor contains a discretionary ACL.  If this
//          flag is set and the Dacl field of the SECURITY_DESCRIPTOR is
//          null, then a null ACL is explicitly being specified.
//
//      SE_DACL_DEFAULTED - This boolean flag, when set, indicates that the
//          ACL pointed to by the Dacl field was provided by a defaulting
//          mechanism rather than explicitly provided by the original
//          provider of the security descriptor.  This may affect the
//          treatment of the ACL with respect to inheritence of an ACL.
//          This flag is ignored if the DaclPresent flag is not set.
//
//      SE_SACL_PRESENT - This boolean flag, when set,  indicates that the
//          security descriptor contains a system ACL pointed to by the
//          Sacl field.  If this flag is set and the Sacl field of the
//          SECURITY_DESCRIPTOR is null, then an empty (but present)
//          ACL is being specified.
//
//      SE_SACL_DEFAULTED - This boolean flag, when set, indicates that the
//          ACL pointed to by the Sacl field was provided by a defaulting
//          mechanism rather than explicitly provided by the original
//          provider of the security descriptor.  This may affect the
//          treatment of the ACL with respect to inheritence of an ACL.
//          This flag is ignored if the SaclPresent flag is not set.
//
//      SE_SELF_RELATIVE - This boolean flag, when set, indicates that the
//          security descriptor is in self-relative form.  In this form,
//          all fields of the security descriptor are contiguous in memory
//          and all pointer fields are expressed as offsets from the
//          beginning of the security descriptor.  This form is useful
//          for treating security descriptors as opaque data structures
//          for transmission in communication protocol or for storage on
//          secondary media.
//
//
//
// Pictorially the structure of a security descriptor is as follows:
//
//       3 3 2 2 2 2 2 2 2 2 2 2 1 1 1 1 1 1 1 1 1 1
//       1 0 9 8 7 6 5 4 3 2 1 0 9 8 7 6 5 4 3 2 1 0 9 8 7 6 5 4 3 2 1 0
//      +---------------------------------------------------------------+
//      |            Control            |Reserved1 (SBZ)|   Revision    |
//      +---------------------------------------------------------------+
//      |                            Owner                              |
//      +---------------------------------------------------------------+
//      |                            Group                              |
//      +---------------------------------------------------------------+
//      |                            Sacl                               |
//      +---------------------------------------------------------------+
//      |                            Dacl                               |
//      +---------------------------------------------------------------+
//
// In general, this data structure should be treated opaquely to ensure future
// compatibility.
//
//

struct SECURITY_DESCRIPTOR {
   BYTE  Revision;
   BYTE  Sbz1;
   SECURITY_DESCRIPTOR_CONTROL Control;
   PSID Owner;
   PSID Group;
   PACL Sacl;
   PACL Dacl;
} 
alias SECURITY_DESCRIPTOR * PISECURITY_DESCRIPTOR;

// Where:
//
//     Revision - Contains the revision level of the security
//         descriptor.  This allows this structure to be passed between
//         systems or stored on disk even though it is expected to
//         change in the future.
//
//     Control - A set of flags which qualify the meaning of the
//         security descriptor or individual fields of the security
//         descriptor.
//
//     Owner - is a pointer to an SID representing an object's owner.
//         If this field is null, then no owner SID is present in the
//         security descriptor.  If the security descriptor is in
//         self-relative form, then this field contains an offset to
//         the SID, rather than a pointer.
//
//     Group - is a pointer to an SID representing an object's primary
//         group.  If this field is null, then no primary group SID is
//         present in the security descriptor.  If the security descriptor
//         is in self-relative form, then this field contains an offset to
//         the SID, rather than a pointer.
//
//     Sacl - is a pointer to a system ACL.  This field value is only
//         valid if the DaclPresent control flag is set.  If the
//         SaclPresent flag is set and this field is null, then a null
//         ACL  is specified.  If the security descriptor is in
//         self-relative form, then this field contains an offset to
//         the ACL, rather than a pointer.
//
//     Dacl - is a pointer to a discretionary ACL.  This field value is
//         only valid if the DaclPresent control flag is set.  If the
//         DaclPresent flag is set and this field is null, then a null
//         ACL (unconditionally granting access) is specified.  If the
//         security descriptor is in self-relative form, then this field
//         contains an offset to the ACL, rather than a pointer.
//



////////////////////////////////////////////////////////////////////////
//                                                                    //
//               Privilege Related Data Structures                    //
//                                                                    //
////////////////////////////////////////////////////////////////////////


// begin_ntddk begin_nthal begin_ntifs
//
// Privilege attributes
//
enum : uint {
SE_PRIVILEGE_ENABLED_BY_DEFAULT =(0x00000001L),
SE_PRIVILEGE_ENABLED            =(0x00000002L),
SE_PRIVILEGE_USED_FOR_ACCESS    =(0x80000000L)
}

//
// Privilege Set Control flags
//

enum { PRIVILEGE_SET_ALL_NECESSARY    = (1) }

//
//  Privilege Set - This is defined for a privilege set of one.
//                  If more than one privilege is needed, then this structure
//                  will need to be allocated with more space.
//
//  Note: don't change this structure without fixing the INITIAL_PRIVILEGE_SET
//  structure (defined in se.h)
//

struct PRIVILEGE_SET {
    DWORD PrivilegeCount;
    DWORD Control;
    LUID_AND_ATTRIBUTES Privilege[ANYSIZE_ARRAY];
}
alias PRIVILEGE_SET * PPRIVILEGE_SET;


////////////////////////////////////////////////////////////////////////
//                                                                    //
//               NT Defined Privileges                                //
//                                                                    //
////////////////////////////////////////////////////////////////////////
/*
#define SE_CREATE_TOKEN_NAME              TEXT("SeCreateTokenPrivilege")
#define SE_ASSIGNPRIMARYTOKEN_NAME        TEXT("SeAssignPrimaryTokenPrivilege")
#define SE_LOCK_MEMORY_NAME               TEXT("SeLockMemoryPrivilege")
#define SE_INCREASE_QUOTA_NAME            TEXT("SeIncreaseQuotaPrivilege")
#define SE_UNSOLICITED_INPUT_NAME         TEXT("SeUnsolicitedInputPrivilege")
#define SE_MACHINE_ACCOUNT_NAME           TEXT("SeMachineAccountPrivilege")
#define SE_TCB_NAME                       TEXT("SeTcbPrivilege")
#define SE_SECURITY_NAME                  TEXT("SeSecurityPrivilege")
#define SE_TAKE_OWNERSHIP_NAME            TEXT("SeTakeOwnershipPrivilege")
#define SE_LOAD_DRIVER_NAME               TEXT("SeLoadDriverPrivilege")
#define SE_SYSTEM_PROFILE_NAME            TEXT("SeSystemProfilePrivilege")
#define SE_SYSTEMTIME_NAME                TEXT("SeSystemtimePrivilege")
#define SE_PROF_SINGLE_PROCESS_NAME       TEXT("SeProfileSingleProcessPrivilege")
#define SE_INC_BASE_PRIORITY_NAME         TEXT("SeIncreaseBasePriorityPrivilege")
#define SE_CREATE_PAGEFILE_NAME           TEXT("SeCreatePagefilePrivilege")
#define SE_CREATE_PERMANENT_NAME          TEXT("SeCreatePermanentPrivilege")
#define SE_BACKUP_NAME                    TEXT("SeBackupPrivilege")
#define SE_RESTORE_NAME                   TEXT("SeRestorePrivilege")
#define SE_SHUTDOWN_NAME                  TEXT("SeShutdownPrivilege")
#define SE_DEBUG_NAME                     TEXT("SeDebugPrivilege")
#define SE_AUDIT_NAME                     TEXT("SeAuditPrivilege")
#define SE_SYSTEM_ENVIRONMENT_NAME        TEXT("SeSystemEnvironmentPrivilege")
#define SE_CHANGE_NOTIFY_NAME             TEXT("SeChangeNotifyPrivilege")
#define SE_REMOTE_SHUTDOWN_NAME           TEXT("SeRemoteShutdownPrivilege")
*/

////////////////////////////////////////////////////////////////////
//                                                                //
//           Security Quality Of Service                          //
//                                                                //
//                                                                //
////////////////////////////////////////////////////////////////////

// begin_ntddk begin_nthal begin_ntifs
//
// Impersonation Level
//
// Impersonation level is represented by a pair of bits in Windows.
// If a new impersonation level is added or lowest value is changed from
// 0 to something else, fix the Windows CreateFile call.
//

enum SECURITY_IMPERSONATION_LEVEL {
    SecurityAnonymous,
    SecurityIdentification,
    SecurityImpersonation,
    SecurityDelegation
} 
alias SECURITY_IMPERSONATION_LEVEL * PSECURITY_IMPERSONATION_LEVEL;

//#define SECURITY_MAX_IMPERSONATION_LEVEL SecurityDelegation
//#define DEFAULT_IMPERSONATION_LEVEL SecurityImpersonation


////////////////////////////////////////////////////////////////////
//                                                                //
//           Token Object Definitions                             //
//                                                                //
//                                                                //
////////////////////////////////////////////////////////////////////


//
// Token Specific Access Rights.
//
enum {
TOKEN_ASSIGN_PRIMARY    =(0x0001),
TOKEN_DUPLICATE         =(0x0002),
TOKEN_IMPERSONATE       =(0x0004),
TOKEN_QUERY             =(0x0008),
TOKEN_QUERY_SOURCE      =(0x0010),
TOKEN_ADJUST_PRIVILEGES =(0x0020),
TOKEN_ADJUST_GROUPS     =(0x0040),
TOKEN_ADJUST_DEFAULT    =(0x0080),

TOKEN_ALL_ACCESS =(STANDARD_RIGHTS_REQUIRED  |
                          TOKEN_ASSIGN_PRIMARY      |
                          TOKEN_DUPLICATE           |
                          TOKEN_IMPERSONATE         |
                          TOKEN_QUERY               |
                          TOKEN_QUERY_SOURCE        |
                          TOKEN_ADJUST_PRIVILEGES   |
                          TOKEN_ADJUST_GROUPS       |
                          TOKEN_ADJUST_DEFAULT),


TOKEN_READ       =(STANDARD_RIGHTS_READ      |
                          TOKEN_QUERY),

TOKEN_WRITE      =(STANDARD_RIGHTS_WRITE     |
                          TOKEN_ADJUST_PRIVILEGES   |
                          TOKEN_ADJUST_GROUPS       |
                          TOKEN_ADJUST_DEFAULT),

TOKEN_EXECUTE    =(STANDARD_RIGHTS_EXECUTE)
}

//
//
// Token Types
//

enum TOKEN_TYPE {
    TokenPrimary = 1,
    TokenImpersonation
}
alias TOKEN_TYPE * PTOKEN_TYPE;


//
// Token Information Classes.
//


enum TOKEN_INFORMATION_CLASS {
    TokenUser = 1,
    TokenGroups,
    TokenPrivileges,
    TokenOwner,
    TokenPrimaryGroup,
    TokenDefaultDacl,
    TokenSource,
    TokenType,
    TokenImpersonationLevel,
    TokenStatistics
} 
alias TOKEN_INFORMATION_CLASS * PTOKEN_INFORMATION_CLASS;

//
// Token information class structures
//


struct TOKEN_USER {
    SID_AND_ATTRIBUTES User;
} 
alias TOKEN_USER * PTOKEN_USER;

// begin_ntifs

struct TOKEN_GROUPS {
    DWORD GroupCount;
    SID_AND_ATTRIBUTES Groups[ANYSIZE_ARRAY];
} 
alias TOKEN_GROUPS * PTOKEN_GROUPS;


struct TOKEN_PRIVILEGES {
    DWORD PrivilegeCount;
    LUID_AND_ATTRIBUTES Privileges[ANYSIZE_ARRAY];
} 
alias TOKEN_PRIVILEGES * PTOKEN_PRIVILEGES;


struct TOKEN_OWNER {
    PSID Owner;
} 
alias TOKEN_OWNER * PTOKEN_OWNER;


struct TOKEN_PRIMARY_GROUP {
    PSID PrimaryGroup;
} 
alias TOKEN_PRIMARY_GROUP * PTOKEN_PRIMARY_GROUP;


struct TOKEN_DEFAULT_DACL {
    PACL DefaultDacl;
} 
alias TOKEN_DEFAULT_DACL * PTOKEN_DEFAULT_DACL;



enum  { TOKEN_SOURCE_LENGTH = 8 }

struct TOKEN_SOURCE {
    CHAR SourceName[TOKEN_SOURCE_LENGTH];
    LUID SourceIdentifier;
} 
alias TOKEN_SOURCE * PTOKEN_SOURCE;


struct TOKEN_STATISTICS {
    LUID TokenId;
    LUID AuthenticationId;
    LARGE_INTEGER ExpirationTime;
    TOKEN_TYPE TokenType;
    SECURITY_IMPERSONATION_LEVEL ImpersonationLevel;
    DWORD DynamicCharged;
    DWORD DynamicAvailable;
    DWORD GroupCount;
    DWORD PrivilegeCount;
    LUID ModifiedId;
} 
alias TOKEN_STATISTICS * PTOKEN_STATISTICS;


struct TOKEN_CONTROL {
    LUID TokenId;
    LUID AuthenticationId;
    LUID ModifiedId;
    TOKEN_SOURCE TokenSource;
} 
alias TOKEN_CONTROL * PTOKEN_CONTROL;

//
// Security Tracking Mode
//

//#define SECURITY_DYNAMIC_TRACKING      (TRUE)
//#define SECURITY_STATIC_TRACKING       (FALSE)

alias BOOLEAN SECURITY_CONTEXT_TRACKING_MODE;
alias BOOLEAN * PSECURITY_CONTEXT_TRACKING_MODE;



//
// Quality Of Service
//

struct SECURITY_QUALITY_OF_SERVICE {
    DWORD Length;
    SECURITY_IMPERSONATION_LEVEL ImpersonationLevel;
    SECURITY_CONTEXT_TRACKING_MODE ContextTrackingMode;
    BOOLEAN EffectiveOnly;
} 
alias SECURITY_QUALITY_OF_SERVICE * PSECURITY_QUALITY_OF_SERVICE;


//
// Used to represent information related to a thread impersonation
//

struct SE_IMPERSONATION_STATE {
    PACCESS_TOKEN Token;
    BOOLEAN CopyOnOpen;
    BOOLEAN EffectiveOnly;
    SECURITY_IMPERSONATION_LEVEL Level;
} 
alias SE_IMPERSONATION_STATE * PSE_IMPERSONATION_STATE;

alias DWORD SECURITY_INFORMATION;
alias DWORD * PSECURITY_INFORMATION;

enum {
OWNER_SECURITY_INFORMATION       =(0X00000001L),
GROUP_SECURITY_INFORMATION       =(0X00000002L),
DACL_SECURITY_INFORMATION        =(0X00000004L),
SACL_SECURITY_INFORMATION        =(0X00000008L)
}

//
// Image Format
//

//#include "pshpack4.h"                   // 4 byte packing is the default
enum {
IMAGE_DOS_SIGNATURE                 =0x5A4D,      // MZ
IMAGE_OS2_SIGNATURE                 =0x454E,      // NE
IMAGE_OS2_SIGNATURE_LE              =0x454C,      // LE
IMAGE_VXD_SIGNATURE                 =0x454C,      // LE
IMAGE_NT_SIGNATURE                  =0x00004550,  // PE00
}
//#include "pshpack2.h"                   // 16 bit headers are 2 byte packed

struct IMAGE_DOS_HEADER {      // DOS .EXE header
    WORD   e_magic;                     // Magic number
    WORD   e_cblp;                      // Bytes on last page of file
    WORD   e_cp;                        // Pages in file
    WORD   e_crlc;                      // Relocations
    WORD   e_cparhdr;                   // Size of header in paragraphs
    WORD   e_minalloc;                  // Minimum extra paragraphs needed
    WORD   e_maxalloc;                  // Maximum extra paragraphs needed
    WORD   e_ss;                        // Initial (relative) SS value
    WORD   e_sp;                        // Initial SP value
    WORD   e_csum;                      // Checksum
    WORD   e_ip;                        // Initial IP value
    WORD   e_cs;                        // Initial (relative) CS value
    WORD   e_lfarlc;                    // File address of relocation table
    WORD   e_ovno;                      // Overlay number
    WORD   e_res[4];                    // Reserved words
    WORD   e_oemid;                     // OEM identifier (for e_oeminfo)
    WORD   e_oeminfo;                   // OEM information; e_oemid specific
    WORD   e_res2[10];                  // Reserved words
    LONG   e_lfanew;                    // File address of new exe header
} 
alias IMAGE_DOS_HEADER * PIMAGE_DOS_HEADER;

struct IMAGE_OS2_HEADER {      // OS/2 .EXE header
    WORD   ne_magic;                    // Magic number
    CHAR   ne_ver;                      // Version number
    CHAR   ne_rev;                      // Revision number
    WORD   ne_enttab;                   // Offset of Entry Table
    WORD   ne_cbenttab;                 // Number of bytes in Entry Table
    LONG   ne_crc;                      // Checksum of whole file
    WORD   ne_flags;                    // Flag word
    WORD   ne_autodata;                 // Automatic data segment number
    WORD   ne_heap;                     // Initial heap allocation
    WORD   ne_stack;                    // Initial stack allocation
    LONG   ne_csip;                     // Initial CS:IP setting
    LONG   ne_sssp;                     // Initial SS:SP setting
    WORD   ne_cseg;                     // Count of file segments
    WORD   ne_cmod;                     // Entries in Module Reference Table
    WORD   ne_cbnrestab;                // Size of non-resident name table
    WORD   ne_segtab;                   // Offset of Segment Table
    WORD   ne_rsrctab;                  // Offset of Resource Table
    WORD   ne_restab;                   // Offset of resident name table
    WORD   ne_modtab;                   // Offset of Module Reference Table
    WORD   ne_imptab;                   // Offset of Imported Names Table
    LONG   ne_nrestab;                  // Offset of Non-resident Names Table
    WORD   ne_cmovent;                  // Count of movable entries
    WORD   ne_align;                    // Segment alignment shift count
    WORD   ne_cres;                     // Count of resource segments
    BYTE   ne_exetyp;                   // Target Operating system
    BYTE   ne_flagsothers;              // Other .EXE flags
    WORD   ne_pretthunks;               // offset to return thunks
    WORD   ne_psegrefbytes;             // offset to segment ref. bytes
    WORD   ne_swaparea;                 // Minimum code swap area size
    WORD   ne_expver;                   // Expected Windows version number
} 
alias IMAGE_OS2_HEADER * PIMAGE_OS2_HEADER;

struct IMAGE_VXD_HEADER {      // Windows VXD header
    WORD   e32_magic;                   // Magic number
    BYTE   e32_border;                  // The byte ordering for the VXD
    BYTE   e32_worder;                  // The word ordering for the VXD
    DWORD  e32_level;                   // The EXE format level for now = 0
    WORD   e32_cpu;                     // The CPU type
    WORD   e32_os;                      // The OS type
    DWORD  e32_ver;                     // Module version
    DWORD  e32_mflags;                  // Module flags
    DWORD  e32_mpages;                  // Module # pages
    DWORD  e32_startobj;                // Object # for instruction pointer
    DWORD  e32_eip;                     // Extended instruction pointer
    DWORD  e32_stackobj;                // Object # for stack pointer
    DWORD  e32_esp;                     // Extended stack pointer
    DWORD  e32_pagesize;                // VXD page size
    DWORD  e32_lastpagesize;            // Last page size in VXD
    DWORD  e32_fixupsize;               // Fixup section size
    DWORD  e32_fixupsum;                // Fixup section checksum
    DWORD  e32_ldrsize;                 // Loader section size
    DWORD  e32_ldrsum;                  // Loader section checksum
    DWORD  e32_objtab;                  // Object table offset
    DWORD  e32_objcnt;                  // Number of objects in module
    DWORD  e32_objmap;                  // Object page map offset
    DWORD  e32_itermap;                 // Object iterated data map offset
    DWORD  e32_rsrctab;                 // Offset of Resource Table
    DWORD  e32_rsrccnt;                 // Number of resource entries
    DWORD  e32_restab;                  // Offset of resident name table
    DWORD  e32_enttab;                  // Offset of Entry Table
    DWORD  e32_dirtab;                  // Offset of Module Directive Table
    DWORD  e32_dircnt;                  // Number of module directives
    DWORD  e32_fpagetab;                // Offset of Fixup Page Table
    DWORD  e32_frectab;                 // Offset of Fixup Record Table
    DWORD  e32_impmod;                  // Offset of Import Module Name Table
    DWORD  e32_impmodcnt;               // Number of entries in Import Module Name Table
    DWORD  e32_impproc;                 // Offset of Import Procedure Name Table
    DWORD  e32_pagesum;                 // Offset of Per-Page Checksum Table
    DWORD  e32_datapage;                // Offset of Enumerated Data Pages
    DWORD  e32_preload;                 // Number of preload pages
    DWORD  e32_nrestab;                 // Offset of Non-resident Names Table
    DWORD  e32_cbnrestab;               // Size of Non-resident Name Table
    DWORD  e32_nressum;                 // Non-resident Name Table Checksum
    DWORD  e32_autodata;                // Object # for automatic data object
    DWORD  e32_debuginfo;               // Offset of the debugging information
    DWORD  e32_debuglen;                // The length of the debugging info. in bytes
    DWORD  e32_instpreload;             // Number of instance pages in preload section of VXD file
    DWORD  e32_instdemand;              // Number of instance pages in demand load section of VXD file
    DWORD  e32_heapsize;                // Size of heap - for 16-bit apps
    BYTE   e32_res3[12];                // Reserved words
    DWORD  e32_winresoff;
    DWORD  e32_winreslen;
    WORD   e32_devid;                   // Device ID for VxD
    WORD   e32_ddkver;                  // DDK version for VxD
} 
alias IMAGE_VXD_HEADER * PIMAGE_VXD_HEADER;

//#include "poppack.h"                    // Back to 4 byte packing

//
// File header format.
//

struct IMAGE_FILE_HEADER {
    WORD    Machine;
    WORD    NumberOfSections;
    DWORD   TimeDateStamp;
    DWORD   PointerToSymbolTable;
    DWORD   NumberOfSymbols;
    WORD    SizeOfOptionalHeader;
    WORD    Characteristics;
} 
alias IMAGE_FILE_HEADER * PIMAGE_FILE_HEADER;

enum {IMAGE_SIZEOF_FILE_HEADER             =20}

enum {
IMAGE_FILE_RELOCS_STRIPPED           =0x0001,  // Relocation info stripped from file.
IMAGE_FILE_EXECUTABLE_IMAGE          =0x0002,  // File is executable  (i.e. no unresolved externel references).
IMAGE_FILE_LINE_NUMS_STRIPPED        =0x0004,  // Line nunbers stripped from file.
IMAGE_FILE_LOCAL_SYMS_STRIPPED       =0x0008,  // Local symbols stripped from file.
IMAGE_FILE_AGGRESIVE_WS_TRIM         =0x0010,  // Agressively trim working set
IMAGE_FILE_BYTES_REVERSED_LO         =0x0080,  // Bytes of machine word are reversed.
IMAGE_FILE_32BIT_MACHINE             =0x0100,  // 32 bit word machine.
IMAGE_FILE_DEBUG_STRIPPED            =0x0200,  // Debugging info stripped from file in .DBG file
IMAGE_FILE_REMOVABLE_RUN_FROM_SWAP   =0x0400,  // If Image is on removable media, copy and run from the swap file.
IMAGE_FILE_NET_RUN_FROM_SWAP         =0x0800,  // If Image is on Net, copy and run from the swap file.
IMAGE_FILE_SYSTEM                    =0x1000,  // System File.
IMAGE_FILE_DLL                       =0x2000,  // File is a DLL.
IMAGE_FILE_UP_SYSTEM_ONLY            =0x4000,  // File should only be run on a UP machine
IMAGE_FILE_BYTES_REVERSED_HI         =0x8000,  // Bytes of machine word are reversed.

IMAGE_FILE_MACHINE_UNKNOWN           =0,
IMAGE_FILE_MACHINE_I386              =0x14c,   // Intel 386.
IMAGE_FILE_MACHINE_R3000             =0x162,   // MIPS little-endian, 0x160 big-endian
IMAGE_FILE_MACHINE_R4000             =0x166,   // MIPS little-endian
IMAGE_FILE_MACHINE_R10000            =0x168,   // MIPS little-endian
IMAGE_FILE_MACHINE_ALPHA             =0x184,   // Alpha_AXP
IMAGE_FILE_MACHINE_POWERPC           =0x1F0   // IBM PowerPC Little-Endian
}
//
// Directory format.
//

struct IMAGE_DATA_DIRECTORY {
    DWORD   VirtualAddress;
    DWORD   Size;
} 
alias IMAGE_DATA_DIRECTORY * PIMAGE_DATA_DIRECTORY;

enum { IMAGE_NUMBEROF_DIRECTORY_ENTRIES    = 16 }

//
// Optional header format.
//

struct IMAGE_OPTIONAL_HEADER {
    //
    // Standard fields.
    //

    WORD    Magic;
    BYTE    MajorLinkerVersion;
    BYTE    MinorLinkerVersion;
    DWORD   SizeOfCode;
    DWORD   SizeOfInitializedData;
    DWORD   SizeOfUninitializedData;
    DWORD   AddressOfEntryPoint;
    DWORD   BaseOfCode;
    DWORD   BaseOfData;

    //
    // NT additional fields.
    //

    DWORD   ImageBase;
    DWORD   SectionAlignment;
    DWORD   FileAlignment;
    WORD    MajorOperatingSystemVersion;
    WORD    MinorOperatingSystemVersion;
    WORD    MajorImageVersion;
    WORD    MinorImageVersion;
    WORD    MajorSubsystemVersion;
    WORD    MinorSubsystemVersion;
    DWORD   Win32VersionValue;
    DWORD   SizeOfImage;
    DWORD   SizeOfHeaders;
    DWORD   CheckSum;
    WORD    Subsystem;
    WORD    DllCharacteristics;
    DWORD   SizeOfStackReserve;
    DWORD   SizeOfStackCommit;
    DWORD   SizeOfHeapReserve;
    DWORD   SizeOfHeapCommit;
    DWORD   LoaderFlags;
    DWORD   NumberOfRvaAndSizes;
    IMAGE_DATA_DIRECTORY DataDirectory[IMAGE_NUMBEROF_DIRECTORY_ENTRIES];
} 
alias IMAGE_OPTIONAL_HEADER * PIMAGE_OPTIONAL_HEADER;

struct IMAGE_ROM_OPTIONAL_HEADER {
    WORD   Magic;
    BYTE   MajorLinkerVersion;
    BYTE   MinorLinkerVersion;
    DWORD  SizeOfCode;
    DWORD  SizeOfInitializedData;
    DWORD  SizeOfUninitializedData;
    DWORD  AddressOfEntryPoint;
    DWORD  BaseOfCode;
    DWORD  BaseOfData;
    DWORD  BaseOfBss;
    DWORD  GprMask;
    DWORD  CprMask[4];
    DWORD  GpValue;
} 
alias IMAGE_ROM_OPTIONAL_HEADER * PIMAGE_ROM_OPTIONAL_HEADER;

enum {
IMAGE_SIZEOF_ROM_OPTIONAL_HEADER      =56,
IMAGE_SIZEOF_STD_OPTIONAL_HEADER      =28,
IMAGE_SIZEOF_NT_OPTIONAL_HEADER      =224
}

enum {
IMAGE_NT_OPTIONAL_HDR_MAGIC        =0x10b,
IMAGE_ROM_OPTIONAL_HDR_MAGIC       =0x107
}

struct IMAGE_NT_HEADERS {
    DWORD Signature;
    IMAGE_FILE_HEADER FileHeader;
    IMAGE_OPTIONAL_HEADER OptionalHeader;
} 
alias IMAGE_NT_HEADERS * PIMAGE_NT_HEADERS;

struct IMAGE_ROM_HEADERS {
    IMAGE_FILE_HEADER FileHeader;
    IMAGE_ROM_OPTIONAL_HEADER OptionalHeader;
} 
alias IMAGE_ROM_HEADERS * PIMAGE_ROM_HEADERS;

/*
#define IMAGE_FIRST_SECTION( ntheader ) ((PIMAGE_SECTION_HEADER)        \
    ((DWORD)ntheader +                                                  \
     FIELD_OFFSET( IMAGE_NT_HEADERS, OptionalHeader ) +                 \
     ((PIMAGE_NT_HEADERS)(ntheader))->FileHeader.SizeOfOptionalHeader   \
    ))

*/
// Subsystem Values
enum {
IMAGE_SUBSYSTEM_UNKNOWN              =0,   // Unknown subsystem.
IMAGE_SUBSYSTEM_NATIVE               =1,   // Image doesn't require a subsystem.
IMAGE_SUBSYSTEM_WINDOWS_GUI          =2,   // Image runs in the Windows GUI subsystem.
IMAGE_SUBSYSTEM_WINDOWS_CUI          =3,   // Image runs in the Windows character subsystem.
IMAGE_SUBSYSTEM_OS2_CUI              =5,   // image runs in the OS/2 character subsystem.
IMAGE_SUBSYSTEM_POSIX_CUI            =7,   // image run  in the Posix character subsystem.
IMAGE_SUBSYSTEM_RESERVED8            =8   // image run  in the 8 subsystem.
}

enum {
// Directory Entries
IMAGE_DIRECTORY_ENTRY_EXPORT         =0,   // Export Directory
IMAGE_DIRECTORY_ENTRY_IMPORT         =1,   // Import Directory
IMAGE_DIRECTORY_ENTRY_RESOURCE       =2,   // Resource Directory
IMAGE_DIRECTORY_ENTRY_EXCEPTION      =3,   // Exception Directory
IMAGE_DIRECTORY_ENTRY_SECURITY       =4,   // Security Directory
IMAGE_DIRECTORY_ENTRY_BASERELOC      =5,   // Base Relocation Table
IMAGE_DIRECTORY_ENTRY_DEBUG          =6,   // Debug Directory
IMAGE_DIRECTORY_ENTRY_COPYRIGHT      =7,   // Description String
IMAGE_DIRECTORY_ENTRY_GLOBALPTR      =8,   // Machine Value (MIPS GP)
IMAGE_DIRECTORY_ENTRY_TLS            =9,  // TLS Directory
IMAGE_DIRECTORY_ENTRY_LOAD_CONFIG   =10,   // Load Configuration Directory
IMAGE_DIRECTORY_ENTRY_BOUND_IMPORT  =11,   // Bound Import Directory in headers
IMAGE_DIRECTORY_ENTRY_IAT           =12   // Import Address Table
}

//
// Section header format.
//
enum { IMAGE_SIZEOF_SHORT_NAME              = 8 }

struct IMAGE_SECTION_HEADER {
    BYTE    Name[IMAGE_SIZEOF_SHORT_NAME];
    union Misc {
            DWORD   PhysicalAddress;
            DWORD   VirtualSize;
    } ;
    DWORD   VirtualAddress;
    DWORD   SizeOfRawData;
    DWORD   PointerToRawData;
    DWORD   PointerToRelocations;
    DWORD   PointerToLinenumbers;
    WORD    NumberOfRelocations;
    WORD    NumberOfLinenumbers;
    DWORD   Characteristics;
} 
alias IMAGE_SECTION_HEADER * PIMAGE_SECTION_HEADER;

enum { IMAGE_SIZEOF_SECTION_HEADER          = 40 }

//
// Section characteristics.
//

//      IMAGE_SCN_TYPE_REG                   0x00000000  // Reserved.
//      IMAGE_SCN_TYPE_DSECT                 0x00000001  // Reserved.
//      IMAGE_SCN_TYPE_NOLOAD                0x00000002  // Reserved.
//      IMAGE_SCN_TYPE_GROUP                 0x00000004  // Reserved.
enum { IMAGE_SCN_TYPE_NO_PAD                = 0x00000008 } // Reserved.
//      IMAGE_SCN_TYPE_COPY                  0x00000010  // Reserved.
enum : uint { 
IMAGE_SCN_CNT_CODE                   =0x00000020,  // Section contains code.
IMAGE_SCN_CNT_INITIALIZED_DATA       =0x00000040,  // Section contains initialized data.
IMAGE_SCN_CNT_UNINITIALIZED_DATA     =0x00000080,  // Section contains uninitialized data.

IMAGE_SCN_LNK_OTHER                  =0x00000100,  // Reserved.
IMAGE_SCN_LNK_INFO                   =0x00000200,  // Section contains comments or some other type of information.
//      IMAGE_SCN_TYPE_OVER                  0x00000400  // Reserved.
IMAGE_SCN_LNK_REMOVE                 =0x00000800,  // Section contents will not become part of image.
IMAGE_SCN_LNK_COMDAT                 =0x00001000,  // Section contents comdat.
//                                           0x00002000  // Reserved.

//      IMAGE_SCN_MEM_PROTECTED - Obsolete   0x00004000
IMAGE_SCN_MEM_FARDATA                =0x00008000,
//      IMAGE_SCN_MEM_SYSHEAP  - Obsolete    0x00010000
IMAGE_SCN_MEM_PURGEABLE              =0x00020000,
IMAGE_SCN_MEM_16BIT                  =0x00020000,
IMAGE_SCN_MEM_LOCKED                 =0x00040000,
IMAGE_SCN_MEM_PRELOAD                =0x00080000,

IMAGE_SCN_ALIGN_1BYTES               =0x00100000,  //
IMAGE_SCN_ALIGN_2BYTES               =0x00200000,  //
IMAGE_SCN_ALIGN_4BYTES               =0x00300000,  //
IMAGE_SCN_ALIGN_8BYTES               =0x00400000,  //
IMAGE_SCN_ALIGN_16BYTES              =0x00500000,  // Default alignment if no others are specified.
IMAGE_SCN_ALIGN_32BYTES              =0x00600000,  //
IMAGE_SCN_ALIGN_64BYTES              =0x00700000,  //
// Unused                                    0x00800000

IMAGE_SCN_LNK_NRELOC_OVFL            =0x01000000,  // Section contains extended relocations.
IMAGE_SCN_MEM_DISCARDABLE            =0x02000000,  // Section can be discarded.
IMAGE_SCN_MEM_NOT_CACHED             =0x04000000,  // Section is not cachable.
IMAGE_SCN_MEM_NOT_PAGED              =0x08000000,  // Section is not pageable.
IMAGE_SCN_MEM_SHARED                 =0x10000000,  // Section is shareable.
IMAGE_SCN_MEM_EXECUTE                =0x20000000,  // Section is executable.
IMAGE_SCN_MEM_READ                   =0x40000000,  // Section is readable.
IMAGE_SCN_MEM_WRITE                  =0x80000000,  // Section is writeable.

//
// TLS Chaacteristic Flags
//
IMAGE_SCN_SCALE_INDEX                =0x00000001,  // Tls index is scaled
}
//#include "pshpack2.h"                       // Symbols, relocs, and linenumbers are 2 byte packed

//
// Symbol format.
//

struct IMAGE_SYMBOL {
    union N {
        BYTE    ShortName[8];
        struct Name {
            DWORD   Short;     // if 0, use LongName
            DWORD   Long;      // offset into string table
        } ;
        PBYTE   LongName[2];
    } ;
    DWORD   Value;
    SHORT   SectionNumber;
    WORD    Type;
    BYTE    StorageClass;
    BYTE    NumberOfAuxSymbols;
}
//alias IMAGE_SYMBOL UNALIGNED *PIMAGE_SYMBOL;
alias IMAGE_SYMBOL * PIMAGE_SYMBOL;


enum { IMAGE_SIZEOF_SYMBOL                  =18 }

//
// Section values.
//
// Symbols have a section number of the section in which they are
// defined. Otherwise, section numbers have the following meanings:
//
enum : short {
IMAGE_SYM_UNDEFINED           =(SHORT)0,          // Symbol is undefined or is common.
IMAGE_SYM_ABSOLUTE            =(SHORT)-1,         // Symbol is an absolute value.
IMAGE_SYM_DEBUG               =(SHORT)-2         // Symbol is a special debug item.
}

enum {
//
// Type (fundamental) values.
//
IMAGE_SYM_TYPE_NULL                 =0x0000,  // no type.
IMAGE_SYM_TYPE_VOID                 =0x0001,  //
IMAGE_SYM_TYPE_CHAR                 =0x0002,  // type character.
IMAGE_SYM_TYPE_SHORT                =0x0003,  // type short integer.
IMAGE_SYM_TYPE_INT                  =0x0004,  //
IMAGE_SYM_TYPE_LONG                 =0x0005,  //
IMAGE_SYM_TYPE_FLOAT                =0x0006,  //
IMAGE_SYM_TYPE_DOUBLE               =0x0007,  //
IMAGE_SYM_TYPE_STRUCT               =0x0008 , //
IMAGE_SYM_TYPE_UNION                =0x0009,  //
IMAGE_SYM_TYPE_ENUM                 =0x000A,  // enumeration.
IMAGE_SYM_TYPE_MOE                  =0x000B,  // member of enumeration.
IMAGE_SYM_TYPE_BYTE                 =0x000C,  //
IMAGE_SYM_TYPE_WORD                 =0x000D,  //
IMAGE_SYM_TYPE_UINT                 =0x000E,  //
IMAGE_SYM_TYPE_DWORD                =0x000F,  //
IMAGE_SYM_TYPE_PCODE                =0x8000  //
}

enum {
//
// Type (derived) values.
//
IMAGE_SYM_DTYPE_NULL                =0,       // no derived type.
IMAGE_SYM_DTYPE_POINTER             =1,       // pointer.
IMAGE_SYM_DTYPE_FUNCTION            =2,       // function.
IMAGE_SYM_DTYPE_ARRAY               =3       // array.
}

enum : BYTE {
//
// Storage classes.
//
IMAGE_SYM_CLASS_END_OF_FUNCTION     =(BYTE )-1,
IMAGE_SYM_CLASS_NULL                =0x0000,
IMAGE_SYM_CLASS_AUTOMATIC           =0x0001,
IMAGE_SYM_CLASS_EXTERNAL            =0x0002,
IMAGE_SYM_CLASS_STATIC              =0x0003,
IMAGE_SYM_CLASS_REGISTER            =0x0004,
IMAGE_SYM_CLASS_EXTERNAL_DEF        =0x0005,
IMAGE_SYM_CLASS_LABEL               =0x0006,
IMAGE_SYM_CLASS_UNDEFINED_LABEL     =0x0007,
IMAGE_SYM_CLASS_MEMBER_OF_STRUCT    =0x0008,
IMAGE_SYM_CLASS_ARGUMENT            =0x0009,
IMAGE_SYM_CLASS_STRUCT_TAG          =0x000A,
IMAGE_SYM_CLASS_MEMBER_OF_UNION     =0x000B,
IMAGE_SYM_CLASS_UNION_TAG           =0x000C,
IMAGE_SYM_CLASS_TYPE_DEFINITION     =0x000D,
IMAGE_SYM_CLASS_UNDEFINED_STATIC    =0x000E,
IMAGE_SYM_CLASS_ENUM_TAG            =0x000F,
IMAGE_SYM_CLASS_MEMBER_OF_ENUM      =0x0010,
IMAGE_SYM_CLASS_REGISTER_PARAM      =0x0011,
IMAGE_SYM_CLASS_BIT_FIELD           =0x0012,

IMAGE_SYM_CLASS_FAR_EXTERNAL        =0x0044,  //

IMAGE_SYM_CLASS_BLOCK               =0x0064,
IMAGE_SYM_CLASS_FUNCTION            =0x0065,
IMAGE_SYM_CLASS_END_OF_STRUCT       =0x0066,
IMAGE_SYM_CLASS_FILE                =0x0067,
// new
IMAGE_SYM_CLASS_SECTION             =0x0068,
IMAGE_SYM_CLASS_WEAK_EXTERNAL       =0x0069
}

enum {
// type packing constants
N_BTMASK                            =0x000F,
N_TMASK                             =0x0030,
N_TMASK1                            =0x00C0,
N_TMASK2                            =0x00F0,
N_BTSHFT                            =4,
N_TSHIFT                            =2
}

// MACROS
/*
// Basic Type of  x
#define BTYPE(x) ((x) & N_BTMASK)

// Is x a pointer?
#ifndef ISPTR
#define ISPTR(x) (((x) & N_TMASK) == (IMAGE_SYM_DTYPE_POINTER << N_BTSHFT))
#endif

// Is x a function?
#ifndef ISFCN
#define ISFCN(x) (((x) & N_TMASK) == (IMAGE_SYM_DTYPE_FUNCTION << N_BTSHFT))
#endif

// Is x an array?

#ifndef ISARY
#define ISARY(x) (((x) & N_TMASK) == (IMAGE_SYM_DTYPE_ARRAY << N_BTSHFT))
#endif

// Is x a structure, union, or enumeration TAG?
#ifndef ISTAG
#define ISTAG(x) ((x)==IMAGE_SYM_CLASS_STRUCT_TAG || (x)==IMAGE_SYM_CLASS_UNION_TAG || (x)==IMAGE_SYM_CLASS_ENUM_TAG)
#endif

#ifndef INCREF
#define INCREF(x) ((((x)&~N_BTMASK)<<N_TSHIFT)|(IMAGE_SYM_DTYPE_POINTER<<N_BTSHFT)|((x)&N_BTMASK))
#endif
#ifndef DECREF
#define DECREF(x) ((((x)>>N_TSHIFT)&~N_BTMASK)|((x)&N_BTMASK))
#endif
*/
//
// Auxiliary entry format.
//

union IMAGE_AUX_SYMBOL {
    struct Sym {
        DWORD    TagIndex;                      // struct, union, or enum tag index
        union Misc {
            struct LnSz{
                WORD    Linenumber;             // declaration line number
                WORD    Size;                   // size of struct, union, or enum
            } ;
           DWORD    TotalSize;
        } ;
        union FcnAry {
            struct Function {                            // if ISFCN, tag, or .bb
                DWORD    PointerToLinenumber;
                DWORD    PointerToNextFunction;
            } ;
            struct Array {                            // if ISARY, up to 4 dimen.
                WORD     Dimension[4];
            } ;
        } ;
        WORD    TvIndex;                        // tv index
    } ;
    struct File {
        BYTE    Name[IMAGE_SIZEOF_SYMBOL];
    } ;
    struct Section {
        DWORD   Length;                         // section length
        WORD    NumberOfRelocations;            // number of relocation entries
        WORD    NumberOfLinenumbers;            // number of line numbers
        DWORD   CheckSum;                       // checksum for communal
        SHORT   Number;                         // section number to associate with
        BYTE    Selection;                      // communal selection type
    } ;
} 
//alias IMAGE_AUX_SYMBOL UNALIGNED *PIMAGE_AUX_SYMBOL;
alias IMAGE_AUX_SYMBOL * PIMAGE_AUX_SYMBOL;

enum { IMAGE_SIZEOF_AUX_SYMBOL             =18}

//
// Communal selection types.
//
enum {
IMAGE_COMDAT_SELECT_NODUPLICATES    =1,
IMAGE_COMDAT_SELECT_ANY             =2,
IMAGE_COMDAT_SELECT_SAME_SIZE       =3,
IMAGE_COMDAT_SELECT_EXACT_MATCH     =4,
IMAGE_COMDAT_SELECT_ASSOCIATIVE     =5,
IMAGE_COMDAT_SELECT_LARGEST         =6,
IMAGE_COMDAT_SELECT_NEWEST          =7
}
enum {
IMAGE_WEAK_EXTERN_SEARCH_NOLIBRARY  =1,
IMAGE_WEAK_EXTERN_SEARCH_LIBRARY    =2,
IMAGE_WEAK_EXTERN_SEARCH_ALIAS      =3
}
//
// Relocation format.
//

struct IMAGE_RELOCATION {
    union {
        DWORD   VirtualAddress;
        DWORD   RelocCount;             // Set to the real count when IMAGE_SCN_LNK_NRELOC_OVFL is set
    };
    DWORD   SymbolTableIndex;
    WORD    Type;
} 
//alias IMAGE_RELOCATION UNALIGNED *PIMAGE_RELOCATION;
alias IMAGE_RELOCATION * PIMAGE_RELOCATION;

enum { IMAGE_SIZEOF_RELOCATION         =10 }

enum { 
//
// I386 relocation types.
//
IMAGE_REL_I386_ABSOLUTE         =0x0000,  // Reference is absolute, no relocation is necessary
IMAGE_REL_I386_DIR16            =0x0001, // Direct 16-bit reference to the symbols virtual address
IMAGE_REL_I386_REL16            =0x0002,// PC-relative 16-bit reference to the symbols virtual address
IMAGE_REL_I386_DIR32            =0x0006,  // Direct 32-bit reference to the symbols virtual address
IMAGE_REL_I386_DIR32NB          =0x0007,  // Direct 32-bit reference to the symbols virtual address, base not included
IMAGE_REL_I386_SEG12            =0x0009,  // Direct 16-bit reference to the segment-selector bits of a 32-bit virtual address
IMAGE_REL_I386_SECTION          =0x000A,
IMAGE_REL_I386_SECREL           =0x000B,
IMAGE_REL_I386_REL32            =0x0014,  // PC-relative 32-bit reference to the symbols virtual address
//
// MIPS relocation types.
//

IMAGE_REL_MIPS_ABSOLUTE         =0x0000,  // Reference is absolute, no relocation is necessary
IMAGE_REL_MIPS_REFHALF          =0x0001,
IMAGE_REL_MIPS_REFWORD          =0x0002,
IMAGE_REL_MIPS_JMPADDR          =0x0003,
IMAGE_REL_MIPS_REFHI            =0x0004,
IMAGE_REL_MIPS_REFLO            =0x0005,
IMAGE_REL_MIPS_GPREL            =0x0006,
IMAGE_REL_MIPS_LITERAL          =0x0007,
IMAGE_REL_MIPS_SECTION          =0x000A,
IMAGE_REL_MIPS_SECREL           =0x000B,
IMAGE_REL_MIPS_SECRELLO         =0x000C,  // Low 16-bit section relative referemce (used for >32k TLS)
IMAGE_REL_MIPS_SECRELHI         =0x000D,  // High 16-bit section relative reference (used for >32k TLS)
IMAGE_REL_MIPS_REFWORDNB        =0x0022,
IMAGE_REL_MIPS_PAIR             =0x0025,

//
// Alpha Relocation types.
//

IMAGE_REL_ALPHA_ABSOLUTE        =0x0000,
IMAGE_REL_ALPHA_REFLONG         =0x0001,
IMAGE_REL_ALPHA_REFQUAD         =0x0002,
IMAGE_REL_ALPHA_GPREL32         =0x0003,
IMAGE_REL_ALPHA_LITERAL         =0x0004,
IMAGE_REL_ALPHA_LITUSE          =0x0005,
IMAGE_REL_ALPHA_GPDISP          =0x0006,
IMAGE_REL_ALPHA_BRADDR          =0x0007,
IMAGE_REL_ALPHA_HINT            =0x0008,
IMAGE_REL_ALPHA_INLINE_REFLONG  =0x0009,
IMAGE_REL_ALPHA_REFHI           =0x000A,
IMAGE_REL_ALPHA_REFLO           =0x000B,
IMAGE_REL_ALPHA_PAIR            =0x000C,
IMAGE_REL_ALPHA_MATCH           =0x000D,
IMAGE_REL_ALPHA_SECTION         =0x000E,
IMAGE_REL_ALPHA_SECREL          =0x000F,
IMAGE_REL_ALPHA_REFLONGNB       =0x0010,
IMAGE_REL_ALPHA_SECRELLO        =0x0011 , // Low 16-bit section relative reference
IMAGE_REL_ALPHA_SECRELHI        =0x0012,  // High 16-bit section relative reference

//
// IBM PowerPC relocation types.
//

IMAGE_REL_PPC_ABSOLUTE          =0x0000,  // NOP
IMAGE_REL_PPC_ADDR64            =0x0001,  // 64-bit address
IMAGE_REL_PPC_ADDR32            =0x0002,  // 32-bit address
IMAGE_REL_PPC_ADDR24            =0x0003,  // 26-bit address, shifted left 2 (branch absolute)
IMAGE_REL_PPC_ADDR16            =0x0004,  // 16-bit address
IMAGE_REL_PPC_ADDR14            =0x0005,  // 16-bit address, shifted left 2 (load doubleword)
IMAGE_REL_PPC_REL24             =0x0006,  // 26-bit PC-relative offset, shifted left 2 (branch relative)
IMAGE_REL_PPC_REL14             =0x0007,  // 16-bit PC-relative offset, shifted left 2 (br cond relative)
IMAGE_REL_PPC_TOCREL16          =0x0008,  // 16-bit offset from TOC base
IMAGE_REL_PPC_TOCREL14          =0x0009,  // 16-bit offset from TOC base, shifted left 2 (load doubleword)

IMAGE_REL_PPC_ADDR32NB          =0x000A,  // 32-bit addr w/o image base
IMAGE_REL_PPC_SECREL            =0x000B,  // va of containing section (as in an image sectionhdr)
IMAGE_REL_PPC_SECTION           =0x000C,  // sectionheader number
IMAGE_REL_PPC_IFGLUE            =0x000D,  // substitute TOC restore instruction iff symbol is glue code
IMAGE_REL_PPC_IMGLUE            =0x000E,  // symbol is glue code; virtual address is TOC restore instruction
IMAGE_REL_PPC_SECREL16          =0x000F,  // va of containing section (limited to 16 bits)
IMAGE_REL_PPC_REFHI             =0x0010,
IMAGE_REL_PPC_REFLO             =0x0011,
IMAGE_REL_PPC_PAIR              =0x0012,
IMAGE_REL_PPC_SECRELLO          =0x0013 , // Low 16-bit section relative reference (used for >32k TLS)
IMAGE_REL_PPC_SECRELHI          =0x0014,  // High 16-bit section relative reference (used for >32k TLS)

IMAGE_REL_PPC_TYPEMASK          =0x00FF,  // mask to isolate above values in IMAGE_RELOCATION.Type

// Flag bits in IMAGE_RELOCATION.TYPE

IMAGE_REL_PPC_NEG               =0x0100,  // subtract reloc value rather than adding it
IMAGE_REL_PPC_BRTAKEN           =0x0200,  // fix branch prediction bit to predict branch taken
IMAGE_REL_PPC_BRNTAKEN          =0x0400,  // fix branch prediction bit to predict branch not taken
IMAGE_REL_PPC_TOCDEFN           =0x0800  // toc slot defined in file (or, data in toc)
}
//
// Line number format.
//

struct IMAGE_LINENUMBER {
    union Type {
        DWORD   SymbolTableIndex;               // Symbol table index of function name if Linenumber is 0.
        DWORD   VirtualAddress;                 // Virtual address of line number.
    } ;
    WORD    Linenumber;                         // Line number.
} 
//alias IMAGE_LINENUMBER UNALIGNED *PIMAGE_LINENUMBER;
alias IMAGE_LINENUMBER * PIMAGE_LINENUMBER;

enum { IMAGE_SIZEOF_LINENUMBER              = 6 }

//#include "poppack.h"                        // Back to 4 byte packing

//
// Based relocation format.
//

struct IMAGE_BASE_RELOCATION {
    DWORD   VirtualAddress;
    DWORD   SizeOfBlock;
//  WORD    TypeOffset[1];
} 
//alias IMAGE_BASE_RELOCATION UNALIGNED * PIMAGE_BASE_RELOCATION;
alias IMAGE_BASE_RELOCATION * PIMAGE_BASE_RELOCATION;

enum { IMAGE_SIZEOF_BASE_RELOCATION         = 8 }

//
// Based relocation types.
//
enum {
IMAGE_REL_BASED_ABSOLUTE              =0,
IMAGE_REL_BASED_HIGH                  =1,
IMAGE_REL_BASED_LOW                   =2,
IMAGE_REL_BASED_HIGHLOW               =3,
IMAGE_REL_BASED_HIGHADJ               =4,
IMAGE_REL_BASED_MIPS_JMPADDR          =5,
IMAGE_REL_BASED_SECTION               =6,
IMAGE_REL_BASED_REL32                 =7
}
//
// Archive format.
//
enum { IMAGE_ARCHIVE_START_SIZE             =8 }
/*
IMAGE_ARCHIVE_START                  "!<arch>\n"
IMAGE_ARCHIVE_END                    "`\n"
IMAGE_ARCHIVE_PAD                    "\n"
IMAGE_ARCHIVE_LINKER_MEMBER          "/               "
IMAGE_ARCHIVE_LONGNAMES_MEMBER       "//              "
*/
struct IMAGE_ARCHIVE_MEMBER_HEADER {
    BYTE     Name[16];                          // File member name - `/' terminated.
    BYTE     Date[12];                          // File member date - decimal.
    BYTE     UserID[6];                         // File member user id - decimal.
    BYTE     GroupID[6];                        // File member group id - decimal.
    BYTE     Mode[8];                           // File member mode - octal.
    BYTE     Size[10];                          // File member size - decimal.
    BYTE     EndHeader[2];                      // String to end header.
} 
alias IMAGE_ARCHIVE_MEMBER_HEADER * PIMAGE_ARCHIVE_MEMBER_HEADER;

enum { IMAGE_SIZEOF_ARCHIVE_MEMBER_HDR      = 60 }

//
// DLL support.
//

//
// Export Format
//

struct IMAGE_EXPORT_DIRECTORY {
    DWORD   Characteristics;
    DWORD   TimeDateStamp;
    WORD    MajorVersion;
    WORD    MinorVersion;
    DWORD   Name;
    DWORD   Base;
    DWORD   NumberOfFunctions;
    DWORD   NumberOfNames;
    PDWORD  *AddressOfFunctions;
    PDWORD  *AddressOfNames;
    PWORD   *AddressOfNameOrdinals;
} 
alias IMAGE_EXPORT_DIRECTORY * PIMAGE_EXPORT_DIRECTORY;

//
// Import Format
//

struct IMAGE_IMPORT_BY_NAME {
    WORD    Hint;
    BYTE    Name[1];
} 
alias IMAGE_IMPORT_BY_NAME * PIMAGE_IMPORT_BY_NAME;

struct IMAGE_THUNK_DATA {
    union u1 {
        PBYTE  ForwarderString;
        PDWORD Function;
        DWORD Ordinal;
        PIMAGE_IMPORT_BY_NAME AddressOfData;
    } ;
}
alias IMAGE_THUNK_DATA * PIMAGE_THUNK_DATA;

enum : uint { IMAGE_ORDINAL_FLAG = 0x80000000 }
//IMAGE_SNAP_BY_ORDINAL(Ordinal) ((Ordinal & IMAGE_ORDINAL_FLAG) != 0)
//IMAGE_ORDINAL(Ordinal) (Ordinal & 0xffff)

struct IMAGE_IMPORT_DESCRIPTOR {
    union {
        DWORD   Characteristics;                // 0 for terminating null import descriptor
        PIMAGE_THUNK_DATA OriginalFirstThunk;   // RVA to original unbound IAT
    };
    DWORD   TimeDateStamp;                  // 0 if not bound,
                                            // -1 if bound, and real date\time stamp
                                            //     in IMAGE_DIRECTORY_ENTRY_BOUND_IMPORT (new BIND)
                                            // O.W. date/time stamp of DLL bound to (Old BIND)

    DWORD   ForwarderChain;                 // -1 if no forwarders
    DWORD   Name;
    PIMAGE_THUNK_DATA FirstThunk;           // RVA to IAT (if bound this IAT has actual addresses)
}
//alias IMAGE_IMPORT_DESCRIPTOR UNALIGNED *PIMAGE_IMPORT_DESCRIPTOR;
alias IMAGE_IMPORT_DESCRIPTOR * PIMAGE_IMPORT_DESCRIPTOR;

//
// New format import descriptors pointed to by DataDirectory[ IMAGE_DIRECTORY_ENTRY_BOUND_IMPORT ]
//

struct IMAGE_BOUND_IMPORT_DESCRIPTOR {
    DWORD   TimeDateStamp;
    WORD    OffsetModuleName;
    WORD    NumberOfModuleForwarderRefs;
// Array of zero or more IMAGE_BOUND_FORWARDER_REF follows
} 
alias IMAGE_BOUND_IMPORT_DESCRIPTOR * PIMAGE_BOUND_IMPORT_DESCRIPTOR;

struct IMAGE_BOUND_FORWARDER_REF {
    DWORD   TimeDateStamp;
    WORD    OffsetModuleName;
    WORD    Reserved;
} 
alias IMAGE_BOUND_FORWARDER_REF * PIMAGE_BOUND_FORWARDER_REF;


//
// Thread Local Storage
//

alias VOID (*PIMAGE_TLS_CALLBACK) (PVOID DllHandle,DWORD Reason,PVOID Reserved);

struct IMAGE_TLS_DIRECTORY {
    DWORD   StartAddressOfRawData;
    DWORD   EndAddressOfRawData;
    PDWORD  AddressOfIndex;
    PIMAGE_TLS_CALLBACK *AddressOfCallBacks;
    DWORD   SizeOfZeroFill;
    DWORD   Characteristics;
} 
alias IMAGE_TLS_DIRECTORY * PIMAGE_TLS_DIRECTORY;


//
// Resource Format.
//

//
// Resource directory consists of two counts, following by a variable length
// array of directory entries.  The first count is the number of entries at
// beginning of the array that have actual names associated with each entry.
// The entries are in ascending order, case insensitive strings.  The second
// count is the number of entries that immediately follow the named entries.
// This second count identifies the number of entries that have 16-bit integer
// Ids as their name.  These entries are also sorted in ascending order.
//
// This structure allows fast lookup by either name or number, but for any
// given resource entry only one form of lookup is supported, not both.
// This is consistant with the syntax of the .RC file and the .RES file.
//

struct IMAGE_RESOURCE_DIRECTORY {
    DWORD   Characteristics;
    DWORD   TimeDateStamp;
    WORD    MajorVersion;
    WORD    MinorVersion;
    WORD    NumberOfNamedEntries;
    WORD    NumberOfIdEntries;
//  IMAGE_RESOURCE_DIRECTORY_ENTRY DirectoryEntries[];
} 
alias IMAGE_RESOURCE_DIRECTORY * PIMAGE_RESOURCE_DIRECTORY;

enum : uint {
IMAGE_RESOURCE_NAME_IS_STRING        =0x80000000,
IMAGE_RESOURCE_DATA_IS_DIRECTORY     =0x80000000
}

//
// Each directory contains the 32-bit Name of the entry and an offset,
// relative to the beginning of the resource directory of the data associated
// with this directory entry.  If the name of the entry is an actual text
// string instead of an integer Id, then the high order bit of the name field
// is set to one and the low order 31-bits are an offset, relative to the
// beginning of the resource directory of the string, which is of type
// IMAGE_RESOURCE_DIRECTORY_STRING.  Otherwise the high bit is clear and the
// low-order 16-bits are the integer Id that identify this resource directory
// entry. If the directory entry is yet another resource directory (i.e. a
// subdirectory), then the high order bit of the offset field will be
// set to indicate this.  Otherwise the high bit is clear and the offset
// field points to a resource data entry.
//

struct IMAGE_RESOURCE_DIRECTORY_ENTRY {
    union {
        struct {
//            DWORD NameOffset:31;
//            DWORD NameIsString:1;
            DWORD bits;
        };
        DWORD   Name;
        WORD    Id;
    };
    union {
        DWORD   OffsetToData;
        struct {
            DWORD morebits;
//            DWORD   OffsetToDirectory:31;
//            DWORD   DataIsDirectory:1;
        };
    };
} 
alias IMAGE_RESOURCE_DIRECTORY_ENTRY * PIMAGE_RESOURCE_DIRECTORY_ENTRY;

//
// For resource directory entries that have actual string names, the Name
// field of the directory entry points to an object of the following type.
// All of these string objects are stored together after the last resource
// directory entry and before the first resource data object.  This minimizes
// the impact of these variable length objects on the alignment of the fixed
// size directory entry objects.
//

struct IMAGE_RESOURCE_DIRECTORY_STRING {
    WORD    Length;
    CHAR    NameString[ 1 ];
} 
alias IMAGE_RESOURCE_DIRECTORY_STRING * PIMAGE_RESOURCE_DIRECTORY_STRING;


struct IMAGE_RESOURCE_DIR_STRING_U {
    WORD    Length;
    WCHAR   NameString[ 1 ];
} 
alias IMAGE_RESOURCE_DIR_STRING_U * PIMAGE_RESOURCE_DIR_STRING_U;


//
// Each resource data entry describes a leaf node in the resource directory
// tree.  It contains an offset, relative to the beginning of the resource
// directory of the data for the resource, a size field that gives the number
// of bytes of data at that offset, a CodePage that should be used when
// decoding code point values within the resource data.  Typically for new
// applications the code page would be the unicode code page.
//

struct IMAGE_RESOURCE_DATA_ENTRY {
    DWORD   OffsetToData;
    DWORD   Size;
    DWORD   CodePage;
    DWORD   Reserved;
} 
alias IMAGE_RESOURCE_DATA_ENTRY * PIMAGE_RESOURCE_DATA_ENTRY;

//
// Load Configuration Directory Entry
//
struct IMAGE_LOAD_CONFIG_DIRECTORY {
    DWORD   Characteristics;
    DWORD   TimeDateStamp;
    WORD    MajorVersion;
    WORD    MinorVersion;
    DWORD   GlobalFlagsClear;
    DWORD   GlobalFlagsSet;
    DWORD   CriticalSectionDefaultTimeout;
    DWORD   DeCommitFreeBlockThreshold;
    DWORD   DeCommitTotalFreeThreshold;
    PVOID   LockPrefixTable;
    DWORD   MaximumAllocationSize;
    DWORD   VirtualMemoryThreshold;
    DWORD   ProcessHeapFlags;
    DWORD   ProcessAffinityMask;
    DWORD   Reserved[ 3 ];
} 
alias IMAGE_LOAD_CONFIG_DIRECTORY * PIMAGE_LOAD_CONFIG_DIRECTORY;


//
// Function table entry format for MIPS/ALPHA images.  Function table is
// pointed to by the IMAGE_DIRECTORY_ENTRY_EXCEPTION directory entry.
// This definition duplicates ones in ntmips.h and ntalpha.h for use
// by portable image file mungers.
//

struct IMAGE_RUNTIME_FUNCTION_ENTRY {
    DWORD BeginAddress;
    DWORD EndAddress;
    PVOID ExceptionHandler;
    PVOID HandlerData;
    DWORD PrologEndAddress;
} 
alias IMAGE_RUNTIME_FUNCTION_ENTRY * PIMAGE_RUNTIME_FUNCTION_ENTRY;

//
// Debug Format
//
struct IMAGE_DEBUG_DIRECTORY {
    DWORD   Characteristics;
    DWORD   TimeDateStamp;
    WORD    MajorVersion;
    WORD    MinorVersion;
    DWORD   Type;
    DWORD   SizeOfData;
    DWORD   AddressOfRawData;
    DWORD   PointerToRawData;
} 
alias IMAGE_DEBUG_DIRECTORY * PIMAGE_DEBUG_DIRECTORY;

enum {
IMAGE_DEBUG_TYPE_UNKNOWN          =0,
IMAGE_DEBUG_TYPE_COFF             =1,
IMAGE_DEBUG_TYPE_CODEVIEW         =2,
IMAGE_DEBUG_TYPE_FPO              =3,
IMAGE_DEBUG_TYPE_MISC             =4,
IMAGE_DEBUG_TYPE_EXCEPTION        =5,
IMAGE_DEBUG_TYPE_FIXUP            =6,
IMAGE_DEBUG_TYPE_OMAP_TO_SRC      =7,
IMAGE_DEBUG_TYPE_OMAP_FROM_SRC    =8
}

struct IMAGE_COFF_SYMBOLS_HEADER {
    DWORD   NumberOfSymbols;
    DWORD   LvaToFirstSymbol;
    DWORD   NumberOfLinenumbers;
    DWORD   LvaToFirstLinenumber;
    DWORD   RvaToFirstByteOfCode;
    DWORD   RvaToLastByteOfCode;
    DWORD   RvaToFirstByteOfData;
    DWORD   RvaToLastByteOfData;
} 
alias IMAGE_COFF_SYMBOLS_HEADER * PIMAGE_COFF_SYMBOLS_HEADER;

enum {
FRAME_FPO       =0,
FRAME_TRAP      =1,
FRAME_TSS       =2,
FRAME_NONFPO    =3
}

struct FPO_DATA {
    DWORD       ulOffStart;             // offset 1st byte of function code
    DWORD       cbProcSize;             // # bytes in function
    DWORD       cdwLocals;              // # bytes in locals/4
    WORD        cdwParams;              // # bytes in params/4
    WORD        bits;           // # bytes in prolog
	 /*
    WORD        cbProlog : 8;           // # bytes in prolog
    WORD        cbRegs   : 3;           // # regs saved
    WORD        fHasSEH  : 1;           // TRUE if SEH in func
    WORD        fUseBP   : 1;           // TRUE if EBP has been allocated
    WORD        reserved : 1;           // reserved for future use
    WORD        cbFrame  : 2;           // frame type
	 */
} 
alias FPO_DATA * PFPO_DATA;
enum { SIZEOF_RFPO_DATA = 16 }


enum { IMAGE_DEBUG_MISC_EXENAME    = 1 }

struct IMAGE_DEBUG_MISC {
    DWORD       DataType;               // type of misc data, see defines
    DWORD       Length;                 // total length of record, rounded to four
                                        // byte multiple.
    BOOLEAN     Unicode;                // TRUE if data is unicode string
    BYTE        Reserved[ 3 ];
    BYTE        Data[ 1 ];              // Actual data
} 
alias IMAGE_DEBUG_MISC * PIMAGE_DEBUG_MISC;


//
// Function table extracted from MIPS/ALPHA images.  Does not contain
// information needed only for runtime support.  Just those fields for
// each entry needed by a debugger.
//

struct IMAGE_FUNCTION_ENTRY {
    DWORD   StartingAddress;
    DWORD   EndingAddress;
    DWORD   EndOfPrologue;
} 
alias IMAGE_FUNCTION_ENTRY * PIMAGE_FUNCTION_ENTRY;

//
// Debugging information can be stripped from an image file and placed
// in a separate .DBG file, whose file name part is the same as the
// image file name part (e.g. symbols for CMD.EXE could be stripped
// and placed in CMD.DBG).  This is indicated by the IMAGE_FILE_DEBUG_STRIPPED
// flag in the Characteristics field of the file header.  The beginning of
// the .DBG file contains the following structure which captures certain
// information from the image file.  This allows a debug to proceed even if
// the original image file is not accessable.  This header is followed by
// zero of more IMAGE_SECTION_HEADER structures, followed by zero or more
// IMAGE_DEBUG_DIRECTORY structures.  The latter structures and those in
// the image file contain file offsets relative to the beginning of the
// .DBG file.
//
// If symbols have been stripped from an image, the IMAGE_DEBUG_MISC structure
// is left in the image file, but not mapped.  This allows a debugger to
// compute the name of the .DBG file, from the name of the image in the
// IMAGE_DEBUG_MISC structure.
//

struct IMAGE_SEPARATE_DEBUG_HEADER {
    WORD        Signature;
    WORD        Flags;
    WORD        Machine;
    WORD        Characteristics;
    DWORD       TimeDateStamp;
    DWORD       CheckSum;
    DWORD       ImageBase;
    DWORD       SizeOfImage;
    DWORD       NumberOfSections;
    DWORD       ExportedNamesSize;
    DWORD       DebugDirectorySize;
    DWORD       SectionAlignment;
    DWORD       Reserved[2];
} 
alias IMAGE_SEPARATE_DEBUG_HEADER * PIMAGE_SEPARATE_DEBUG_HEADER;

enum { IMAGE_SEPARATE_DEBUG_SIGNATURE  = 0x4944 }
enum { 
IMAGE_SEPARATE_DEBUG_FLAGS_MASK =0x8000,
IMAGE_SEPARATE_DEBUG_MISMATCH   =0x8000  // when DBG was updated, the
                                                // old checksum didn't match.
}

//#include "poppack.h"                        // Return to the default

//
// End Image Format
//

//
// for move macros
//
//#include <string.h>
enum {
HEAP_NO_SERIALIZE               =0x00000001,     
HEAP_GROWABLE                   =0x00000002,     
HEAP_GENERATE_EXCEPTIONS        =0x00000004,      
HEAP_ZERO_MEMORY                =0x00000008,      
HEAP_REALLOC_IN_PLACE_ONLY      =0x00000010,      
HEAP_TAIL_CHECKING_ENABLED      =0x00000020,      
HEAP_FREE_CHECKING_ENABLED      =0x00000040,    
HEAP_DISABLE_COALESCE_ON_FREE   =0x00000080,     
HEAP_CREATE_ALIGN_16            =0x00010000,      
HEAP_CREATE_ENABLE_TRACING      =0x00020000
}
enum {
HEAP_MAXIMUM_TAG                =0x0FFF,              
HEAP_PSEUDO_TAG_FLAG            =0x8000              
}
enum { HEAP_TAG_SHIFT                  =16  }
//HEAP_MAKE_TAG_FLAGS( b, o ) ((DWORD)((b) + ((o) << 16)))  

enum {
IS_TEXT_UNICODE_ASCII16               =0x0001,
IS_TEXT_UNICODE_REVERSE_ASCII16       =0x0010,

IS_TEXT_UNICODE_STATISTICS            =0x0002,
IS_TEXT_UNICODE_REVERSE_STATISTICS    =0x0020,

IS_TEXT_UNICODE_CONTROLS              =0x0004,
IS_TEXT_UNICODE_REVERSE_CONTROLS      =0x0040,

IS_TEXT_UNICODE_SIGNATURE             =0x0008,
IS_TEXT_UNICODE_REVERSE_SIGNATURE     =0x0080,

IS_TEXT_UNICODE_ILLEGAL_CHARS         =0x0100,
IS_TEXT_UNICODE_ODD_LENGTH            =0x0200,
IS_TEXT_UNICODE_DBCS_LEADBYTE         =0x0400,
IS_TEXT_UNICODE_NULL_BYTES            =0x1000,

IS_TEXT_UNICODE_UNICODE_MASK          =0x000F,
IS_TEXT_UNICODE_REVERSE_MASK          =0x00F0,
IS_TEXT_UNICODE_NOT_UNICODE_MASK      =0x0F00,
IS_TEXT_UNICODE_NOT_ASCII_MASK        =0xF000
}

enum {
COMPRESSION_FORMAT_NONE          =(0x0000),   
COMPRESSION_FORMAT_DEFAULT       =(0x0001),   
COMPRESSION_FORMAT_LZNT1         =(0x0002),   
COMPRESSION_ENGINE_STANDARD      =(0x0000),
COMPRESSION_ENGINE_MAXIMUM       =(0x0100)   
}

/*
#if defined(_M_IX86) || defined(_M_MRX000) || defined(_M_ALPHA)

#if defined(_M_MRX000)
NTSYSAPI
DWORD
NTAPI
RtlEqualMemory (
    CONST VOID *Source1,
    CONST VOID *Source2,
    DWORD Length
    );

#else
#define RtlEqualMemory(Destination,Source,Length) (!memcmp((Destination),(Source),(Length)))
#endif

#define RtlMoveMemory(Destination,Source,Length) memmove((Destination),(Source),(Length))
#define RtlCopyMemory(Destination,Source,Length) memcpy((Destination),(Source),(Length))
#define RtlFillMemory(Destination,Length,Fill) memset((Destination),(Fill),(Length))
#define RtlZeroMemory(Destination,Length) memset((Destination),0,(Length))

#else // _M_PPC

NTSYSAPI
DWORD
NTAPI
RtlEqualMemory (
    CONST VOID *Source1,
    CONST VOID *Source2,
    DWORD Length
    );

NTSYSAPI
VOID
NTAPI
RtlCopyMemory (
   VOID UNALIGNED *Destination,
   CONST VOID UNALIGNED *Source,
   DWORD Length
   );

NTSYSAPI
VOID
NTAPI
RtlCopyMemory32 (
   VOID UNALIGNED *Destination,
   CONST VOID UNALIGNED *Source,
   DWORD Length
   );

NTSYSAPI
VOID
NTAPI
RtlMoveMemory (
   VOID UNALIGNED *Destination,
   CONST VOID UNALIGNED *Source,
   DWORD Length
   );

NTSYSAPI
VOID
NTAPI
RtlFillMemory (
   VOID UNALIGNED *Destination,
   DWORD Length,
   BYTE  Fill
   );

NTSYSAPI
VOID
NTAPI
RtlZeroMemory (
   VOID UNALIGNED *Destination,
   DWORD Length
   );
#endif
*/

struct MESSAGE_RESOURCE_ENTRY {
    WORD   Length;
    WORD   Flags;
    BYTE  Text[ 1 ];
} 
alias MESSAGE_RESOURCE_ENTRY * PMESSAGE_RESOURCE_ENTRY;

enum { MESSAGE_RESOURCE_UNICODE  = 0x0001 }

struct MESSAGE_RESOURCE_BLOCK {
    DWORD LowId;
    DWORD HighId;
    DWORD OffsetToEntries;
} 
alias MESSAGE_RESOURCE_BLOCK * PMESSAGE_RESOURCE_BLOCK;

struct MESSAGE_RESOURCE_DATA {
    DWORD NumberOfBlocks;
    MESSAGE_RESOURCE_BLOCK Blocks[ 1 ];
} 
alias MESSAGE_RESOURCE_DATA * PMESSAGE_RESOURCE_DATA;


struct RTL_CRITICAL_SECTION_DEBUG {
    WORD   Type;
    WORD   CreatorBackTraceIndex;
    RTL_CRITICAL_SECTION * CriticalSection;
    LIST_ENTRY ProcessLocksList;
    DWORD EntryCount;
    DWORD ContentionCount;
    DWORD Spare[ 2 ];
} 
alias RTL_CRITICAL_SECTION_DEBUG * PRTL_CRITICAL_SECTION_DEBUG;

enum { 
RTL_CRITSECT_TYPE =0,
RTL_RESOURCE_TYPE =1
}

struct RTL_CRITICAL_SECTION {
    PRTL_CRITICAL_SECTION_DEBUG DebugInfo;

    //
    //  The following three fields control entering and exiting the critical
    //  section for the resource
    //

    LONG LockCount;
    LONG RecursionCount;
    HANDLE OwningThread;        // from the thread's ClientId->UniqueThread
    HANDLE LockSemaphore;
    DWORD Reserved;
}
alias RTL_CRITICAL_SECTION * PRTL_CRITICAL_SECTION;

enum {
DLL_PROCESS_ATTACH =1,
DLL_THREAD_ATTACH  =2,    
DLL_THREAD_DETACH  =3,    
DLL_PROCESS_DETACH =0
}

enum {
//
// Defines for the READ flags for Eventlogging
//
EVENTLOG_SEQUENTIAL_READ        =0X0001,
EVENTLOG_SEEK_READ              =0X0002,
EVENTLOG_FORWARDS_READ          =0X0004,
EVENTLOG_BACKWARDS_READ         =0X0008,

//
// The types of events that can be logged.
//
EVENTLOG_SUCCESS                =0X0000,
EVENTLOG_ERROR_TYPE             =0x0001,
EVENTLOG_WARNING_TYPE           =0x0002,
EVENTLOG_INFORMATION_TYPE       =0x0004,
EVENTLOG_AUDIT_SUCCESS          =0x0008,
EVENTLOG_AUDIT_FAILURE          =0x0010,

//
// Defines for the WRITE flags used by Auditing for paired events
// These are not implemented in Product 1
//
EVENTLOG_START_PAIRED_EVENT    =0x0001,
EVENTLOG_END_PAIRED_EVENT      =0x0002,
EVENTLOG_END_ALL_PAIRED_EVENTS =0x0004,
EVENTLOG_PAIRED_EVENT_ACTIVE   =0x0008,
EVENTLOG_PAIRED_EVENT_INACTIVE =0x0010
}
//
// Structure that defines the header of the Eventlog record. This is the
// fixed-sized portion before all the variable-length strings, binary
// data and pad bytes.
//
// TimeGenerated is the time it was generated at the client.
// TimeWritten is the time it was put into the log at the server end.
//

struct EVENTLOGRECORD {
    DWORD  Length;        // Length of full record
    DWORD  Reserved;      // Used by the service
    DWORD  RecordNumber;  // Absolute record number
    DWORD  TimeGenerated; // Seconds since 1-1-1970
    DWORD  TimeWritten;   // Seconds since 1-1-1970
    DWORD  EventID;
    WORD   EventType;
    WORD   NumStrings;
    WORD   EventCategory;
    WORD   ReservedFlags; // For use with paired events (auditing)
    DWORD  ClosingRecordNumber; // For use with paired events (auditing)
    DWORD  StringOffset;  // Offset from beginning of record
    DWORD  UserSidLength;
    DWORD  UserSidOffset;
    DWORD  DataLength;
    DWORD  DataOffset;    // Offset from beginning of record
    //
    // Then follow:
    //
    // WCHAR SourceName[]
    // WCHAR Computername[]
    // SID   UserSid
    // WCHAR Strings[]
    // BYTE  Data[]
    // CHAR  Pad[]
    // DWORD Length;
    //
} 
alias EVENTLOGRECORD * PEVENTLOGRECORD;

enum : uint { 
DBG_CONTINUE                    =((DWORD   )0x00010002L),
DBG_TERMINATE_THREAD            =((DWORD   )0x40010003L),
DBG_TERMINATE_PROCESS           =((DWORD   )0x40010004L),
DBG_CONTROL_C                   =((DWORD   )0x40010005L), 
DBG_CONTROL_BREAK               =((DWORD   )0x40010008L), 
DBG_EXCEPTION_NOT_HANDLED       =((DWORD   )0x80010001L)
}

//
// Registry Specific Access Rights.
//
enum { 
KEY_QUERY_VALUE         =(0x0001),
KEY_SET_VALUE           =(0x0002),
KEY_CREATE_SUB_KEY      =(0x0004),
KEY_ENUMERATE_SUB_KEYS  =(0x0008),
KEY_NOTIFY              =(0x0010),
KEY_CREATE_LINK         =(0x0020),
KEY_READ                =((STANDARD_RIGHTS_READ          |
                                  KEY_QUERY_VALUE        |
                                  KEY_ENUMERATE_SUB_KEYS |
                                  KEY_NOTIFY)                 
                                  &                           
                                 (~SYNCHRONIZE)),


KEY_WRITE               =((STANDARD_RIGHTS_WRITE      |
                                  KEY_SET_VALUE       |
                                  KEY_CREATE_SUB_KEY)         
                                  &                           
                                 (~SYNCHRONIZE)),
/*
KEY_EXECUTE             = ((KEY_READ)&(~SYNCHRONIZE)),
*/
KEY_ALL_ACCESS          = ((STANDARD_RIGHTS_ALL        |
                                  KEY_QUERY_VALUE            |
                                  KEY_SET_VALUE              |
                                  KEY_CREATE_SUB_KEY         |
                                  KEY_ENUMERATE_SUB_KEYS     |
                                  KEY_NOTIFY                 |
                                  KEY_CREATE_LINK)            
                                  &                           
                                 (~SYNCHRONIZE))
}

enum {
//
// Open/Create Options
//
REG_OPTION_RESERVED         =(0x00000000L),  // Parameter is reserved

REG_OPTION_NON_VOLATILE     =(0x00000000L),  // Key is preserved
                                                    // when system is rebooted

REG_OPTION_VOLATILE         =(0x00000001L),  // Key is not preserved
                                                    // when system is rebooted

REG_OPTION_CREATE_LINK      =(0x00000002L),   // Created key is a
                                                    // symbolic link

REG_OPTION_BACKUP_RESTORE   =(0x00000004L),   // open for backup or restore
                                                    // special access rules
                                                    // privilege required

REG_OPTION_OPEN_LINK        =(0x00000008L),   // Open symbolic link

REG_LEGAL_OPTION            =
                (REG_OPTION_RESERVED            |
                 REG_OPTION_NON_VOLATILE        |
                 REG_OPTION_VOLATILE            |
                 REG_OPTION_CREATE_LINK         |
                 REG_OPTION_BACKUP_RESTORE      |
                 REG_OPTION_OPEN_LINK),

//
// Key creation/open disposition
//

REG_CREATED_NEW_KEY         =(0x00000001L),   // New Registry Key created
REG_OPENED_EXISTING_KEY     =(0x00000002L),  // Existing Key opened

//
// Key restore flags
//

REG_WHOLE_HIVE_VOLATILE     =(0x00000001L),   // Restore whole hive volatile
REG_REFRESH_HIVE            =(0x00000002L),   // Unwind changes to last flush
REG_NO_LAZY_FLUSH           =(0x00000004L),   // Never lazy flush this hive


//
// Notify filter values
//
REG_NOTIFY_CHANGE_NAME          =(0x00000001L), // Create or delete (child)
REG_NOTIFY_CHANGE_ATTRIBUTES    =(0x00000002L),
REG_NOTIFY_CHANGE_LAST_SET      =(0x00000004L), // time stamp
REG_NOTIFY_CHANGE_SECURITY      =(0x00000008L),

REG_LEGAL_CHANGE_FILTER         =        
                (REG_NOTIFY_CHANGE_NAME         |
                 REG_NOTIFY_CHANGE_ATTRIBUTES   |
                 REG_NOTIFY_CHANGE_LAST_SET      |
                 REG_NOTIFY_CHANGE_SECURITY)
}

enum {
//
// Predefined Value Types.
//
REG_NONE                    =( 0 ),   // No value type
REG_SZ                      =( 1 ),   // Unicode nul terminated string
REG_EXPAND_SZ               =( 2 ),   // Unicode nul terminated string
                                            // (with environment variable references)
REG_BINARY                  =( 3 ),   // Free form binary
REG_DWORD                   =( 4 ),   // 32-bit number
REG_DWORD_LITTLE_ENDIAN     =( 4 ),   // 32-bit number (same as REG_DWORD)
REG_DWORD_BIG_ENDIAN        =( 5 ),   // 32-bit number
REG_LINK                    =( 6 ),   // Symbolic Link (unicode)
REG_MULTI_SZ                =( 7 ),   // Multiple Unicode strings
REG_RESOURCE_LIST           =( 8 ) ,  // Resource list in the resource map
REG_FULL_RESOURCE_DESCRIPTOR =( 9 ),  // Resource list in the hardware description
REG_RESOURCE_REQUIREMENTS_LIST =( 10 )
}

enum {
//
// Service Types (Bit Mask)
//
SERVICE_KERNEL_DRIVER          =0x00000001,
SERVICE_FILE_SYSTEM_DRIVER     =0x00000002,
SERVICE_ADAPTER                =0x00000004,
SERVICE_RECOGNIZER_DRIVER      =0x00000008,

SERVICE_DRIVER                 =(SERVICE_KERNEL_DRIVER |
                                        SERVICE_FILE_SYSTEM_DRIVER |
                                        SERVICE_RECOGNIZER_DRIVER),

SERVICE_WIN32_OWN_PROCESS      =0x00000010,
SERVICE_WIN32_SHARE_PROCESS    =0x00000020,
SERVICE_WIN32                  =(SERVICE_WIN32_OWN_PROCESS | 
                                        SERVICE_WIN32_SHARE_PROCESS),

SERVICE_INTERACTIVE_PROCESS    =0x00000100,

SERVICE_TYPE_ALL               =(SERVICE_WIN32  | 
                                        SERVICE_ADAPTER | 
                                        SERVICE_DRIVER  | 
                                        SERVICE_INTERACTIVE_PROCESS)
}

enum {
//
// Start Type
//
SERVICE_BOOT_START             =0x00000000,
SERVICE_SYSTEM_START           =0x00000001,
SERVICE_AUTO_START             =0x00000002,
SERVICE_DEMAND_START           =0x00000003,
SERVICE_DISABLED               =0x00000004
}

enum {
//
// Error control type
//
SERVICE_ERROR_IGNORE           =0x00000000,
SERVICE_ERROR_NORMAL           =0x00000001,
SERVICE_ERROR_SEVERE           =0x00000002,
SERVICE_ERROR_CRITICAL         =0x00000003
}

//
//
// Define the registry driver node enumerations
//

enum SERVICE_NODE_TYPE {
    DriverType               = SERVICE_KERNEL_DRIVER,
    FileSystemType           = SERVICE_FILE_SYSTEM_DRIVER,
    Win32ServiceOwnProcess   = SERVICE_WIN32_OWN_PROCESS,
    Win32ServiceShareProcess = SERVICE_WIN32_SHARE_PROCESS,
    AdapterType              = SERVICE_ADAPTER,
    RecognizerType           = SERVICE_RECOGNIZER_DRIVER
} 

enum SERVICE_LOAD_TYPE {
    BootLoad    = SERVICE_BOOT_START,
    SystemLoad  = SERVICE_SYSTEM_START,
    AutoLoad    = SERVICE_AUTO_START,
    DemandLoad  = SERVICE_DEMAND_START,
    DisableLoad = SERVICE_DISABLED
} 

enum ERROR_CONTROL_TYPE {
    IgnoreError   = SERVICE_ERROR_IGNORE,
    NormalError   = SERVICE_ERROR_NORMAL,
    SevereError   = SERVICE_ERROR_SEVERE,
    CriticalError = SERVICE_ERROR_CRITICAL
} 

enum : uint { 
//
// IOCTL_TAPE_ERASE definitions
//
TAPE_ERASE_SHORT            =0,
TAPE_ERASE_LONG             =1
}

struct TAPE_ERASE {
    DWORD Type;
    BOOLEAN Immediate;
} 
alias TAPE_ERASE * PTAPE_ERASE;

enum : uint {
//
// IOCTL_TAPE_PREPARE definitions
//
TAPE_LOAD                   =0,
TAPE_UNLOAD                 =1,
TAPE_TENSION                =2,
TAPE_LOCK                   =3,
TAPE_UNLOCK                 =4,
TAPE_FORMAT                 =5
}

struct TAPE_PREPARE {
    DWORD Operation;
    BOOLEAN Immediate;
} 
alias TAPE_PREPARE * PTAPE_PREPARE;

enum : uint {
//
// IOCTL_TAPE_WRITE_MARKS definitions
//
TAPE_SETMARKS               =0,
TAPE_FILEMARKS              =1,
TAPE_SHORT_FILEMARKS        =2,
TAPE_LONG_FILEMARKS         =3
}

struct TAPE_WRITE_MARKS {
    DWORD Type;
    DWORD Count;
    BOOLEAN Immediate;
} 
alias TAPE_WRITE_MARKS * PTAPE_WRITE_MARKS;

enum {
//
// IOCTL_TAPE_GET_POSITION definitions
//
TAPE_ABSOLUTE_POSITION       =0,
TAPE_LOGICAL_POSITION        =1,
TAPE_PSEUDO_LOGICAL_POSITION =2
}

struct TAPE_GET_POSITION {
    DWORD Type;
    DWORD Partition;
    LARGE_INTEGER Offset;
} 
alias TAPE_GET_POSITION * PTAPE_GET_POSITION;

enum {
//
// IOCTL_TAPE_SET_POSITION definitions
//
TAPE_REWIND                 =0,
TAPE_ABSOLUTE_BLOCK         =1,
TAPE_LOGICAL_BLOCK          =2,
TAPE_PSEUDO_LOGICAL_BLOCK   =3,
TAPE_SPACE_END_OF_DATA      =4,
TAPE_SPACE_RELATIVE_BLOCKS  =5,
TAPE_SPACE_FILEMARKS        =6,
TAPE_SPACE_SEQUENTIAL_FMKS  =7,
TAPE_SPACE_SETMARKS         =8,
TAPE_SPACE_SEQUENTIAL_SMKS  =9
}

struct TAPE_SET_POSITION {
    DWORD Method;
    DWORD Partition;
    LARGE_INTEGER Offset;
    BOOLEAN Immediate;
} 
alias TAPE_SET_POSITION * PTAPE_SET_POSITION;

//
// IOCTL_TAPE_GET_DRIVE_PARAMS definitions
//

//
// Definitions for FeaturesLow parameter
//
enum : uint {
TAPE_DRIVE_FIXED            =0x00000001,
TAPE_DRIVE_SELECT           =0x00000002,
TAPE_DRIVE_INITIATOR        =0x00000004,

TAPE_DRIVE_ERASE_SHORT      =0x00000010,
TAPE_DRIVE_ERASE_LONG       =0x00000020,
TAPE_DRIVE_ERASE_BOP_ONLY   =0x00000040,
TAPE_DRIVE_ERASE_IMMEDIATE  =0x00000080,

TAPE_DRIVE_TAPE_CAPACITY    =0x00000100,
TAPE_DRIVE_TAPE_REMAINING   =0x00000200,
TAPE_DRIVE_FIXED_BLOCK      =0x00000400,
TAPE_DRIVE_VARIABLE_BLOCK   =0x00000800,

TAPE_DRIVE_WRITE_PROTECT    =0x00001000,
TAPE_DRIVE_EOT_WZ_SIZE      =0x00002000,

TAPE_DRIVE_ECC              =0x00010000,
TAPE_DRIVE_COMPRESSION      =0x00020000,
TAPE_DRIVE_PADDING          =0x00040000,
TAPE_DRIVE_REPORT_SMKS      =0x00080000,

TAPE_DRIVE_GET_ABSOLUTE_BLK =0x00100000,
TAPE_DRIVE_GET_LOGICAL_BLK  =0x00200000,
TAPE_DRIVE_SET_EOT_WZ_SIZE  =0x00400000,

TAPE_DRIVE_EJECT_MEDIA      =0x01000000,

TAPE_DRIVE_RESERVED_BIT     =0x80000000,  //don't use this bit!
//                                              //can't be a low features bit!
//                                              //reserved; high features only

//
// Definitions for FeaturesHigh parameter
//

TAPE_DRIVE_LOAD_UNLOAD      =0x80000001,
TAPE_DRIVE_TENSION          =0x80000002,
TAPE_DRIVE_LOCK_UNLOCK      =0x80000004,
TAPE_DRIVE_REWIND_IMMEDIATE =0x80000008,

TAPE_DRIVE_SET_BLOCK_SIZE   =0x80000010,
TAPE_DRIVE_LOAD_UNLD_IMMED  =0x80000020,
TAPE_DRIVE_TENSION_IMMED    =0x80000040,
TAPE_DRIVE_LOCK_UNLK_IMMED  =0x80000080,

TAPE_DRIVE_SET_ECC          =0x80000100,
TAPE_DRIVE_SET_COMPRESSION  =0x80000200,
TAPE_DRIVE_SET_PADDING      =0x80000400,
TAPE_DRIVE_SET_REPORT_SMKS  =0x80000800,

TAPE_DRIVE_ABSOLUTE_BLK     =0x80001000,
TAPE_DRIVE_ABS_BLK_IMMED    =0x80002000,
TAPE_DRIVE_LOGICAL_BLK      =0x80004000,
TAPE_DRIVE_LOG_BLK_IMMED    =0x80008000,

TAPE_DRIVE_END_OF_DATA      =0x80010000,
TAPE_DRIVE_RELATIVE_BLKS    =0x80020000,
TAPE_DRIVE_FILEMARKS        =0x80040000,
TAPE_DRIVE_SEQUENTIAL_FMKS  =0x80080000,

TAPE_DRIVE_SETMARKS         =0x80100000,
TAPE_DRIVE_SEQUENTIAL_SMKS  =0x80200000,
TAPE_DRIVE_REVERSE_POSITION =0x80400000,
TAPE_DRIVE_SPACE_IMMEDIATE  =0x80800000,

TAPE_DRIVE_WRITE_SETMARKS   =0x81000000,
TAPE_DRIVE_WRITE_FILEMARKS  =0x82000000,
TAPE_DRIVE_WRITE_SHORT_FMKS =0x84000000,
TAPE_DRIVE_WRITE_LONG_FMKS  =0x88000000,

TAPE_DRIVE_WRITE_MARK_IMMED =0x90000000,
TAPE_DRIVE_FORMAT           =0xA0000000,
TAPE_DRIVE_FORMAT_IMMEDIATE =0xC0000000,
TAPE_DRIVE_HIGH_FEATURES    =0x80000000  //mask for high features flag
}

struct TAPE_GET_DRIVE_PARAMETERS {
    BOOLEAN ECC;
    BOOLEAN Compression;
    BOOLEAN DataPadding;
    BOOLEAN ReportSetmarks;
    DWORD DefaultBlockSize;
    DWORD MaximumBlockSize;
    DWORD MinimumBlockSize;
    DWORD MaximumPartitionCount;
    DWORD FeaturesLow;
    DWORD FeaturesHigh;
    DWORD EOTWarningZoneSize;
} 
alias TAPE_GET_DRIVE_PARAMETERS * PTAPE_GET_DRIVE_PARAMETERS;

//
// IOCTL_TAPE_SET_DRIVE_PARAMETERS definitions
//

struct TAPE_SET_DRIVE_PARAMETERS {
    BOOLEAN ECC;
    BOOLEAN Compression;
    BOOLEAN DataPadding;
    BOOLEAN ReportSetmarks;
    DWORD EOTWarningZoneSize;
} 
alias TAPE_SET_DRIVE_PARAMETERS * PTAPE_SET_DRIVE_PARAMETERS;

//
// IOCTL_TAPE_GET_MEDIA_PARAMETERS definitions
//

struct TAPE_GET_MEDIA_PARAMETERS {
    LARGE_INTEGER Capacity;
    LARGE_INTEGER Remaining;
    DWORD BlockSize;
    DWORD PartitionCount;
    BOOLEAN WriteProtected;
} 
alias TAPE_GET_MEDIA_PARAMETERS * PTAPE_GET_MEDIA_PARAMETERS;

//
// IOCTL_TAPE_SET_MEDIA_PARAMETERS definitions
//

struct TAPE_SET_MEDIA_PARAMETERS {
    DWORD BlockSize;
} 
alias TAPE_SET_MEDIA_PARAMETERS * PTAPE_SET_MEDIA_PARAMETERS;

enum {
//
// IOCTL_TAPE_CREATE_PARTITION definitions
//
TAPE_FIXED_PARTITIONS       =0,
TAPE_SELECT_PARTITIONS      =1,
TAPE_INITIATOR_PARTITIONS   =2
}

struct TAPE_CREATE_PARTITION {
    DWORD Method;
    DWORD Count;
    DWORD Size;
} 
alias TAPE_CREATE_PARTITION * PTAPE_CREATE_PARTITION;

} // extern (Windows)
