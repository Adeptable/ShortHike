module winuser;
/*
 * WinUser.d a D port of Microsofts WinUser.h
 * this assumes WINVER >= 0x0400 (win95+)
 * 
 * currently this does not compiler is is incomplete.
 * 
 */

 import wingdi;

/****************************************************************************
* winuser.h -- USER procedure declarations, constant definitions and macros *
* Copyright (c) 1985-1996, Microsoft Corp. All rights reserved.             *
****************************************************************************/
extern (Windows)
{
typedef HANDLE HDWP;
typedef VOID MENUTEMPLATEA;
typedef VOID MENUTEMPLATEW;

typedef PVOID LPMENUTEMPLATEA;
typedef PVOID LPMENUTEMPLATEW;

//alias LRESULT (* WNDPROC)(HWND, UINT, WPARAM, LPARAM);
alias BOOL (* DLGPROC)(HWND, UINT, WPARAM, LPARAM);
alias VOID (* TIMERPROC)(HWND, UINT, UINT, DWORD);
alias BOOL (* GRAYSTRINGPROC)(HDC, LPARAM, int);
alias BOOL (* WNDENUMPROC)(HWND, LPARAM);
alias LRESULT (* HOOKPROC)(int code, WPARAM wParam, LPARAM lParam);
alias VOID (* SENDASYNCPROC)(HWND, UINT, DWORD, LRESULT);
alias BOOL (* PROPENUMPROCA)(HWND, LPCSTR, HANDLE);
alias BOOL (* PROPENUMPROCW)(HWND, LPCWSTR, HANDLE);
alias BOOL (* PROPENUMPROCEXA)(HWND, LPSTR, HANDLE, DWORD);
alias BOOL (* PROPENUMPROCEXW)(HWND, LPWSTR, HANDLE, DWORD);
alias int (* EDITWORDBREAKPROCA)(LPSTR lpch, int ichCurrent, int cch, int code);
alias int (* EDITWORDBREAKPROCW)(LPWSTR lpch, int ichCurrent, int cch, int code);

alias BOOL (* NAMEENUMPROCA)(LPSTR, LPARAM);
alias BOOL (* NAMEENUMPROCW)(LPWSTR, LPARAM);

alias NAMEENUMPROCA   WINSTAENUMPROCA;
alias NAMEENUMPROCA   DESKTOPENUMPROCA;
alias NAMEENUMPROCW   WINSTAENUMPROCW;
alias NAMEENUMPROCW   DESKTOPENUMPROCW;

alias BOOL (* DRAWSTATEPROC)(HDC hdc, LPARAM lData, WPARAM wData, int cx, int cy);

/*
 * Predefined Resource Types
 */
/*
#define RT_CURSOR           MAKEINTRESOURCE(1)
#define RT_BITMAP           MAKEINTRESOURCE(2)
#define RT_ICON             MAKEINTRESOURCE(3)
#define RT_MENU             MAKEINTRESOURCE(4)
#define RT_DIALOG           MAKEINTRESOURCE(5)
#define RT_STRING           MAKEINTRESOURCE(6)
#define RT_FONTDIR          MAKEINTRESOURCE(7)
#define RT_FONT             MAKEINTRESOURCE(8)
#define RT_ACCELERATOR      MAKEINTRESOURCE(9)
#define RT_RCDATA           MAKEINTRESOURCE(10)
#define RT_MESSAGETABLE     MAKEINTRESOURCE(11)

#define DIFFERENCE          11
#define RT_GROUP_CURSOR MAKEINTRESOURCE((DWORD)RT_CURSOR + DIFFERENCE)
#define RT_GROUP_ICON   MAKEINTRESOURCE((DWORD)RT_ICON + DIFFERENCE)
#define RT_VERSION      MAKEINTRESOURCE(16)
#define RT_DLGINCLUDE   MAKEINTRESOURCE(17)

version( WIN2K ) {
#define RT_PLUGPLAY     MAKEINTRESOURCE(19)
#define RT_VXD          MAKEINTRESOURCE(20)
#define RT_ANICURSOR    MAKEINTRESOURCE(21)
#define RT_ANIICON      MAKEINTRESOURCE(22)
}
*/

/*
int wvsprintfA(LPSTR,LPCSTR,va_list arglist);
int wvsprintfW(LPWSTR,LPCWSTR,va_list arglist);

version( UNICODE ) {
	int wvsprintf(LPWSTR a,LPCWSTR b, va_list arglist) { wvsprintfW(a,b,arglist); }
} else {
	int wvsprintf(LPSTR a,LPCSTR b, va_list arglist) { wvsprintfA(a,b,arglist); }
}

int wsprintfA(LPSTR, LPCSTR, ...);
int wsprintfW(LPWSTR, LPCWSTR, ...);
*/

enum {
/*
 * Scroll Bar Constants
 */
SB_HORZ             = 0,
SB_VERT             = 1,
SB_CTL              = 2,
SB_BOTH             = 3,

/*
 * Scroll Bar Commands
 */
SB_LINEUP           =0,
SB_LINELEFT         =0,
SB_LINEDOWN         =1,
SB_LINERIGHT        =1,
SB_PAGEUP           =2,
SB_PAGELEFT         =2,
SB_PAGEDOWN         =3,
SB_PAGERIGHT        =3,
SB_THUMBPOSITION    =4,
SB_THUMBTRACK       =5,
SB_TOP              =6,
SB_LEFT             =6,
SB_BOTTOM           =7,
SB_RIGHT            =7,
SB_ENDSCROLL        =8
}


// begin_r_winuser

/*
 * ShowWindow() Commands
 */
enum {
SW_HIDE             =0,
SW_SHOWNORMAL       =1,
SW_NORMAL           =1,
SW_SHOWMINIMIZED    =2,
SW_SHOWMAXIMIZED    =3,
SW_MAXIMIZE         =3,
SW_SHOWNOACTIVATE   =4,
SW_SHOW             =5,
SW_MINIMIZE         =6,
SW_SHOWMINNOACTIVE  =7,
SW_SHOWNA           =8,
SW_RESTORE          =9,
SW_SHOWDEFAULT      =10,
SW_MAX              =10,

/*
 * Old ShowWindow() Commands
 */
HIDE_WINDOW         =0,
SHOW_OPENWINDOW     =1,
SHOW_ICONWINDOW     =2,
SHOW_FULLSCREEN     =3,
SHOW_OPENNOACTIVATE =4,

/*
 * Identifiers for the WM_SHOWWINDOW message
 */
SW_PARENTCLOSING    =1,
SW_OTHERZOOM        =2,
SW_PARENTOPENING    =3,
SW_OTHERUNZOOM      =4
}
// end_r_winuser


enum {
/*
 * WM_KEYUP/DOWN/CHAR HIWORD(lParam) flags
 */
KF_EXTENDED         =0x0100,
KF_DLGMODE          =0x0800,
KF_MENUMODE         =0x1000,
KF_ALTDOWN          =0x2000,
KF_REPEAT           =0x4000,
KF_UP               =0x8000
}
// begin_r_winuser

enum {
/*
 * Virtual Keys, Standard Set
 */
VK_LBUTTON        =0x01,
VK_RBUTTON        =0x02,
VK_CANCEL         =0x03,
VK_MBUTTON        =0x04,    /* NOT contiguous with L & RBUTTON */

VK_BACK           =0x08,
VK_TAB            =0x09,

VK_CLEAR          =0x0C,
VK_RETURN         =0x0D,

VK_SHIFT          =0x10,
VK_CONTROL        =0x11,
VK_MENU           =0x12,
VK_PAUSE          =0x13,
VK_CAPITAL        =0x14,


VK_ESCAPE         =0x1B,

VK_SPACE          =0x20,
VK_PRIOR          =0x21,
VK_NEXT           =0x22,
VK_END            =0x23,
VK_HOME           =0x24,
VK_LEFT           =0x25,
VK_UP             =0x26,
VK_RIGHT          =0x27,
VK_DOWN           =0x28,
VK_SELECT         =0x29,
VK_PRINT          =0x2A,
VK_EXECUTE        =0x2B,
VK_SNAPSHOT       =0x2C,
VK_INSERT         =0x2D,
VK_DELETE         =0x2E,
VK_HELP           =0x2F,

/* VK_0 thru VK_9 are the same as ASCII '0' thru '9' (0x30 - 0x39) */
/* VK_A thru VK_Z are the same as ASCII 'A' thru 'Z' (0x41 - 0x5A) */

VK_LWIN           =0x5B,
VK_RWIN           =0x5C,
VK_APPS           =0x5D,

VK_NUMPAD0        =0x60,
VK_NUMPAD1        =0x61,
VK_NUMPAD2        =0x62,
VK_NUMPAD3        =0x63,
VK_NUMPAD4        =0x64,
VK_NUMPAD5        =0x65,
VK_NUMPAD6        =0x66,
VK_NUMPAD7        =0x67,
VK_NUMPAD8        =0x68,
VK_NUMPAD9        =0x69,
VK_MULTIPLY       =0x6A,
VK_ADD            =0x6B,
VK_SEPARATOR      =0x6C,
VK_SUBTRACT       =0x6D,
VK_DECIMAL        =0x6E,
VK_DIVIDE         =0x6F,
VK_F1             =0x70,
VK_F2             =0x71,
VK_F3             =0x72,
VK_F4             =0x73,
VK_F5             =0x74,
VK_F6             =0x75,
VK_F7             =0x76,
VK_F8             =0x77,
VK_F9             =0x78,
VK_F10            =0x79,
VK_F11            =0x7A,
VK_F12            =0x7B,
VK_F13            =0x7C,
VK_F14            =0x7D,
VK_F15            =0x7E,
VK_F16            =0x7F,
VK_F17            =0x80,
VK_F18            =0x81,
VK_F19            =0x82,
VK_F20            =0x83,
VK_F21            =0x84,
VK_F22            =0x85,
VK_F23            =0x86,
VK_F24            =0x87,

VK_NUMLOCK        =0x90,
VK_SCROLL         =0x91,

/*
 * VK_L* & VK_R* - left and right Alt, Ctrl and Shift virtual keys.
 * Used only as parameters to GetAsyncKeyState() and GetKeyState().
 * No other API or message will distinguish left and right keys in this way.
 */
VK_LSHIFT         =0xA0,
VK_RSHIFT         =0xA1,
VK_LCONTROL       =0xA2,
VK_RCONTROL       =0xA3,
VK_LMENU          =0xA4,
VK_RMENU          =0xA5,

//#if(WINVER >= 0x0400)
VK_PROCESSKEY     =0xE5,
//#endif /* WINVER >= 0x0400 */

VK_ATTN           =0xF6,
VK_CRSEL          =0xF7,
VK_EXSEL          =0xF8,
VK_EREOF          =0xF9,
VK_PLAY           =0xFA,
VK_ZOOM           =0xFB,
VK_NONAME         =0xFC,
VK_PA1            =0xFD,
VK_OEM_CLEAR      =0xFE
}
// end_r_winuser


enum {
/*
 * SetWindowsHook() codes
 */
WH_MIN              =(-1),
WH_MSGFILTER        =(-1),
WH_JOURNALRECORD    =0,
WH_JOURNALPLAYBACK  =1,
WH_KEYBOARD         =2,
WH_GETMESSAGE       =3,
WH_CALLWNDPROC      =4,
WH_CBT              =5,
WH_SYSMSGFILTER     =6,
WH_MOUSE            =7,
WH_HARDWARE         =8,
WH_DEBUG            =9,
WH_SHELL           =10,
WH_FOREGROUNDIDLE  =11,
//#if(WINVER >= 0x0400)
WH_CALLWNDPROCRET  =12,
WH_MAX             =12,
//#else
//WH_MAX            =11
//#endif
WH_MINHOOK         =WH_MIN,
WH_MAXHOOK         =WH_MAX
}

enum {
/*
 * Hook Codes
 */
HC_ACTION          = 0,
HC_GETNEXT         = 1,
HC_SKIP             =2,
HC_NOREMOVE         =3,
HC_NOREM            =HC_NOREMOVE,
HC_SYSMODALON       =4,
HC_SYSMODALOFF      =5

}

enum {
/*
 * CBT Hook Codes
 */
HCBT_MOVESIZE       =0,
HCBT_MINMAX         =1,
HCBT_QS             =2,
HCBT_CREATEWND      =3,
HCBT_DESTROYWND     =4,
HCBT_ACTIVATE       =5,
HCBT_CLICKSKIPPED   =6,
HCBT_KEYSKIPPED     =7,
HCBT_SYSCOMMAND     =8,
HCBT_SETFOCUS       =9
}

/*
 * HCBT_CREATEWND parameters pointed to by lParam
 */
struct CBT_CREATEWNDA
{
    CBT_CREATEWNDA * lpcs;
    HWND           hwndInsertAfter;
} 
alias CBT_CREATEWNDA * LPCBT_CREATEWNDA;

/*
 * HCBT_CREATEWND parameters pointed to by lParam
 */
struct CBT_CREATEWNDW
{
    CBT_CREATEWNDW *lpcs;
    HWND           hwndInsertAfter;
} 
alias CBT_CREATEWNDW * LPCBT_CREATEWNDW;

/*
 * HCBT_ACTIVATE structure pointed to by lParam
 */
struct CBTACTIVATESTRUCT
{
    BOOL    fMouse;
    HWND    hWndActive;
} 
alias CBTACTIVATESTRUCT * LPCBTACTIVATESTRUCT;

enum {
/*
 * WH_MSGFILTER Filter Proc Codes
 */
MSGF_DIALOGBOX      =0,
MSGF_MESSAGEBOX     =1,
MSGF_MENU           =2,
MSGF_MOVE           =3,
MSGF_SIZE           =4,
MSGF_SCROLLBAR      =5,
MSGF_NEXTWINDOW     =6,
MSGF_MAINLOOP       =8,
MSGF_MAX            =8,
MSGF_USER           =4096

}

enum {
/*
 * Shell support
 */
HSHELL_WINDOWCREATED        =1,
HSHELL_WINDOWDESTROYED      =2,
HSHELL_ACTIVATESHELLWINDOW  =3,

//#if(WINVER >= 0x0400)
HSHELL_WINDOWACTIVATED      =4,
HSHELL_GETMINRECT           =5,
HSHELL_REDRAW               =6,
HSHELL_TASKMAN              =7,
HSHELL_LANGUAGE             =8
//#endif /* WINVER >= 0x0400 */
}

/*
 * Message Structure used in Journaling
 */
struct EVENTMSG {
    UINT    message;
    UINT    paramL;
    UINT    paramH;
    DWORD    time;
    HWND     hwnd;
} 
alias EVENTMSG * PEVENTMSGMSG;
alias EVENTMSG * LPEVENTMSGMSG;
alias EVENTMSG * NPEVENTMSGMSG;

//typedef struct tagEVENTMSG *PEVENTMSG, NEAR *NPEVENTMSG, FAR *LPEVENTMSG;

/*
 * Message structure used by WH_CALLWNDPROC
 */
struct CWPSTRUCT {
    LPARAM  lParam;
    WPARAM  wParam;
    UINT    message;
    HWND    hwnd;
} 
alias CWPSTRUCT * PCWPSTRUCT;
alias CWPSTRUCT * NPCWPSTRUCT;
alias CWPSTRUCT * LPCWPSTRUCT;
// , NEAR *NPCWPSTRUCT, FAR *LPCWPSTRUCT;

/*
 * Message structure used by WH_CALLWNDPROCRET
 */
struct CWPRETSTRUCT {
	LRESULT lResult;
	LPARAM  lParam;
	WPARAM  wParam;
	UINT    message;
	HWND    hwnd;
} 
alias CWPRETSTRUCT * PCWPRETSTRUCT;
alias CWPRETSTRUCT * NPCWPRETSTRUCT;
alias CWPRETSTRUCT * LPCWPRETSTRUCT;

/*
 * Structure used by WH_DEBUG
 */
struct DEBUGHOOKINFO {
    DWORD   idThread;
    DWORD   idThreadInstaller;
    LPARAM  lParam;
    WPARAM  wParam;
    int     code;
} 
alias DEBUGHOOKINFO * PDEBUGHOOKINFO;
alias DEBUGHOOKINFO * NPDEBUGHOOKINFO;
alias DEBUGHOOKINFO * LPDEBUGHOOKINFO;

/*
 * Structure used by WH_MOUSE
 */
struct MOUSEHOOKSTRUCT {
    POINT   pt;
    HWND    hwnd;
    UINT    wHitTestCode;
    DWORD   dwExtraInfo;
} 
alias MOUSEHOOKSTRUCT * PMOUSEHOOKSTRUCT;
alias MOUSEHOOKSTRUCT * LPMOUSEHOOKSTRUCT;

/*
 * Structure used by WH_HARDWARE
 */
struct HARDWAREHOOKSTRUCT {
    HWND    hwnd;
    UINT    message;
    WPARAM  wParam;
    LPARAM  lParam;
} 
alias HARDWAREHOOKSTRUCT * LPHARDWAREHOOKSTRUCT;
alias HARDWAREHOOKSTRUCT * PHARDWAREHOOKSTRUCT;

enum {
/*
 * Keyboard Layout API
 */
HKL_PREV            =0,
HKL_NEXT            =1
}

enum {
KLF_ACTIVATE        =0x00000001,
KLF_SUBSTITUTE_OK   =0x00000002,
KLF_UNLOADPREVIOUS  =0x00000004,
KLF_REORDER         =0x00000008,
//#if(WINVER >= 0x0400)
KLF_REPLACELANG     =0x00000010,
KLF_NOTELLSHELL     =0x00000080,
//#endif /* WINVER >= 0x0400 */
}

enum {
/*
 * Size of KeyboardLayoutName (number of characters), including nul terminator
 */
KL_NAMELENGTH       =9,
}

HKL LoadKeyboardLayoutA( LPCSTR pwszKLID, UINT Flags );
HKL LoadKeyboardLayoutW( LPCWSTR pwszKLID, UINT Flags);


HKL ActivateKeyboardLayout(HKL hkl,UINT Flags);
int ToUnicodeEx( UINT wVirtKey,UINT wScanCode,PBYTE lpKeyState,LPWSTR pwszBuff,int cchBuff,UINT wFlags,HKL dwhkl);
BOOL UnloadKeyboardLayout( HKL hkl );

BOOL GetKeyboardLayoutNameA(LPSTR pwszKLID);
BOOL GetKeyboardLayoutNameW(LPWSTR pwszKLID);


int GetKeyboardLayoutList(int nBuff, HKL *lpList );
HKL GetKeyboardLayout(DWORD dwLayout);

enum {
/*
 * Desktop-specific access flags
 */
DESKTOP_READOBJECTS         =0x0001,
DESKTOP_CREATEWINDOW        =0x0002,
DESKTOP_CREATEMENU          =0x0004,
DESKTOP_HOOKCONTROL         =0x0008,
DESKTOP_JOURNALRECORD       =0x0010,
DESKTOP_JOURNALPLAYBACK     =0x0020,
DESKTOP_ENUMERATE           =0x0040,
DESKTOP_WRITEOBJECTS        =0x0080,
DESKTOP_SWITCHDESKTOP       =0x0100
}

enum {
/*
 * Desktop-specific control flags
 */
DF_ALLOWOTHERACCOUNTHOOK    =0x0001
}

HDESK CreateDesktopA( LPSTR lpszDesktop,LPSTR lpszDevice,LPDEVMODEA pDevmode,DWORD dwFlags,DWORD dwDesiredAccess,LPSECURITY_ATTRIBUTES lpsa);
HDESK CreateDesktopW(LPWSTR lpszDesktop,LPWSTR lpszDevice,LPDEVMODEW pDevmode,DWORD dwFlags,DWORD dwDesiredAccess,LPSECURITY_ATTRIBUTES lpsa);

HDESK OpenDesktopA(LPSTR lpszDesktop,DWORD dwFlags,BOOL fInherit,DWORD dwDesiredAccess);
HDESK OpenDesktopW(LPWSTR lpszDesktop,DWORD dwFlags,BOOL fInherit,DWORD dwDesiredAccess);


HDESK OpenInputDesktop(DWORD dwFlags,BOOL fInherit,DWORD dwDesiredAccess);

BOOL EnumDesktopsA(HWINSTA hwinsta,DESKTOPENUMPROCA lpEnumFunc,LPARAM lParam);
BOOL EnumDesktopsW(HWINSTA hwinsta,DESKTOPENUMPROCW lpEnumFunc,LPARAM lParam);

BOOL EnumDesktopWindows( HDESK hDesktop,WNDENUMPROC lpfn,LPARAM lParam);
BOOL SwitchDesktop(HDESK hDesktop);
BOOL SetThreadDesktop(HDESK hDesktop);
BOOL CloseDesktop(HDESK hDesktop);
HDESK GetThreadDesktop(DWORD dwThreadId);

enum {
/*
 * Windowstation-specific access flags
 */
WINSTA_ENUMDESKTOPS         =0x0001,
WINSTA_READATTRIBUTES       =0x0002,
WINSTA_ACCESSCLIPBOARD      =0x0004,
WINSTA_CREATEDESKTOP        =0x0008,
WINSTA_WRITEATTRIBUTES      =0x0010,
WINSTA_ACCESSGLOBALATOMS    =0x0020,
WINSTA_EXITWINDOWS          =0x0040,
WINSTA_ENUMERATE            =0x0100,
WINSTA_READSCREEN           =0x0200
}

enum {
/*
 * Windowstation-specific attribute flags
 */
WSF_VISIBLE                 =0x0001
}

HWINSTA CreateWindowStationA(LPSTR lpwinsta,DWORD dwReserved,DWORD dwDesiredAccess,LPSECURITY_ATTRIBUTES lpsa);
HWINSTA CreateWindowStationW(LPWSTR lpwinsta,DWORD dwReserved,DWORD dwDesiredAccess,LPSECURITY_ATTRIBUTES lpsa);

HWINSTA OpenWindowStationA(LPSTR lpszWinSta,BOOL fInherit,DWORD dwDesiredAccess);
HWINSTA OpenWindowStationW( LPWSTR lpszWinSta,BOOL fInherit,DWORD dwDesiredAccess);

BOOL EnumWindowStationsA(WINSTAENUMPROCA lpEnumFunc,LPARAM lParam);
BOOL EnumWindowStationsW(WINSTAENUMPROCW lpEnumFunc,LPARAM lParam);


BOOL CloseWindowStation(HWINSTA hWinSta);
BOOL SetProcessWindowStation(HWINSTA hWinSta);

HWINSTA GetProcessWindowStation();

BOOL SetUserObjectSecurity(HANDLE hObj,PSECURITY_INFORMATION pSIRequested,PSECURITY_DESCRIPTOR pSID);
BOOL GetUserObjectSecurity(HANDLE hObj,PSECURITY_INFORMATION pSIRequested,PSECURITY_DESCRIPTOR pSID,DWORD nLength,LPDWORD lpnLengthNeeded);

enum {
UOI_FLAGS       =1,
UOI_NAME        =2,
UOI_TYPE        =3,
UOI_USER_SID    =4
}

struct USEROBJECTFLAGS {
    BOOL fInherit;
    BOOL fReserved;
    DWORD dwFlags;
} 
alias USEROBJECTFLAGS * PUSEROBJECTFLAGS;

BOOL GetUserObjectInformationA(HANDLE hObj,int nIndex,PVOID pvInfo,DWORD nLength,LPDWORD lpnLengthNeeded);
BOOL GetUserObjectInformationW(HANDLE hObj,int nIndex,PVOID pvInfo,DWORD nLength,LPDWORD lpnLengthNeeded);

BOOL SetUserObjectInformationA(HANDLE hObj,int nIndex,PVOID pvInfo,DWORD nLength);
BOOL SetUserObjectInformationW(HANDLE hObj,int nIndex,PVOID pvInfo,DWORD nLength);
/*
struct WNDCLASSEXA {
    UINT        cbSize;
    // Win 3.x 
    UINT        style;
    WNDPROC     lpfnWndProc;
    int         cbClsExtra;
    int         cbWndExtra;
    HINSTANCE   hInstance;
    HICON       hIcon;
    HCURSOR     hCursor;
    HBRUSH      hbrBackground;
    LPCSTR      lpszMenuName;
    LPCSTR      lpszClassName;
    /// Win 4.0 
    HICON       hIconSm;
} 
*/
//alias WNDCLASSEXA * PWNDCLASSEXA;
//, NEAR *NPWNDCLASSEXA, FAR *LPWNDCLASSEXA;
//alias WNDCLASSEXA * NPWNDCLASSEXA;
//alias WNDCLASSEXA * LPWNDCLASSEXA;

struct WNDCLASSEXW {
    UINT        cbSize;
    /* Win 3.x */
    UINT        style;
    WNDPROC     lpfnWndProc;
    int         cbClsExtra;
    int         cbWndExtra;
    HINSTANCE   hInstance;
    HICON       hIcon;
    HCURSOR     hCursor;
    HBRUSH      hbrBackground;
    LPCWSTR     lpszMenuName;
    LPCWSTR     lpszClassName;
    /* Win 4.0 */
    HICON       hIconSm;
} 
alias WNDCLASSEXW * PWNDCLASSEXW;
//, NEAR *NPWNDCLASSEXW, FAR *LPWNDCLASSEXW;
alias WNDCLASSEXW * NPWNDCLASSEXW;
alias WNDCLASSEXW * LPWNDCLASSEXW;
/*
struct WNDCLASSA {
    UINT        style;
    WNDPROC     lpfnWndProc;
    int         cbClsExtra;
    int         cbWndExtra;
    HINSTANCE   hInstance;
    HICON       hIcon;
    HCURSOR     hCursor;
    HBRUSH      hbrBackground;
    LPCSTR      lpszMenuName;
    LPCSTR      lpszClassName;
}
*/
//alias WNDCLASSA * PWNDCLASSA,NPWNDCLASSA,LPWNDCLASSA;
//, NEAR *NPWNDCLASSA, FAR *LPWNDCLASSA;

struct WNDCLASSW {
    UINT        style;
    WNDPROC     lpfnWndProc;
    int         cbClsExtra;
    int         cbWndExtra;
    HINSTANCE   hInstance;
    HICON       hIcon;
    HCURSOR     hCursor;
    HBRUSH      hbrBackground;
    LPCWSTR     lpszMenuName;
    LPCWSTR     lpszClassName;
} 
alias WNDCLASSW * PWNDCLASSW,NPWNDCLASSW,LPWNDCLASSW;
//, NEAR *NPWNDCLASSW, FAR *LPWNDCLASSW;
/*
 * Message structure
 */
version( STANDALONE ) {
struct MSG {
    HWND        hwnd;
    UINT        message;
    WPARAM      wParam;
    LPARAM      lParam;
    DWORD       time;
    POINT       pt;
} 
} // version( STANDALONE ) 

alias MSG * PMSG,NPMSG,LPMSG;

/*
#define POINTSTOPOINT(pt, pts)                          \
        { (pt).x = (LONG)(SHORT)LOWORD(*(LONG*)&pts);   \
          (pt).y = (LONG)(SHORT)HIWORD(*(LONG*)&pts); }

#define POINTTOPOINTS(pt)      (MAKELONG((short)((pt).x), (short)((pt).y)))
#define MAKEWPARAM(l, h)      (WPARAM)MAKELONG(l, h)
#define MAKELPARAM(l, h)      (LPARAM)MAKELONG(l, h)
#define MAKELRESULT(l, h)     (LRESULT)MAKELONG(l, h)
*/

enum {
/*
 * Window field offsets for GetWindowLong()
 */
GWL_WNDPROC         =(-4),
GWL_HINSTANCE       =(-6),
GWL_HWNDPARENT      =(-8),
GWL_ID              =(-12),
GWL_STYLE           =(-16),
GWL_EXSTYLE         =(-20),
GWL_USERDATA        =(-21),
}

enum {
/*
 * Class field offsets for GetClassLong()
 */
GCL_MENUNAME        =(-8),
GCL_HBRBACKGROUND   =(-10),
GCL_HCURSOR         =(-12),
GCL_HICON           =(-14),
GCL_HMODULE         =(-16),
GCL_CBWNDEXTRA      =(-18),
GCL_CBCLSEXTRA      =(-20),
GCL_WNDPROC         =(-24),
GCL_STYLE           =(-26),
GCW_ATOM            =(-32),
GCL_HICONSM         =(-34)
}

version( STANDALONE ) {
enum {
/*
 * Window Messages
 */
WM_NULL                         =0x0000,
WM_CREATE                       =0x0001,
WM_DESTROY                      =0x0002,
WM_MOVE                         =0x0003,
WM_SIZE                         =0x0005,

WM_ACTIVATE                     =0x0006,

WM_SETFOCUS                     =0x0007,
WM_KILLFOCUS                    =0x0008,
WM_ENABLE                       =0x000A,
WM_SETREDRAW                    =0x000B,
WM_SETTEXT                      =0x000C,
WM_GETTEXT                      =0x000D,
WM_GETTEXTLENGTH                =0x000E,
WM_PAINT                        =0x000F,
WM_CLOSE                        =0x0010,
WM_QUERYENDSESSION              =0x0011,
WM_QUIT                         =0x0012,
WM_QUERYOPEN                    =0x0013,
WM_ERASEBKGND                   =0x0014,
WM_SYSCOLORCHANGE               =0x0015,
WM_ENDSESSION                   =0x0016,
WM_SHOWWINDOW                   =0x0018,
WM_WININICHANGE                 =0x001A,
WM_SETTINGCHANGE                =WM_WININICHANGE,

WM_DEVMODECHANGE                =0x001B,
WM_ACTIVATEAPP                  =0x001C,
WM_FONTCHANGE                   =0x001D,
WM_TIMECHANGE                   =0x001E,
WM_CANCELMODE                   =0x001F,
WM_SETCURSOR                    =0x0020,
WM_MOUSEACTIVATE                =0x0021,
WM_CHILDACTIVATE                =0x0022,
WM_QUEUESYNC                    =0x0023,

WM_GETMINMAXINFO                =0x0024,

WM_PAINTICON                    =0x0026,
WM_ICONERASEBKGND               =0x0027,
WM_NEXTDLGCTL                   =0x0028,
WM_SPOOLERSTATUS                =0x002A,
WM_DRAWITEM                     =0x002B,
WM_MEASUREITEM                  =0x002C,
WM_DELETEITEM                   =0x002D,
WM_VKEYTOITEM                   =0x002E,
WM_CHARTOITEM                   =0x002F,
WM_SETFONT                      =0x0030,
WM_GETFONT                      =0x0031,
WM_SETHOTKEY                    =0x0032,
WM_GETHOTKEY                    =0x0033,
WM_QUERYDRAGICON                =0x0037,
WM_COMPAREITEM                  =0x0039,

WM_COMPACTING                   =0x0041,
WM_COMMNOTIFY                   =0x0044,  /* no longer suported */
WM_WINDOWPOSCHANGING            =0x0046,
WM_WINDOWPOSCHANGED             =0x0047,

WM_POWER                        =0x0048,

WM_COPYDATA                     =0x004A,
WM_CANCELJOURNAL                =0x004B,
WM_NOTIFY                       =0x004E,
WM_INPUTLANGCHANGEREQUEST       =0x0050,
WM_INPUTLANGCHANGE              =0x0051,
WM_TCARD                        =0x0052,
WM_HELP                         =0x0053,
WM_USERCHANGED                  =0x0054,
WM_NOTIFYFORMAT                 =0x0055,

WM_CONTEXTMENU                  =0x007B,
WM_STYLECHANGING                =0x007C,
WM_STYLECHANGED                 =0x007D,
WM_DISPLAYCHANGE                =0x007E,
WM_GETICON                      =0x007F,
WM_SETICON                      =0x0080,

WM_NCCREATE                     =0x0081,
WM_NCDESTROY                    =0x0082,
WM_NCCALCSIZE                   =0x0083,
WM_NCHITTEST                    =0x0084,
WM_NCPAINT                      =0x0085,
WM_NCACTIVATE                   =0x0086,
WM_GETDLGCODE                   =0x0087,

WM_NCMOUSEMOVE                  =0x00A0,
WM_NCLBUTTONDOWN                =0x00A1,
WM_NCLBUTTONUP                  =0x00A2,
WM_NCLBUTTONDBLCLK              =0x00A3,
WM_NCRBUTTONDOWN                =0x00A4,
WM_NCRBUTTONUP                  =0x00A5,
WM_NCRBUTTONDBLCLK              =0x00A6,
WM_NCMBUTTONDOWN                =0x00A7,
WM_NCMBUTTONUP                  =0x00A8,
WM_NCMBUTTONDBLCLK              =0x00A9,

WM_KEYFIRST                     =0x0100,
WM_KEYDOWN                      =0x0100,
WM_KEYUP                        =0x0101,
WM_CHAR                         =0x0102,
WM_DEADCHAR                     =0x0103,
WM_SYSKEYDOWN                   =0x0104,
WM_SYSKEYUP                     =0x0105,
WM_SYSCHAR                      =0x0106,
WM_SYSDEADCHAR                  =0x0107,
WM_KEYLAST                      =0x0108,

WM_IME_STARTCOMPOSITION         =0x010D,
WM_IME_ENDCOMPOSITION           =0x010E,
WM_IME_COMPOSITION              =0x010F,
WM_IME_KEYLAST                  =0x010F,

WM_INITDIALOG                   =0x0110,
WM_COMMAND                      =0x0111,
WM_SYSCOMMAND                   =0x0112,
WM_TIMER                        =0x0113,
WM_HSCROLL                      =0x0114,
WM_VSCROLL                      =0x0115,
WM_INITMENU                     =0x0116,
WM_INITMENUPOPUP                =0x0117,
WM_MENUSELECT                   =0x011F,
WM_MENUCHAR                     =0x0120,
WM_ENTERIDLE                    =0x0121,

WM_CTLCOLORMSGBOX               =0x0132,
WM_CTLCOLOREDIT                 =0x0133,
WM_CTLCOLORLISTBOX              =0x0134,
WM_CTLCOLORBTN                  =0x0135,
WM_CTLCOLORDLG                  =0x0136,
WM_CTLCOLORSCROLLBAR            =0x0137,
WM_CTLCOLORSTATIC               =0x0138,

WM_MOUSEFIRST                   =0x0200,
WM_MOUSEMOVE                    =0x0200,
WM_LBUTTONDOWN                  =0x0201,
WM_LBUTTONUP                    =0x0202,
WM_LBUTTONDBLCLK                =0x0203,
WM_RBUTTONDOWN                  =0x0204,
WM_RBUTTONUP                    =0x0205,
WM_RBUTTONDBLCLK                =0x0206,
WM_MBUTTONDOWN                  =0x0207,
WM_MBUTTONUP                    =0x0208,
WM_MBUTTONDBLCLK                =0x0209,
WM_MOUSEWHEEL                   =0x020A,
WM_MOUSELAST                    =0x020A,

WM_PARENTNOTIFY                 =0x0210,
WM_ENTERMENULOOP                =0x0211,
WM_EXITMENULOOP                 =0x0212,

WM_NEXTMENU                     =0x0213,
WM_SIZING                       =0x0214,
WM_CAPTURECHANGED               =0x0215,
WM_MOVING                       =0x0216,
WM_POWERBROADCAST               =0x0218,
WM_DEVICECHANGE                 =0x0219,

WM_IME_SETCONTEXT               =0x0281,
WM_IME_NOTIFY                   =0x0282,
WM_IME_CONTROL                  =0x0283,
WM_IME_COMPOSITIONFULL          =0x0284,
WM_IME_SELECT                   =0x0285,
WM_IME_CHAR                     =0x0286,
WM_IME_KEYDOWN                  =0x0290,
WM_IME_KEYUP                    =0x0291,

WM_MDICREATE                    =0x0220,
WM_MDIDESTROY                   =0x0221,
WM_MDIACTIVATE                  =0x0222,
WM_MDIRESTORE                   =0x0223,
WM_MDINEXT                      =0x0224,
WM_MDIMAXIMIZE                  =0x0225,
WM_MDITILE                      =0x0226,
WM_MDICASCADE                   =0x0227,
WM_MDIICONARRANGE               =0x0228,
WM_MDIGETACTIVE                 =0x0229,

WM_MDISETMENU                   =0x0230,
WM_ENTERSIZEMOVE                =0x0231,
WM_EXITSIZEMOVE                 =0x0232,
WM_DROPFILES                    =0x0233,
WM_MDIREFRESHMENU               =0x0234,

WM_MOUSEHOVER                   =0x02A1,
WM_MOUSELEAVE                   =0x02A3,
WM_CUT                          =0x0300,
WM_COPY                         =0x0301,
WM_PASTE                        =0x0302,
WM_CLEAR                        =0x0303,
WM_UNDO                         =0x0304,
WM_RENDERFORMAT                 =0x0305,
WM_RENDERALLFORMATS             =0x0306,
WM_DESTROYCLIPBOARD             =0x0307,
WM_DRAWCLIPBOARD                =0x0308,
WM_PAINTCLIPBOARD               =0x0309,
WM_VSCROLLCLIPBOARD             =0x030A,
WM_SIZECLIPBOARD                =0x030B,
WM_ASKCBFORMATNAME              =0x030C,
WM_CHANGECBCHAIN                =0x030D,
WM_HSCROLLCLIPBOARD             =0x030E,
WM_QUERYNEWPALETTE              =0x030F,
WM_PALETTEISCHANGING            =0x0310,
WM_PALETTECHANGED               =0x0311,
WM_HOTKEY                       =0x0312,
WM_PRINT                        =0x0317,
WM_PRINTCLIENT                  =0x0318,

WM_HANDHELDFIRST                =0x0358,
WM_HANDHELDLAST                 =0x035F,

WM_AFXFIRST                     =0x0360,
WM_AFXLAST                      =0x037F,

WM_PENWINFIRST                  =0x0380,
WM_PENWINLAST                   =0x038F,

/*
 * NOTE: All Message Numbers below 0x0400 are RESERVED.
 *
 * Private Window Messages Start Here:
 */
WM_USER                         =0x0400,

WM_APP                          =0x8000
}
} else { // version( STANDALONE ) 
// Window messages that I use that are not in the D phobos lib
// and messages that are required by this lib and no in the phobos lib
enum {
	WM_USER                     =0x0400
}
}// version( STANDALONE ) 


enum {
/*
 * WM_ACTIVATE state values
 */
WA_INACTIVE     =0,
WA_ACTIVE       =1,
WA_CLICKACTIVE  =2
}
/*
 * Struct pointed to by WM_GETMINMAXINFO lParam
 */
struct MINMAXINFO {
    POINT ptReserved;
    POINT ptMaxSize;
    POINT ptMaxPosition;
    POINT ptMinTrackSize;
    POINT ptMaxTrackSize;
} 
alias MINMAXINFO * PMINMAXINFO;
alias MINMAXINFO * LPMINMAXINFO;

enum {
/*
 * wParam for WM_POWER window message and DRV_POWER driver notification
 */
PWR_OK              =1,
PWR_FAIL            =(-1),
PWR_SUSPENDREQUEST  =1,
PWR_SUSPENDRESUME   =2,
PWR_CRITICALRESUME  =3
}

/*
 * lParam of WM_COPYDATA message points to...
 */
struct COPYDATASTRUCT {
    DWORD dwData;
    DWORD cbData;
    PVOID lpData;
} 
alias COPYDATASTRUCT * PCOPYDATASTRUCT;


enum {
		NFR_ANSI                             =1,
		NFR_UNICODE                          =2,
		NF_QUERY                             =3,
		NF_REQUERY                           =4
}
enum : uint {
		WHEEL_DELTA                     =120,     /* Value for rolling one detent */
		WHEEL_PAGESCROLL                =(uint.max), /* Scroll one page */
}

enum {
	MENULOOP_WINDOW                 =0,
	MENULOOP_POPUP                  =1
}

struct MDINEXTMENU {
    HMENU   hmenuIn;
    HMENU   hmenuNext;
    HWND    hwndNext;
}
alias MDINEXTMENU * PMDINEXTMENU,LPMDINEXTMENU;

enum {
/*  wParam for WM_SIZING message  */
WMSZ_LEFT           =1,
WMSZ_RIGHT          =2,
WMSZ_TOP            =3,
WMSZ_TOPLEFT        =4,
WMSZ_TOPRIGHT       =5,
WMSZ_BOTTOM         =6,
WMSZ_BOTTOMLEFT     =7,
WMSZ_BOTTOMRIGHT    =8
}

enum {
/*
 * WM_SYNCTASK Commands
 */
ST_BEGINSWP         =0,
ST_ENDSWP           =1
}

enum {
/*
 * WM_NCHITTEST and MOUSEHOOKSTRUCT Mouse Position Codes
 */
HTERROR             =(-2),
HTTRANSPARENT       =(-1),
HTNOWHERE           =0,
HTCLIENT            =1,
HTCAPTION           =2,
HTSYSMENU           =3,
HTGROWBOX           =4,
HTSIZE              =HTGROWBOX,
HTMENU              =5,
HTHSCROLL           =6,
HTVSCROLL           =7,
HTMINBUTTON         =8,
HTMAXBUTTON         =9,
HTLEFT              =10,
HTRIGHT             =11,
HTTOP               =12,
HTTOPLEFT           =13,
HTTOPRIGHT          =14,
HTBOTTOM            =15,
HTBOTTOMLEFT        =16,
HTBOTTOMRIGHT       =17,
HTBORDER            =18,

HTOBJECT            =19,
HTCLOSE             =20,
HTHELP              =21,

HTREDUCE            =HTMINBUTTON,
HTZOOM              =HTMAXBUTTON,
HTSIZEFIRST         =HTLEFT,
HTSIZELAST          =HTBOTTOMRIGHT
}

enum {
/*
 * SendMessageTimeout values
 */
SMTO_NORMAL         =0x0000,
SMTO_BLOCK          =0x0001,
SMTO_ABORTIFHUNG    =0x0002
}

enum {
/*
 * WM_MOUSEACTIVATE Return Codes
 */
MA_ACTIVATE         =1,
MA_ACTIVATEANDEAT   =2,
MA_NOACTIVATE       =3,
MA_NOACTIVATEANDEAT =4
}

enum {
/*
 * WM_SETICON / WM_GETICON Type Codes
 */
ICON_SMALL          =0,
ICON_BIG            =1
}

UINT RegisterWindowMessageA(LPCSTR lpString);
UINT RegisterWindowMessageW(LPCWSTR lpString);

enum {
/*
 * WM_SIZE message wParam values
 */
SIZE_RESTORED       =0,
SIZE_MINIMIZED      =1,
SIZE_MAXIMIZED      =2,
SIZE_MAXSHOW        =3,
SIZE_MAXHIDE        =4,
/*
 * Obsolete constant names
 */
SIZENORMAL          =SIZE_RESTORED,
SIZEICONIC          =SIZE_MINIMIZED,
SIZEFULLSCREEN      =SIZE_MAXIMIZED,
SIZEZOOMSHOW        =SIZE_MAXSHOW,
SIZEZOOMHIDE        =SIZE_MAXHIDE
}

// end_r_winuser
/*
 * WM_WINDOWPOSCHANGING/CHANGED struct pointed to by lParam
 */
struct WINDOWPOS {
    HWND    hwnd;
    HWND    hwndInsertAfter;
    int     x;
    int     y;
    int     cx;
    int     cy;
    UINT    flags;
} 
alias WINDOWPOS * LPWINDOWPOS;
alias WINDOWPOS * PWINDOWPOS;

/*
 * WM_NCCALCSIZE parameter structure
 */
struct NCCALCSIZE_PARAMS {
    RECT       rgrc[3];
    PWINDOWPOS lppos;
} 
alias NCCALCSIZE_PARAMS * LPNCCALCSIZE_PARAMS;

enum {
/*
 * WM_NCCALCSIZE "window valid rect" return values
 */
WVR_ALIGNTOP        =0x0010,
WVR_ALIGNLEFT       =0x0020,
WVR_ALIGNBOTTOM     =0x0040,
WVR_ALIGNRIGHT      =0x0080,
WVR_HREDRAW         =0x0100,
WVR_VREDRAW         =0x0200,
WVR_REDRAW          =(WVR_HREDRAW | WVR_VREDRAW),
WVR_VALIDRECTS      =0x0400
}

enum {
/*
 * Key State Masks for Mouse Messages
 */
MK_LBUTTON          =0x0001,
MK_RBUTTON          =0x0002,
MK_SHIFT            =0x0004,
MK_CONTROL          =0x0008,
MK_MBUTTON          =0x0010
}

enum : uint {
	TME_HOVER       =0x00000001,
	TME_LEAVE       =0x00000002,
	TME_QUERY       =0x40000000,
	TME_CANCEL      =0x80000000
}

enum : uint {
	HOVER_DEFAULT   = 0xFFFFFFFF
}

struct TRACKMOUSEEVENT {
		DWORD cbSize;
		DWORD dwFlags;
		HWND  hwndTrack;
		DWORD dwHoverTime;
} 
alias TRACKMOUSEEVENT * LPTRACKMOUSEEVENT;

BOOL TrackMouseEvent(LPTRACKMOUSEEVENT lpEventTrack);

version(STANDALONE) {
enum {
/*
 * Window Styles
 */
WS_OVERLAPPED       =0x00000000,
WS_POPUP            =0x80000000,
WS_CHILD            =0x40000000,
WS_MINIMIZE         =0x20000000,
WS_VISIBLE          =0x10000000,
WS_DISABLED         =0x08000000,
WS_CLIPSIBLINGS     =0x04000000,
WS_CLIPCHILDREN     =0x02000000,
WS_MAXIMIZE         =0x01000000,
WS_CAPTION          =0x00C00000,    // WS_BORDER | WS_DLGFRAME 
WS_BORDER           =0x00800000,
WS_DLGFRAME         =0x00400000,
WS_VSCROLL          =0x00200000,
WS_HSCROLL          =0x00100000,
WS_SYSMENU          =0x00080000,
WS_THICKFRAME       =0x00040000,
WS_GROUP            =0x00020000,
WS_TABSTOP          =0x00010000,

WS_MINIMIZEBOX      =0x00020000,
WS_MAXIMIZEBOX      =0x00010000,

WS_TILED            =WS_OVERLAPPED,
WS_ICONIC           =WS_MINIMIZE,
WS_SIZEBOX          =WS_THICKFRAME,
/*
 * Common Window Styles
 */
WS_OVERLAPPEDWINDOW =(WS_OVERLAPPED|WS_CAPTION|WS_SYSMENU|WS_THICKFRAME|WS_MINIMIZEBOX|WS_MAXIMIZEBOX),
WS_POPUPWINDOW      =(WS_POPUP|WS_BORDER|WS_SYSMENU),
WS_TILEDWINDOW      =WS_OVERLAPPEDWINDOW,
WS_CHILDWINDOW      =(WS_CHILD)
}
} // version(STANDALONE)

enum {
/*
 * Extended Window Styles
 */
WS_EX_DLGMODALFRAME     =0x00000001,
WS_EX_NOPARENTNOTIFY    =0x00000004,
WS_EX_TOPMOST           =0x00000008,
WS_EX_ACCEPTFILES       =0x00000010,
WS_EX_TRANSPARENT       =0x00000020,

WS_EX_MDICHILD          =0x00000040,
WS_EX_TOOLWINDOW        =0x00000080,
WS_EX_WINDOWEDGE        =0x00000100,
WS_EX_CLIENTEDGE        =0x00000200,
WS_EX_CONTEXTHELP       =0x00000400,

WS_EX_RIGHT             =0x00001000,
WS_EX_LEFT              =0x00000000,
WS_EX_RTLREADING        =0x00002000,
WS_EX_LTRREADING        =0x00000000,
WS_EX_LEFTSCROLLBAR     =0x00004000,
WS_EX_RIGHTSCROLLBAR    =0x00000000,

WS_EX_CONTROLPARENT     =0x00010000,
WS_EX_STATICEDGE        =0x00020000,
WS_EX_APPWINDOW         =0x00040000,


WS_EX_OVERLAPPEDWINDOW  =(WS_EX_WINDOWEDGE | WS_EX_CLIENTEDGE),
WS_EX_PALETTEWINDOW     =(WS_EX_WINDOWEDGE | WS_EX_TOOLWINDOW | WS_EX_TOPMOST)
}

version( STANDALONE){
enum {
/*
 * Class styles
 */
CS_VREDRAW          =0x0001,
CS_HREDRAW          =0x0002,
CS_KEYCVTWINDOW     =0x0004,
CS_DBLCLKS          =0x0008,
CS_OWNDC            =0x0020,
CS_CLASSDC          =0x0040,
CS_PARENTDC         =0x0080,
CS_NOKEYCVT         =0x0100,
CS_NOCLOSE          =0x0200,
CS_SAVEBITS         =0x0800,
CS_BYTEALIGNCLIENT  =0x1000,
CS_BYTEALIGNWINDOW  =0x2000,
CS_GLOBALCLASS      =0x4000,
CS_IME              =0x00010000
}
}

enum {
/* WM_PRINT flags */
PRF_CHECKVISIBLE    =0x00000001,
PRF_NONCLIENT       =0x00000002,
PRF_CLIENT          =0x00000004,
PRF_ERASEBKGND      =0x00000008,
PRF_CHILDREN        =0x00000010,
PRF_OWNED           =0x00000020
}
enum {
/* 3D border styles */
BDR_RAISEDOUTER =0x0001,
BDR_SUNKENOUTER =0x0002,
BDR_RAISEDINNER =0x0004,
BDR_SUNKENINNER =0x0008,

BDR_OUTER       =0x0003,
BDR_INNER       =0x000c,
BDR_RAISED      =0x0005,
BDR_SUNKEN      =0x000a,


EDGE_RAISED     =(BDR_RAISEDOUTER | BDR_RAISEDINNER),
EDGE_SUNKEN     =(BDR_SUNKENOUTER | BDR_SUNKENINNER),
EDGE_ETCHED     =(BDR_SUNKENOUTER | BDR_RAISEDINNER),
EDGE_BUMP       =(BDR_RAISEDOUTER | BDR_SUNKENINNER),
}
enum {

/* Border flags */
BF_LEFT         =0x0001,
BF_TOP          =0x0002,
BF_RIGHT        =0x0004,
BF_BOTTOM       =0x0008,

BF_TOPLEFT      =(BF_TOP | BF_LEFT),
BF_TOPRIGHT     =(BF_TOP | BF_RIGHT),
BF_BOTTOMLEFT   =(BF_BOTTOM | BF_LEFT),
BF_BOTTOMRIGHT  =(BF_BOTTOM | BF_RIGHT),
BF_RECT         =(BF_LEFT | BF_TOP | BF_RIGHT | BF_BOTTOM),

BF_DIAGONAL     =0x0010,

// For diagonal lines, the BF_RECT flags specify the end point of the
// vector bounded by the rectangle parameter.
BF_DIAGONAL_ENDTOPRIGHT     =(BF_DIAGONAL | BF_TOP | BF_RIGHT),
BF_DIAGONAL_ENDTOPLEFT      =(BF_DIAGONAL | BF_TOP | BF_LEFT),
BF_DIAGONAL_ENDBOTTOMLEFT   =(BF_DIAGONAL | BF_BOTTOM | BF_LEFT),
BF_DIAGONAL_ENDBOTTOMRIGHT  =(BF_DIAGONAL | BF_BOTTOM | BF_RIGHT),


BF_MIDDLE       =0x0800,  /* Fill in the middle */
BF_SOFT         =0x1000, /* For softer buttons */
BF_ADJUST       =0x2000,  /* Calculate the space left over */
BF_FLAT         =0x4000,  /* For flat rather than 3D borders */
BF_MONO         =0x8000,  /* For monochrome borders */
}


BOOL DrawEdge(HDC hdc, LPRECT qrc, UINT edge, UINT grfFlags);

enum {
/* flags for DrawFrameControl */
DFC_CAPTION             =1,
DFC_MENU                =2,
DFC_SCROLL              =3,
DFC_BUTTON              =4,

DFCS_CAPTIONCLOSE       =0x0000,
DFCS_CAPTIONMIN         =0x0001,
DFCS_CAPTIONMAX         =0x0002,
DFCS_CAPTIONRESTORE     =0x0003,
DFCS_CAPTIONHELP        =0x0004,

DFCS_MENUARROW          =0x0000,
DFCS_MENUCHECK          =0x0001,
DFCS_MENUBULLET         =0x0002,
DFCS_MENUARROWRIGHT     =0x0004,

DFCS_SCROLLUP           =0x0000,
DFCS_SCROLLDOWN         =0x0001,
DFCS_SCROLLLEFT         =0x0002,
DFCS_SCROLLRIGHT        =0x0003,
DFCS_SCROLLCOMBOBOX     =0x0005,
DFCS_SCROLLSIZEGRIP     =0x0008,
DFCS_SCROLLSIZEGRIPRIGHT =0x0010,

DFCS_BUTTONCHECK        =0x0000,
DFCS_BUTTONRADIOIMAGE   =0x0001,
DFCS_BUTTONRADIOMASK    =0x0002,
DFCS_BUTTONRADIO        =0x0004,
DFCS_BUTTON3STATE       =0x0008,
DFCS_BUTTONPUSH         =0x0010,

DFCS_INACTIVE           =0x0100,
DFCS_PUSHED             =0x0200,
DFCS_CHECKED            =0x0400,
DFCS_ADJUSTRECT         =0x2000,
DFCS_FLAT               =0x4000,
DFCS_MONO               =0x8000
}

BOOL DrawFrameControl(HDC, LPRECT, UINT, UINT);

enum {
/* flags for DrawCaption */
DC_ACTIVE           =0x0001,
DC_SMALLCAP         =0x0002,
DC_ICON             =0x0004,
DC_TEXT             =0x0008,
DC_INBUTTON         =0x0010
}

//BOOL DrawCaption(HWND, HDC, CONST RECT *, UINT);
BOOL DrawCaption(HWND, HDC, RECT *, UINT);

enum {
IDANI_OPEN          =1,
IDANI_CLOSE         =2,
IDANI_CAPTION       =3
}

//BOOL DrawAnimatedRects(HWND hwnd, int idAni, CONST RECT * lprcFrom, CONST RECT * lprcTo);
BOOL DrawAnimatedRects(HWND hwnd, int idAni, RECT * lprcFrom, RECT * lprcTo);

enum {
/*
 * Predefined Clipboard Formats
 */
CF_TEXT             =1,
CF_BITMAP           =2,
CF_METAFILEPICT     =3,
CF_SYLK             =4,
CF_DIF              =5,
CF_TIFF             =6,
CF_OEMTEXT          =7,
CF_DIB              =8,
CF_PALETTE          =9,
CF_PENDATA          =10,
CF_RIFF             =11,
CF_WAVE             =12,
CF_UNICODETEXT      =13,
CF_ENHMETAFILE      =14,
CF_HDROP            =15,
CF_LOCALE           =16,
CF_MAX              =17,

CF_OWNERDISPLAY     =0x0080,
CF_DSPTEXT          =0x0081,
CF_DSPBITMAP        =0x0082,
CF_DSPMETAFILEPICT  =0x0083,
CF_DSPENHMETAFILE   =0x008E,

/*
 * "Private" formats don't get GlobalFree()'d
 */
CF_PRIVATEFIRST     =0x0200,
CF_PRIVATELAST      =0x02FF,

/*
 * "GDIOBJ" formats do get DeleteObject()'d
 */
CF_GDIOBJFIRST      =0x0300,
CF_GDIOBJLAST       =0x03FF
}

enum {
/*
 * Defines for the fVirt field of the Accelerator table structure.
 */
FVIRTKEY  =1,          /* Assumed to be == TRUE */
FNOINVERT =0x02,
FSHIFT    =0x04,
FCONTROL  =0x08,
FALT      =0x10,
}

struct ACCEL {
    BYTE   fVirt;               /* Also called the flags field */
    WORD   key;
    WORD   cmd;
} 
alias ACCEL * LPACCEL;
/*
struct PAINTSTRUCT {
    HDC         hdc;
    BOOL        fErase;
    RECT        rcPaint;
    BOOL        fRestore;
    BOOL        fIncUpdate;
    BYTE        rgbReserved[32];
} 
*/
alias PAINTSTRUCT * PPAINTSTRUCT,NPPAINTSTRUCT,LPPAINTSTRUCT;

struct CREATESTRUCTA {
    LPVOID      lpCreateParams;
    HINSTANCE   hInstance;
    HMENU       hMenu;
    HWND        hwndParent;
    int         cy;
    int         cx;
    int         y;
    int         x;
    LONG        style;
    LPCSTR      lpszName;
    LPCSTR      lpszClass;
    DWORD       dwExStyle;
} 
alias CREATESTRUCTA * LPCREATESTRUCTA;

struct CREATESTRUCTW {
    LPVOID      lpCreateParams;
    HINSTANCE   hInstance;
    HMENU       hMenu;
    HWND        hwndParent;
    int         cy;
    int         cx;
    int         y;
    int         x;
    LONG        style;
    LPCWSTR     lpszName;
    LPCWSTR     lpszClass;
    DWORD       dwExStyle;
} 
alias CREATESTRUCTW * LPCREATESTRUCTW;

struct WINDOWPLACEMENT {
    UINT  length;
    UINT  flags;
    UINT  showCmd;
    POINT ptMinPosition;
    POINT ptMaxPosition;
    RECT  rcNormalPosition;
}
alias WINDOWPLACEMENT * PWINDOWPLACEMENT,LPWINDOWPLACEMENT;

enum {
WPF_SETMINPOSITION      =0x0001,
WPF_RESTORETOMAXIMIZED  =0x0002
}

struct NMHDR {
    HWND  hwndFrom;
    UINT  idFrom;
    UINT  code;         // NM_ code
}

alias NMHDR * LPNMHDR;

struct STYLESTRUCT
{
    DWORD   styleOld;
    DWORD   styleNew;
} 
alias STYLESTRUCT * LPSTYLESTRUCT;

enum {
/*
 * Owner draw control types
 */
ODT_MENU        =1,
ODT_LISTBOX     =2,
ODT_COMBOBOX    =3,
ODT_BUTTON      =4,
ODT_STATIC      =5
}

enum {
/*
 * Owner draw actions
 */
ODA_DRAWENTIRE  =0x0001,
ODA_SELECT      =0x0002,
ODA_FOCUS       =0x0004
}

enum {
/*
 * Owner draw state
 */
ODS_SELECTED    =0x0001,
ODS_GRAYED      =0x0002,
ODS_DISABLED    =0x0004,
ODS_CHECKED     =0x0008,
ODS_FOCUS       =0x0010,
ODS_DEFAULT         =0x0020,
ODS_COMBOBOXEDIT    =0x1000
}

/*
 * MEASUREITEMSTRUCT for ownerdraw
 */
struct MEASUREITEMSTRUCT {
    UINT       CtlType;
    UINT       CtlID;
    UINT       itemID;
    UINT       itemWidth;
    UINT       itemHeight;
    DWORD      itemData;
} 
alias MEASUREITEMSTRUCT * PMEASUREITEMSTRUCT,LPMEASUREITEMSTRUCT;

/*
 * DRAWITEMSTRUCT for ownerdraw
 */
struct DRAWITEMSTRUCT {
    UINT        CtlType;
    UINT        CtlID;
    UINT        itemID;
    UINT        itemAction;
    UINT        itemState;
    HWND        hwndItem;
    HDC         hDC;
    RECT        rcItem;
    DWORD       itemData;
} 
alias DRAWITEMSTRUCT * PDRAWITEMSTRUCT,LPDRAWITEMSTRUCT;

/*
 * DELETEITEMSTRUCT for ownerdraw
 */
struct DELETEITEMSTRUCT {
    UINT       CtlType;
    UINT       CtlID;
    UINT       itemID;
    HWND       hwndItem;
    UINT       itemData;
} 
alias DELETEITEMSTRUCT * PDELETEITEMSTRUCT;
alias DELETEITEMSTRUCT * LPDELETEITEMSTRUCT;

/*
 * COMPAREITEMSTUCT for ownerdraw sorting
 */
struct COMPAREITEMSTRUCT {
    UINT        CtlType;
    UINT        CtlID;
    HWND        hwndItem;
    UINT        itemID1;
    DWORD       itemData1;
    UINT        itemID2;
    DWORD       itemData2;
    DWORD       dwLocaleId;
} 
alias COMPAREITEMSTRUCT * PCOMPAREITEMSTRUCT,LPCOMPAREITEMSTRUCT;

/*
 * Message Function Templates
 */
//BOOL GetMessageA(LPMSG lpMsg,HWND hWnd,UINT wMsgFilterMin,UINT wMsgFilterMax);
BOOL GetMessageW(LPMSG lpMsg,HWND hWnd,UINT wMsgFilterMin,UINT wMsgFilterMax);

//BOOL TranslateMessage(CONST MSG *lpMsg);
//LONG DispatchMessageA(CONST MSG *lpMsg);
//LONG DispatchMessageW(CONST MSG *lpMsg);
//BOOL TranslateMessage(MSG *lpMsg);
//LONG DispatchMessageA(MSG *lpMsg);
LONG DispatchMessageW(MSG *lpMsg);

BOOL SetMessageQueue(int cMessagesMax);
//BOOL PeekMessageA(LPMSG lpMsg,HWND hWnd,UINT wMsgFilterMin,UINT wMsgFilterMax,UINT wRemoveMsg);
BOOL PeekMessageW(LPMSG lpMsg,HWND hWnd,UINT wMsgFilterMin,UINT wMsgFilterMax,UINT wRemoveMsg);

enum {
/*
 * PeekMessage() Options
 */
PM_NOREMOVE         =0x0000,
PM_REMOVE           =0x0001,
PM_NOYIELD          =0x0002
}

BOOL RegisterHotKey(HWND hWnd,int id,UINT fsModifiers,UINT vk);
BOOL UnregisterHotKey(HWND hWnd,int id);

enum {
MOD_ALT         =0x0001,
MOD_CONTROL     =0x0002,
MOD_SHIFT       =0x0004,
MOD_WIN         =0x0008
}

enum {
IDHOT_SNAPWINDOW        =(-1),    /* SHIFT-PRINTSCRN  */
IDHOT_SNAPDESKTOP       =(-2)    /* PRINTSCRN        */
}

enum {
EW_RESTARTWINDOWS    =0x0042,
EW_REBOOTSYSTEM      =0x0043,
EW_EXITANDEXECAPP    =0x0044,
}

enum : uint {
ENDSESSION_LOGOFF    =0x80000000,
}

enum {
EWX_LOGOFF   =0,
EWX_SHUTDOWN =1,
EWX_REBOOT   =2,
EWX_FORCE    =4,
EWX_POWEROFF =8,
}


//#define ExitWindows(dwReserved, Code) ExitWindowsEx(EWX_LOGOFF, 0xFFFFFFFF)

BOOL ExitWindowsEx(UINT uFlags,DWORD dwReserved);
BOOL SwapMouseButton(BOOL fSwap);
DWORD GetMessagePos();
LONG GetMessageTime();
LONG GetMessageExtraInfo();

LPARAM SetMessageExtraInfo(LPARAM lParam);

LRESULT SendMessageA(HWND hWnd,UINT Msg,WPARAM wParam,LPARAM lParam);
LRESULT SendMessageW(HWND hWnd,UINT Msg,WPARAM wParam,LPARAM lParam);

LRESULT SendMessageTimeoutA(HWND hWnd,UINT Msg,WPARAM wParam,LPARAM lParam,UINT fuFlags,UINT uTimeout,LPDWORD lpdwResult);
LRESULT SendMessageTimeoutW(HWND hWnd,UINT Msg,WPARAM wParam,LPARAM lParam,UINT fuFlags,UINT uTimeout,LPDWORD lpdwResult);

BOOL SendNotifyMessageA(HWND hWnd,UINT Msg,WPARAM wParam,LPARAM lParam);
BOOL SendNotifyMessageW(HWND hWnd,UINT Msg,WPARAM wParam,LPARAM lParam);

BOOL SendMessageCallbackA(HWND hWnd,UINT Msg,WPARAM wParam,LPARAM lParam,SENDASYNCPROC lpResultCallBack,DWORD dwData);
BOOL SendMessageCallbackW(HWND hWnd,UINT Msg,WPARAM wParam,LPARAM lParam,SENDASYNCPROC lpResultCallBack,DWORD dwData);

long  BroadcastSystemMessageA(DWORD, LPDWORD, UINT, WPARAM, LPARAM);
long  BroadcastSystemMessageW(DWORD, LPDWORD, UINT, WPARAM, LPARAM);

enum {
//Broadcast Special Message Recipient list
BSM_ALLCOMPONENTS       =0x00000000,
BSM_VXDS                =0x00000001,
BSM_NETDRIVER           =0x00000002,
BSM_INSTALLABLEDRIVERS  =0x00000004,
BSM_APPLICATIONS        =0x00000008,
BSM_ALLDESKTOPS         =0x00000010
}

enum {
//Broadcast Special Message Flags
BSF_QUERY               =0x00000001,
BSF_IGNORECURRENTTASK   =0x00000002,
BSF_FLUSHDISK           =0x00000004,
BSF_NOHANG              =0x00000008,
BSF_POSTMESSAGE         =0x00000010,
BSF_FORCEIFHUNG         =0x00000020,
BSF_NOTIMEOUTIFNOTHUNG  =0x00000040
}

struct BROADCASTSYSMSG
{
    UINT    uiMessage;
    WPARAM  wParam;
    LPARAM  lParam;
} 
alias BROADCASTSYSMSG  * LPBROADCASTSYSMSG;

enum {
BROADCAST_QUERY_DENY         =0x424D5144  // Return this value to deny a query.
}

BOOL PostMessageA(HWND hWnd,UINT Msg,WPARAM wParam,LPARAM lParam);
BOOL PostMessageW(HWND hWnd,UINT Msg,WPARAM wParam,LPARAM lParam);

BOOL PostThreadMessageA(DWORD idThread,UINT Msg,WPARAM wParam,LPARAM lParam);
BOOL PostThreadMessageW(DWORD idThread,UINT Msg,WPARAM wParam,LPARAM lParam);

/*
 * Special HWND value for use with PostMessage() and SendMessage()
 */
const HWND HWND_BROADCAST  = ((HWND)0xffff);

BOOL AttachThreadInput(DWORD idAttach,DWORD idAttachTo,BOOL fAttach);
BOOL ReplyMessage(LRESULT lResult);

BOOL WaitMessage();

DWORD WaitForInputIdle(HANDLE hProcess,DWORD dwMilliseconds);

//LRESULT DefWindowProcA(HWND hWnd,UINT Msg,WPARAM wParam,LPARAM lParam);
LRESULT DefWindowProcW(HWND hWnd,UINT Msg,WPARAM wParam,LPARAM lParam);

//VOID PostQuitMessage(int nExitCode);

LRESULT CallWindowProcA(WNDPROC lpPrevWndFunc,HWND hWnd,UINT Msg,WPARAM wParam,LPARAM lParam);
LRESULT CallWindowProcW(WNDPROC lpPrevWndFunc,HWND hWnd,UINT Msg,WPARAM wParam,LPARAM lParam);

BOOL InSendMessage();
UINT GetDoubleClickTime();
BOOL SetDoubleClickTime(UINT);

//ATOM RegisterClassA(CONST WNDCLASSA *lpWndClass);
//ATOM RegisterClassW(CONST WNDCLASSW *lpWndClass);
//ATOM RegisterClassA(WNDCLASSA *lpWndClass);
ATOM RegisterClassW(WNDCLASSW *lpWndClass);

BOOL UnregisterClassA(LPCSTR lpClassName,HINSTANCE hInstance);
BOOL UnregisterClassW(LPCWSTR lpClassName,HINSTANCE hInstance);

BOOL GetClassInfoA(HINSTANCE hInstance,LPCSTR lpClassName,LPWNDCLASSA lpWndClass);
BOOL GetClassInfoW(HINSTANCE hInstance,LPCWSTR lpClassName,LPWNDCLASSW lpWndClass);

//ATOM RegisterClassExA(CONST WNDCLASSEXA *);
//ATOM RegisterClassExW(CONST WNDCLASSEXW *);
ATOM RegisterClassExA(WNDCLASSEXA *);
ATOM RegisterClassExW(WNDCLASSEXW *);

BOOL GetClassInfoExA(HINSTANCE, LPCSTR, LPWNDCLASSEXA);
BOOL GetClassInfoExW(HINSTANCE, LPCWSTR, LPWNDCLASSEXW);

/*
enum : int {
CW_USEDEFAULT        = ((int)0x80000000)
}
*/

/*
 * Special value for CreateWindow, et al.
 */
version( STANDALONE )
{
  const HWND HWND_DESKTOP        = cast(HWND)0;
}

//HWND CreateWindowExA(DWORD dwExStyle,LPCSTR lpClassName,LPCSTR lpWindowName,DWORD dwStyle,int X,int Y,int nWidth,int nHeight,HWND hWndParent,HMENU hMenu,HINSTANCE hInstance,LPVOID lpParam);
HWND CreateWindowExW(DWORD dwExStyle,LPCWSTR lpClassName,LPCWSTR lpWindowName,DWORD dwStyle,int X,int Y,int nWidth,int nHeight,HWND hWndParent,HMENU hMenu,HINSTANCE hInstance,LPVOID lpParam);

BOOL IsWindow(HWND hWnd);
BOOL IsMenu(HMENU hMenu);
BOOL IsChild(HWND hWndParent,HWND hWnd);
BOOL DestroyWindow(HWND hWnd);
BOOL ShowWindow(HWND hWnd,int nCmdShow);
BOOL ShowWindowAsync(HWND hWnd,int nCmdShow);
BOOL FlashWindow(HWND hWnd,BOOL bInvert);
BOOL ShowOwnedPopups(HWND hWnd,BOOL fShow);
BOOL OpenIcon(HWND hWnd);
BOOL CloseWindow(HWND hWnd);

BOOL MoveWindow(HWND hWnd,int X,int Y,int nWidth,int nHeight,BOOL bRepaint);

BOOL SetWindowPos(HWND hWnd,HWND hWndInsertAfter,int X,int Y,int cx,int cy,UINT uFlags);

BOOL GetWindowPlacement(HWND hWnd,WINDOWPLACEMENT *lpwndpl);

//BOOL SetWindowPlacement(HWND hWnd,CONST WINDOWPLACEMENT *lpwndpl);
BOOL SetWindowPlacement(HWND hWnd,WINDOWPLACEMENT *lpwndpl);

HDWP BeginDeferWindowPos(int nNumWindows);

HDWP DeferWindowPos(HDWP hWinPosInfo,HWND hWnd,HWND hWndInsertAfter,int x,int y,int cx,int cy,UINT uFlags);

BOOL EndDeferWindowPos(HDWP hWinPosInfo);

BOOL IsWindowVisible(HWND hWnd);

BOOL IsIconic(HWND hWnd);

BOOL AnyPopup();

BOOL BringWindowToTop(HWND hWnd);

BOOL IsZoomed(HWND hWnd);

enum {
/*
 * SetWindowPos Flags
 */
SWP_NOSIZE          =0x0001,
SWP_NOMOVE          =0x0002,
SWP_NOZORDER        =0x0004,
SWP_NOREDRAW        =0x0008,
SWP_NOACTIVATE      =0x0010,
SWP_FRAMECHANGED    =0x0020, /* The frame changed: send WM_NCCALCSIZE */
SWP_SHOWWINDOW      =0x0040,
SWP_HIDEWINDOW      =0x0080,
SWP_NOCOPYBITS      =0x0100,
SWP_NOOWNERZORDER   =0x0200,  /* Don't do owner Z ordering */
SWP_NOSENDCHANGING  =0x0400,  /* Don't send WM_WINDOWPOSCHANGING */

SWP_DRAWFRAME       =SWP_FRAMECHANGED,
SWP_NOREPOSITION    =SWP_NOOWNERZORDER,

SWP_DEFERERASE      =0x2000,
SWP_ASYNCWINDOWPOS  =0x4000
}

const HWND HWND_TOP        =cast(HWND)0;
const HWND HWND_BOTTOM     =cast(HWND)1;
const HWND HWND_TOPMOST    =cast(HWND)-1;
const HWND HWND_NOTOPMOST  =cast(HWND)-2;

/*
 * WARNING:
 * The following structures must NOT be DWORD padded because they are
 * followed by strings, etc that do not have to be DWORD aligned.
//#include <pshpack2.h>
 */

/*
 * original NT 32 bit dialog template:
 */
struct DLGTEMPLATE {
    DWORD style;
    DWORD dwExtendedStyle;
    WORD cdit;
    short x;
    short y;
    short cx;
    short cy;
} ;
alias DLGTEMPLATE * LPDLGTEMPLATEA,LPCDLGTEMPLATEA;
alias DLGTEMPLATE * LPDLGTEMPLATEW,LPCDLGTEMPLATEW;
alias DLGTEMPLATE * LPDLGTEMPLATE,LPCDLGTEMPLATE;

/*
 * 32 bit Dialog item template.
 */
struct DLGITEMTEMPLATE {
    DWORD style;
    DWORD dwExtendedStyle;
    short x;
    short y;
    short cx;
    short cy;
    WORD id;
} ;
alias DLGITEMTEMPLATE * PDLGITEMTEMPLATEA;
alias DLGITEMTEMPLATE * PDLGITEMTEMPLATEW;
alias DLGITEMTEMPLATE * PDLGITEMTEMPLATE;

alias DLGITEMTEMPLATE * LPDLGITEMTEMPLATEA;
alias DLGITEMTEMPLATE * LPDLGITEMTEMPLATEW;
alias DLGITEMTEMPLATE * LPDLGITEMTEMPLATE;


//#include <poppack.h> /* Resume normal packing */

HWND CreateDialogParamA(HINSTANCE hInstance,LPCSTR lpTemplateName,HWND hWndParent,DLGPROC lpDialogFunc,LPARAM dwInitParam);
HWND CreateDialogParamW(HINSTANCE hInstance,LPCWSTR lpTemplateName,HWND hWndParent,DLGPROC lpDialogFunc,LPARAM dwInitParam);

HWND CreateDialogIndirectParamA(HINSTANCE hInstance,LPCDLGTEMPLATEA lpTemplate,HWND hWndParent,DLGPROC lpDialogFunc,LPARAM dwInitParam);
HWND CreateDialogIndirectParamW(HINSTANCE hInstance,LPCDLGTEMPLATEW lpTemplate,HWND hWndParent,DLGPROC lpDialogFunc,LPARAM dwInitParam);

int DialogBoxParamA(HINSTANCE hInstance,LPCSTR lpTemplateName,HWND hWndParent,DLGPROC lpDialogFunc,LPARAM dwInitParam);
int DialogBoxParamW(HINSTANCE hInstance,LPCWSTR lpTemplateName,HWND hWndParent,DLGPROC lpDialogFunc,LPARAM dwInitParam);

int DialogBoxIndirectParamA(HINSTANCE hInstance,LPCDLGTEMPLATEA hDialogTemplate,HWND hWndParent,DLGPROC lpDialogFunc,LPARAM dwInitParam);
int DialogBoxIndirectParamW(HINSTANCE hInstance,LPCDLGTEMPLATEW hDialogTemplate,HWND hWndParent,DLGPROC lpDialogFunc,LPARAM dwInitParam);

BOOL EndDialog(HWND hDlg,int nResult);
HWND GetDlgItem(HWND hDlg,int nIDDlgItem);
BOOL SetDlgItemInt(HWND hDlg,int nIDDlgItem,UINT uValue,BOOL bSigned);
UINT GetDlgItemInt(HWND hDlg,int nIDDlgItem,BOOL *lpTranslated,BOOL bSigned);

BOOL SetDlgItemTextA(HWND hDlg,int nIDDlgItem,LPCSTR lpString);
BOOL SetDlgItemTextW(HWND hDlg,int nIDDlgItem,LPCWSTR lpString);

UINT GetDlgItemTextA(HWND hDlg,int nIDDlgItem,LPSTR lpString,int nMaxCount);
UINT GetDlgItemTextW(HWND hDlg,int nIDDlgItem,LPWSTR lpString,int nMaxCount);

BOOL CheckDlgButton(HWND hDlg,int nIDButton,UINT uCheck);
BOOL CheckRadioButton(HWND hDlg,int nIDFirstButton,int nIDLastButton,int nIDCheckButton);

UINT IsDlgButtonChecked(HWND hDlg,int nIDButton);

LONG SendDlgItemMessageA(HWND hDlg,int nIDDlgItem,UINT Msg,WPARAM wParam,LPARAM lParam);
LONG SendDlgItemMessageW(HWND hDlg,int nIDDlgItem,UINT Msg,WPARAM wParam,LPARAM lParam);

HWND GetNextDlgGroupItem(HWND hDlg,HWND hCtl,BOOL bPrevious);
HWND GetNextDlgTabItem(HWND hDlg,HWND hCtl,BOOL bPrevious);

int GetDlgCtrlID(HWND hWnd);

long GetDialogBaseUnits();

LRESULT DefDlgProcA(HWND hDlg,UINT Msg,WPARAM wParam,LPARAM lParam);
LRESULT DefDlgProcW(HWND hDlg,UINT Msg,WPARAM wParam,LPARAM lParam);


enum {
/*
 * Window extra byted needed for private dialog classes.
 */
DLGWINDOWEXTRA = 30
}


BOOL CallMsgFilterA(LPMSG lpMsg,int nCode);
BOOL CallMsgFilterW(LPMSG lpMsg,int nCode);


/*
 * Clipboard Manager Functions
 */
BOOL OpenClipboard(HWND hWndNewOwner);
BOOL CloseClipboard();
HWND GetClipboardOwner();
HWND SetClipboardViewer(HWND hWndNewViewer);
HWND GetClipboardViewer();
BOOL ChangeClipboardChain(HWND hWndRemove,HWND hWndNewNext);

HANDLE SetClipboardData(UINT uFormat,HANDLE hMem);
HANDLE GetClipboardData(UINT uFormat);
int CountClipboardFormats();

UINT RegisterClipboardFormatA(LPCSTR lpszFormat);
UINT RegisterClipboardFormatW(LPCWSTR lpszFormat);


UINT EnumClipboardFormats(UINT format);

int GetClipboardFormatNameA(UINT format,LPSTR lpszFormatName,int cchMaxCount);
int GetClipboardFormatNameW(UINT format,LPWSTR lpszFormatName,int cchMaxCount);

BOOL EmptyClipboard();
BOOL IsClipboardFormatAvailable(UINT format);
int GetPriorityClipboardFormat(UINT *paFormatPriorityList,int cFormats);
HWND GetOpenClipboardWindow();


/*
 * Character Translation Routines
 */

BOOL CharToOemA(LPCSTR lpszSrc,LPSTR lpszDst);
BOOL CharToOemW(LPCWSTR lpszSrc,LPSTR lpszDst);

BOOL OemToCharA( LPCSTR lpszSrc,LPSTR lpszDst);
BOOL OemToCharW(LPCSTR lpszSrc,LPWSTR lpszDst);

BOOL CharToOemBuffA(LPCSTR lpszSrc,LPSTR lpszDst,DWORD cchDstLength);
BOOL CharToOemBuffW(LPCWSTR lpszSrc,LPSTR lpszDst,DWORD cchDstLength);

BOOL OemToCharBuffA(LPCSTR lpszSrc,LPSTR lpszDst,DWORD cchDstLength);
BOOL OemToCharBuffW(LPCSTR lpszSrc,LPWSTR lpszDst,DWORD cchDstLength);

LPSTR CharUpperA(LPSTR lpsz);
LPWSTR CharUpperW(LPWSTR lpsz);

DWORD CharUpperBuffA(LPSTR lpsz,DWORD cchLength);
DWORD CharUpperBuffW(LPWSTR lpsz,DWORD cchLength);

LPSTR CharLowerA(LPSTR lpsz);
LPWSTR CharLowerW(LPWSTR lpsz);

DWORD CharLowerBuffA(LPSTR lpsz,DWORD cchLength);
DWORD CharLowerBuffW(LPWSTR lpsz,DWORD cchLength);

LPSTR CharNextA(LPCSTR lpsz);
LPWSTR CharNextW(LPCWSTR lpsz);

LPSTR CharPrevA(LPCSTR lpszStart,LPCSTR lpszCurrent);
LPWSTR CharPrevW(LPCWSTR lpszStart,LPCWSTR lpszCurrent);

LPSTR CharNextExA(WORD CodePage,LPCSTR lpCurrentChar,DWORD dwFlags);
LPSTR CharPrevExA(WORD CodePage,LPCSTR lpStart,LPCSTR lpCurrentChar,DWORD dwFlags);


/*
 * Compatibility defines for character translation routines
 */
/*
#define AnsiToOem CharToOemA
#define OemToAnsi OemToCharA
#define AnsiToOemBuff CharToOemBuffA
#define OemToAnsiBuff OemToCharBuffA
#define AnsiUpper CharUpperA
#define AnsiUpperBuff CharUpperBuffA
#define AnsiLower CharLowerA
#define AnsiLowerBuff CharLowerBuffA
#define AnsiNext CharNextA
#define AnsiPrev CharPrevA
*/

/*
 * Language dependent Routines
 */
BOOL IsCharAlphaA(CHAR ch);
BOOL IsCharAlphaW(WCHAR ch);

BOOL IsCharAlphaNumericA(CHAR ch);
BOOL IsCharAlphaNumericW(WCHAR ch);

BOOL IsCharUpperA(CHAR ch);
BOOL IsCharUpperW(WCHAR ch);

BOOL IsCharLowerA(CHAR ch);
BOOL IsCharLowerW(WCHAR ch);


HWND SetFocus(HWND hWnd);
HWND GetActiveWindow();
version( STANDALONE )
{
  HWND GetFocus();
}
UINT GetKBCodePage();
SHORT GetKeyState(int nVirtKey);
SHORT GetAsyncKeyState(int vKey);
BOOL  GetKeyboardState(PBYTE lpKeyState);
BOOL SetKeyboardState(LPBYTE lpKeyState);

int GetKeyNameTextA(LONG lParam,LPSTR lpString,int nSize);
int GetKeyNameTextW(LONG lParam,LPWSTR lpString,int nSize);


int GetKeyboardType(int nTypeFlag);

int ToAscii(UINT uVirtKey,UINT uScanCode,PBYTE lpKeyState,LPWORD lpChar,UINT uFlags);
int ToAsciiEx(UINT uVirtKey,UINT uScanCode,PBYTE lpKeyState,LPWORD lpChar,UINT uFlags,HKL dwhkl);

int ToUnicode(UINT wVirtKey,UINT wScanCode,PBYTE lpKeyState,LPWSTR pwszBuff,int cchBuff,UINT wFlags);

DWORD OemKeyScan(WORD wOemChar);

SHORT VkKeyScanA(CHAR ch);
SHORT VkKeyScanW(WCHAR ch);

SHORT VkKeyScanExA(CHAR  ch,HKL   dwhkl);
SHORT VkKeyScanExW(WCHAR  ch,HKL   dwhkl);

enum {
KEYEVENTF_EXTENDEDKEY =0x0001,
KEYEVENTF_KEYUP       =0x0002
}

VOID keybd_event(BYTE bVk,BYTE bScan,DWORD dwFlags,DWORD dwExtraInfo);

enum {
MOUSEEVENTF_MOVE        =0x0001, /* mouse move */
MOUSEEVENTF_LEFTDOWN    =0x0002, /* left button down */
MOUSEEVENTF_LEFTUP      =0x0004, /* left button up */
MOUSEEVENTF_RIGHTDOWN   =0x0008, /* right button down */
MOUSEEVENTF_RIGHTUP     =0x0010, /* right button up */
MOUSEEVENTF_MIDDLEDOWN  =0x0020, /* middle button down */
MOUSEEVENTF_MIDDLEUP    =0x0040, /* middle button up */
MOUSEEVENTF_WHEEL       =0x0800, /* wheel button rolled */
MOUSEEVENTF_ABSOLUTE    =0x8000  /* absolute move */
}

VOID mouse_event(DWORD dwFlags,DWORD dx,DWORD dy,DWORD dwData,DWORD dwExtraInfo);

UINT MapVirtualKeyA(UINT uCode,UINT uMapType);
UINT MapVirtualKeyW(UINT uCode,UINT uMapType);

UINT MapVirtualKeyExA(UINT uCode,UINT uMapType,HKL dwhkl);
UINT MapVirtualKeyExW(UINT uCode,UINT uMapType,HKL dwhkl);

BOOL GetInputState();
DWORD GetQueueStatus(UINT flags);
HWND GetCapture();
HWND SetCapture(HWND hWnd);
BOOL ReleaseCapture();
DWORD MsgWaitForMultipleObjects(DWORD nCount,LPHANDLE pHandles,BOOL fWaitAll,DWORD dwMilliseconds,DWORD dwWakeMask);
DWORD MsgWaitForMultipleObjectsEx(DWORD nCount,LPHANDLE pHandles,DWORD dwMilliseconds,DWORD dwWakeMask,DWORD dwFlags);

enum {
MWMO_WAITALL      =0x0001,
MWMO_ALERTABLE    =0x0002
}

enum {
/*
 * Queue status flags for GetQueueStatus() and MsgWaitForMultipleObjects()
 */
QS_KEY              =0x0001,
QS_MOUSEMOVE        =0x0002,
QS_MOUSEBUTTON      =0x0004,
QS_POSTMESSAGE      =0x0008,
QS_TIMER            =0x0010,
QS_PAINT            =0x0020,
QS_SENDMESSAGE      =0x0040,
QS_HOTKEY           =0x0080,
QS_ALLPOSTMESSAGE   =0x0100,

QS_MOUSE           =(QS_MOUSEMOVE|QS_MOUSEBUTTON),
QS_INPUT           =(QS_MOUSE|QS_KEY),
QS_ALLEVENTS       =(QS_INPUT|QS_POSTMESSAGE|QS_TIMER|QS_PAINT|QS_HOTKEY),
QS_ALLINPUT        =(QS_INPUT|QS_POSTMESSAGE|QS_TIMER|QS_PAINT|QS_HOTKEY|QS_SENDMESSAGE)
}

/*
 * Windows Functions
 */
UINT SetTimer(HWND hWnd,UINT nIDEvent,UINT uElapse,TIMERPROC lpTimerFunc);
BOOL KillTimer(HWND hWnd,UINT uIDEvent);
BOOL IsWindowUnicode(HWND hWnd);
BOOL EnableWindow(HWND hWnd,BOOL bEnable);
BOOL IsWindowEnabled(HWND hWnd);

HACCEL LoadAcceleratorsA(HINSTANCE hInstance,LPCSTR lpTableName);
HACCEL LoadAcceleratorsW(HINSTANCE hInstance,LPCWSTR lpTableName);

HACCEL CreateAcceleratorTableA(LPACCEL, int);
HACCEL CreateAcceleratorTableW(LPACCEL, int);

BOOL DestroyAcceleratorTable(HACCEL hAccel);

int CopyAcceleratorTableA(HACCEL hAccelSrc,LPACCEL lpAccelDst,int cAccelEntries);
int CopyAcceleratorTableW(HACCEL hAccelSrc,LPACCEL lpAccelDst,int cAccelEntries);

int TranslateAcceleratorA(HWND hWnd,HACCEL hAccTable,LPMSG lpMsg);
int TranslateAcceleratorW(HWND hWnd,HACCEL hAccTable,LPMSG lpMsg);

enum {
/*
 * GetSystemMetrics() codes
 */
SM_CXSCREEN             =0,
SM_CYSCREEN             =1,
SM_CXVSCROLL            =2,
SM_CYHSCROLL            =3,
SM_CYCAPTION            =4,
SM_CXBORDER             =5,
SM_CYBORDER             =6,
SM_CXDLGFRAME           =7,
SM_CYDLGFRAME           =8,
SM_CYVTHUMB             =9,
SM_CXHTHUMB             =10,
SM_CXICON               =11,
SM_CYICON               =12,
SM_CXCURSOR             =13,
SM_CYCURSOR             =14,
SM_CYMENU               =15,
SM_CXFULLSCREEN         =16,
SM_CYFULLSCREEN         =17,
SM_CYKANJIWINDOW        =18,
SM_MOUSEPRESENT         =19,
SM_CYVSCROLL            =20,
SM_CXHSCROLL            =21,
SM_DEBUG                =22,
SM_SWAPBUTTON           =23,
SM_RESERVED1            =24,
SM_RESERVED2            =25,
SM_RESERVED3            =26,
SM_RESERVED4            =27,
SM_CXMIN                =28,
SM_CYMIN                =29,
SM_CXSIZE               =30,
SM_CYSIZE               =31,
SM_CXFRAME              =32,
SM_CYFRAME              =33,
SM_CXMINTRACK           =34,
SM_CYMINTRACK           =35,
SM_CXDOUBLECLK          =36,
SM_CYDOUBLECLK          =37,
SM_CXICONSPACING        =38,
SM_CYICONSPACING        =39,
SM_MENUDROPALIGNMENT    =40,
SM_PENWINDOWS           =41,
SM_DBCSENABLED          =42,
SM_CMOUSEBUTTONS        =43,

SM_CXFIXEDFRAME          = SM_CXDLGFRAME,  /* ;win40 name change */
SM_CYFIXEDFRAME          = SM_CYDLGFRAME,  /* ;win40 name change */
SM_CXSIZEFRAME           = SM_CXFRAME,     /* ;win40 name change */
SM_CYSIZEFRAME           = SM_CYFRAME,     /* ;win40 name change */

SM_SECURE               =44,
SM_CXEDGE               =45,
SM_CYEDGE               =46,
SM_CXMINSPACING         =47,
SM_CYMINSPACING         =48,
SM_CXSMICON             =49,
SM_CYSMICON             =50,
SM_CYSMCAPTION          =51,
SM_CXSMSIZE             =52,
SM_CYSMSIZE             =53,
SM_CXMENUSIZE           =54,
SM_CYMENUSIZE           =55,
SM_ARRANGE              =56,
SM_CXMINIMIZED          =57,
SM_CYMINIMIZED          =58,
SM_CXMAXTRACK           =59,
SM_CYMAXTRACK           =60,
SM_CXMAXIMIZED          =61,
SM_CYMAXIMIZED          =62,
SM_NETWORK              =63,
SM_CLEANBOOT            =67,
SM_CXDRAG               =68,
SM_CYDRAG               =69,
SM_SHOWSOUNDS           =70,
SM_CXMENUCHECK          =71,  /* Use instead of GetMenuCheckMarkDimensions()! */
SM_CYMENUCHECK          =72,
SM_SLOWMACHINE          =73,
SM_MIDEASTENABLED       =74,
SM_MOUSEWHEELPRESENT    =75,
SM_CMETRICS             =76
}

int GetSystemMetrics(int nIndex);


HMENU LoadMenuA(HINSTANCE hInstance,LPCSTR lpMenuName);
HMENU LoadMenuW(HINSTANCE hInstance,LPCWSTR lpMenuName);

//HMENU LoadMenuIndirectA(CONST MENUTEMPLATEA *lpMenuTemplate);
//HMENU LoadMenuIndirectW(CONST MENUTEMPLATEW *lpMenuTemplate);
HMENU LoadMenuIndirectA(MENUTEMPLATEA *lpMenuTemplate);
HMENU LoadMenuIndirectW(MENUTEMPLATEW *lpMenuTemplate);

HMENU GetMenu(HWND hWnd);
BOOL SetMenu(HWND hWnd,HMENU hMenu);
BOOL ChangeMenuA(HMENU hMenu,UINT cmd,LPCSTR lpszNewItem,UINT cmdInsert,UINT flags);
BOOL ChangeMenuW(HMENU hMenu,UINT cmd,LPCWSTR lpszNewItem,UINT cmdInsert,UINT flags);

BOOL HiliteMenuItem(HWND hWnd,HMENU hMenu,UINT uIDHiliteItem,UINT uHilite);
int GetMenuStringA(HMENU hMenu,UINT uIDItem,LPSTR lpString,int nMaxCount,UINT uFlag);
int GetMenuStringW(HMENU hMenu,UINT uIDItem,LPWSTR lpString,int nMaxCount,UINT uFlag);

UINT GetMenuState(HMENU hMenu,UINT uId,UINT uFlags);
BOOL DrawMenuBar(HWND hWnd);
HMENU GetSystemMenu(HWND hWnd,BOOL bRevert);
HMENU CreateMenu();
HMENU CreatePopupMenu();
BOOL DestroyMenu(HMENU hMenu);
DWORD CheckMenuItem(HMENU hMenu,UINT uIDCheckItem,UINT uCheck);
BOOL EnableMenuItem(HMENU hMenu,UINT uIDEnableItem,UINT uEnable);
HMENU GetSubMenu(HMENU hMenu,int nPos);
UINT GetMenuItemID(HMENU hMenu,int nPos);
int GetMenuItemCount(HMENU hMenu);
BOOL InsertMenuA(HMENU hMenu,UINT uPosition,UINT uFlags,UINT uIDNewItem,LPCSTR lpNewItem);
BOOL InsertMenuW(HMENU hMenu,UINT uPosition,UINT uFlags,UINT uIDNewItem,LPCWSTR lpNewItem);

BOOL AppendMenuA(HMENU hMenu,UINT uFlags,UINT uIDNewItem,LPCSTR lpNewItem);
BOOL AppendMenuW(HMENU hMenu,UINT uFlags,UINT uIDNewItem,LPCWSTR lpNewItem);

BOOL ModifyMenuA(HMENU hMnu,UINT uPosition,UINT uFlags,UINT uIDNewItem,LPCSTR lpNewItem);
BOOL ModifyMenuW(HMENU hMnu,UINT uPosition,UINT uFlags,UINT uIDNewItem,LPCWSTR lpNewItem);

BOOL RemoveMenu(HMENU hMenu,UINT uPosition,UINT uFlags);
BOOL DeleteMenu(HMENU hMenu,UINT uPosition,UINT uFlags);
BOOL SetMenuItemBitmaps(HMENU hMenu,UINT uPosition,UINT uFlags,HBITMAP hBitmapUnchecked,HBITMAP hBitmapChecked);
LONG GetMenuCheckMarkDimensions();

//BOOL TrackPopupMenu(HMENU hMenu,UINT uFlags,int x,int y,int nReserved,HWND hWnd,CONST RECT *prcRect);
BOOL TrackPopupMenu(HMENU hMenu,UINT uFlags,int x,int y,int nReserved,HWND hWnd,RECT *prcRect);

enum {
/* return codes for WM_MENUCHAR */
MNC_IGNORE  =0,
MNC_CLOSE   =1,
MNC_EXECUTE =2,
MNC_SELECT  =3
}
struct TPMPARAMS {
    UINT    cbSize;     /* Size of structure */
    RECT    rcExclude;  /* Screen coordinates of rectangle to exclude when positioning */
}
alias TPMPARAMS * LPTPMPARAMS;

BOOL TrackPopupMenuEx(HMENU, UINT, int, int, HWND, LPTPMPARAMS);


enum {
MIIM_STATE       =0x00000001,
MIIM_ID          =0x00000002,
MIIM_SUBMENU     =0x00000004,
MIIM_CHECKMARKS  =0x00000008,
MIIM_TYPE        =0x00000010,
MIIM_DATA        =0x00000020
}

struct MENUITEMINFOA
{
    UINT    cbSize;
    UINT    fMask;
    UINT    fType;          // used if MIIM_TYPE
    UINT    fState;         // used if MIIM_STATE
    UINT    wID;            // used if MIIM_ID
    HMENU   hSubMenu;       // used if MIIM_SUBMENU
    HBITMAP hbmpChecked;    // used if MIIM_CHECKMARKS
    HBITMAP hbmpUnchecked;  // used if MIIM_CHECKMARKS
    DWORD   dwItemData;     // used if MIIM_DATA
    LPSTR   dwTypeData;     // used if MIIM_TYPE
    UINT    cch;            // used if MIIM_TYPE
}   
alias MENUITEMINFOA * LPMENUITEMINFOA;

struct MENUITEMINFOW
{
    UINT    cbSize;
    UINT    fMask;
    UINT    fType;          // used if MIIM_TYPE
    UINT    fState;         // used if MIIM_STATE
    UINT    wID;            // used if MIIM_ID
    HMENU   hSubMenu;       // used if MIIM_SUBMENU
    HBITMAP hbmpChecked;    // used if MIIM_CHECKMARKS
    HBITMAP hbmpUnchecked;  // used if MIIM_CHECKMARKS
    DWORD   dwItemData;     // used if MIIM_DATA
    LPWSTR  dwTypeData;     // used if MIIM_TYPE
    UINT    cch;            // used if MIIM_TYPE
}   
alias MENUITEMINFOW * LPMENUITEMINFOW,LPCMENUITEMINFOA,LPCMENUITEMINFOW;

BOOL InsertMenuItemA(HMENU,UINT,BOOL,LPCMENUITEMINFOA);
BOOL InsertMenuItemW(HMENU,UINT,BOOL,LPCMENUITEMINFOW);

BOOL GetMenuItemInfoA(HMENU,UINT,BOOL,LPMENUITEMINFOA);
BOOL GetMenuItemInfoW(HMENU,UINT,BOOL,LPMENUITEMINFOW);

BOOL SetMenuItemInfoA(HMENU,UINT,BOOL,LPCMENUITEMINFOA);
BOOL SetMenuItemInfoW(HMENU,UINT,BOOL,LPCMENUITEMINFOW);

enum {
GMDI_USEDISABLED    =0x0001,
GMDI_GOINTOPOPUPS   =0x0002
}

UINT GetMenuDefaultItem(HMENU hMenu, UINT fByPos, UINT gmdiFlags);
BOOL SetMenuDefaultItem(HMENU hMenu, UINT uItem, UINT fByPos);

BOOL GetMenuItemRect(HWND hWnd, HMENU hMenu, UINT uItem, LPRECT lprcItem);
int  MenuItemFromPoint(HWND hWnd, HMENU hMenu, POINT ptScreen);

enum {
/*
 * Flags for TrackPopupMenu
 */
TPM_LEFTBUTTON  =0x0000,
TPM_RIGHTBUTTON =0x0002,
TPM_LEFTALIGN   =0x0000,
TPM_CENTERALIGN =0x0004,
TPM_RIGHTALIGN  =0x0008,
TPM_TOPALIGN        =0x0000,
TPM_VCENTERALIGN    =0x0010,
TPM_BOTTOMALIGN     =0x0020,

TPM_HORIZONTAL      =0x0000,     /* Horz alignment matters more */
TPM_VERTICAL        =0x0040,     /* Vert alignment matters more */
TPM_NONOTIFY        =0x0080,     /* Don't send any notification msgs */
TPM_RETURNCMD       =0x0100
}

//
// Drag-and-drop support
//
struct DROPSTRUCT
{
    HWND    hwndSource;
    HWND    hwndSink;
    DWORD   wFmt;
    DWORD   dwData;
    POINT   ptDrop;
    DWORD   dwControlData;
}
alias DROPSTRUCT * PDROPSTRUCT,LPDROPSTRUCT;

enum {
DOF_EXECUTABLE      =0x8001,
DOF_DOCUMENT        =0x8002,
DOF_DIRECTORY       =0x8003,
DOF_MULTIPLE        =0x8004,
DOF_PROGMAN         =0x0001,
DOF_SHELLDATA       =0x0002,

DO_DROPFILE         =0x454C4946,
DO_PRINTFILE        =0x544E5250
}

DWORD DragObject(HWND, HWND, UINT, DWORD, HCURSOR);
BOOL DragDetect(HWND, POINT);
BOOL DrawIcon(HDC hDC,int X,int Y,HICON hIcon);

enum {
/*
 * DrawText() Format Flags
 */
DT_TOP              =0x00000000,
DT_LEFT             =0x00000000,
DT_CENTER           =0x00000001,
DT_RIGHT            =0x00000002,
DT_VCENTER          =0x00000004,
DT_BOTTOM           =0x00000008,
DT_WORDBREAK        =0x00000010,
DT_SINGLELINE       =0x00000020,
DT_EXPANDTABS       =0x00000040,
DT_TABSTOP          =0x00000080,
DT_NOCLIP           =0x00000100,
DT_EXTERNALLEADING  =0x00000200,
DT_CALCRECT         =0x00000400,
DT_NOPREFIX         =0x00000800,
DT_INTERNAL         =0x00001000,

DT_EDITCONTROL      =0x00002000,
DT_PATH_ELLIPSIS    =0x00004000,
DT_END_ELLIPSIS     =0x00008000,
DT_MODIFYSTRING     =0x00010000,
DT_RTLREADING       =0x00020000,
DT_WORD_ELLIPSIS    =0x00040000
}

struct DRAWTEXTPARAMS
{
    UINT    cbSize;
    int     iTabLength;
    int     iLeftMargin;
    int     iRightMargin;
    UINT    uiLengthDrawn;
} 
alias DRAWTEXTPARAMS * LPDRAWTEXTPARAMS;

int DrawTextA(HDC hDC,LPCSTR lpString,int nCount,LPRECT lpRect,UINT uFormat);
int DrawTextW(HDC hDC,LPCWSTR lpString,int nCount,LPRECT lpRect,UINT uFormat);

int DrawTextExA(HDC, LPSTR, int, LPRECT, UINT, LPDRAWTEXTPARAMS);
int DrawTextExW(HDC, LPWSTR, int, LPRECT, UINT, LPDRAWTEXTPARAMS);

BOOL GrayStringA(HDC hDC,HBRUSH hBrush,GRAYSTRINGPROC lpOutputFunc,LPARAM lpData,int nCount,int X,int Y,int nWidth,int nHeight);
BOOL GrayStringW(HDC hDC,HBRUSH hBrush,GRAYSTRINGPROC lpOutputFunc,LPARAM lpData,int nCount,int X,int Y,int nWidth,int nHeight);

enum {
/* Monolithic state-drawing routine */
/* Image type */
DST_COMPLEX     =0x0000,
DST_TEXT        =0x0001,
DST_PREFIXTEXT  =0x0002,
DST_ICON        =0x0003,
DST_BITMAP      =0x0004
}

enum {
/* State type */
DSS_NORMAL      =0x0000,
DSS_UNION       =0x0010, /* Gray string appearance */
DSS_DISABLED    =0x0020,
DSS_MONO        =0x0080,
DSS_RIGHT       =0x8000
}

BOOL DrawStateA(HDC, HBRUSH, DRAWSTATEPROC, LPARAM, WPARAM, int, int, int, int, UINT);
BOOL DrawStateW(HDC, HBRUSH, DRAWSTATEPROC, LPARAM, WPARAM, int, int, int, int, UINT);

LONG TabbedTextOutA(HDC hDC,int X,int Y,LPCSTR lpString,int nCount,int nTabPositions,LPINT lpnTabStopPositions,int nTabOrigin);
LONG TabbedTextOutW(HDC hDC,int X,int Y,LPCWSTR lpString,int nCount,int nTabPositions,LPINT lpnTabStopPositions,int nTabOrigin);

DWORD GetTabbedTextExtentA(HDC hDC,LPCSTR lpString,int nCount,int nTabPositions,LPINT lpnTabStopPositions);
DWORD GetTabbedTextExtentW(HDC hDC,LPCWSTR lpString,int nCount,int nTabPositions,LPINT lpnTabStopPositions);

BOOL UpdateWindow(HWND hWnd);
HWND SetActiveWindow(HWND hWnd);
HWND GetForegroundWindow();
BOOL PaintDesktop(HDC hdc);
BOOL SetForegroundWindow(HWND hWnd);
HWND WindowFromDC(HDC hDC);
HDC  GetDC(HWND hWnd);
HDC  GetDCEx(HWND hWnd,HRGN hrgnClip,DWORD flags);

enum {
/*
 * GetDCEx() flags
 */
DCX_WINDOW           =0x00000001,
DCX_CACHE            =0x00000002,
DCX_NORESETATTRS     =0x00000004,
DCX_CLIPCHILDREN     =0x00000008,
DCX_CLIPSIBLINGS     =0x00000010,
DCX_PARENTCLIP       =0x00000020,

DCX_EXCLUDERGN       =0x00000040,
DCX_INTERSECTRGN     =0x00000080,

DCX_EXCLUDEUPDATE    =0x00000100,
DCX_INTERSECTUPDATE  =0x00000200,

DCX_LOCKWINDOWUPDATE =0x00000400,

DCX_VALIDATE         =0x00200000
}

HDC GetWindowDC(HWND hWnd);

//int ReleaseDC(HWND hWnd,HDC hDC);

//HDC BeginPaint(HWND hWnd,LPPAINTSTRUCT lpPaint);
//BOOL EndPaint(HWND hWnd,CONST PAINTSTRUCT *lpPaint);
//BOOL EndPaint(HWND hWnd,PAINTSTRUCT *lpPaint);
BOOL GetUpdateRect(HWND hWnd,LPRECT lpRect,BOOL bErase);
int GetUpdateRgn(HWND hWnd,HRGN hRgn,BOOL bErase);

int SetWindowRgn(HWND hWnd,HRGN hRgn,BOOL bRedraw);
int GetWindowRgn(HWND hWnd,HRGN hRgn);
int ExcludeUpdateRgn(HDC hDC,HWND hWnd);
//BOOL InvalidateRect(HWND hWnd,CONST RECT *lpRect,BOOL bErase);
//BOOL ValidateRect(HWND hWnd,CONST RECT *lpRect);
BOOL InvalidateRect(HWND hWnd,RECT *lpRect,BOOL bErase);
version( STANDALONE )
{
  BOOL ValidateRect(HWND hWnd,RECT *lpRect);
}
BOOL InvalidateRgn(HWND hWnd,HRGN hRgn,BOOL bErase);
BOOL ValidateRgn(HWND hWnd,HRGN hRgn);
//BOOL RedrawWindow(HWND hWnd,CONST RECT *lprcUpdate,HRGN hrgnUpdate,UINT flags);
BOOL RedrawWindow(HWND hWnd,RECT *lprcUpdate,HRGN hrgnUpdate,UINT flags);

enum {
/*
 * RedrawWindow() flags
 */
RDW_INVALIDATE          =0x0001,
RDW_INTERNALPAINT       =0x0002,
RDW_ERASE               =0x0004,

RDW_VALIDATE            =0x0008,
RDW_NOINTERNALPAINT     =0x0010,
RDW_NOERASE             =0x0020,

RDW_NOCHILDREN          =0x0040,
RDW_ALLCHILDREN         =0x0080,

RDW_UPDATENOW           =0x0100,
RDW_ERASENOW            =0x0200,

RDW_FRAME               =0x0400,
RDW_NOFRAME             =0x0800
}


/*
 * LockWindowUpdate API
 */

BOOL LockWindowUpdate(HWND hWndLock);
//BOOL ScrollWindow(HWND hWnd,int XAmount,int YAmount,CONST RECT *lpRect,CONST RECT *lpClipRect);
//BOOL ScrollDC(HDC hDC,int dx,int dy,CONST RECT *lprcScroll,CONST RECT *lprcClip,HRGN hrgnUpdate,LPRECT lprcUpdate);
//int ScrollWindowEx(HWND hWnd,int dx,int dy,CONST RECT *prcScroll,CONST RECT *prcClip,HRGN hrgnUpdate,LPRECT prcUpdate,UINT flags);
BOOL ScrollWindow(HWND hWnd,int XAmount,int YAmount,RECT *lpRect,RECT *lpClipRect);
BOOL ScrollDC(HDC hDC,int dx,int dy,RECT *lprcScroll,RECT *lprcClip,HRGN hrgnUpdate,LPRECT lprcUpdate);
int ScrollWindowEx(HWND hWnd,int dx,int dy,RECT *prcScroll,RECT *prcClip,HRGN hrgnUpdate,LPRECT prcUpdate,UINT flags);

enum {
SW_SCROLLCHILDREN   =0x0001,  /* Scroll children within *lprcScroll. */
SW_INVALIDATE       =0x0002,  /* Invalidate after scrolling */
SW_ERASE            =0x0004  /* If SW_INVALIDATE, don't send WM_ERASEBACKGROUND */
}

int SetScrollPos(HWND hWnd,int nBar,int nPos,BOOL bRedraw);
int GetScrollPos(HWND hWnd,int nBar);

BOOL SetScrollRange(HWND hWnd,int nBar,int nMinPos,int nMaxPos,BOOL bRedraw);
BOOL GetScrollRange(HWND hWnd,int nBar,LPINT lpMinPos,LPINT lpMaxPos);
BOOL ShowScrollBar(HWND hWnd,int wBar,BOOL bShow);
BOOL EnableScrollBar(HWND hWnd,UINT wSBflags,UINT wArrows);


enum {
/*
 * EnableScrollBar() flags
 */
ESB_ENABLE_BOTH     =0x0000,
ESB_DISABLE_BOTH    =0x0003,

ESB_DISABLE_LEFT    =0x0001,
ESB_DISABLE_RIGHT   =0x0002,

ESB_DISABLE_UP      =0x0001,
ESB_DISABLE_DOWN    =0x0002,

ESB_DISABLE_LTUP    =ESB_DISABLE_LEFT,
ESB_DISABLE_RTDN    =ESB_DISABLE_RIGHT
}

BOOL SetPropA(HWND hWnd,LPCSTR lpString,HANDLE hData);
BOOL SetPropW(HWND hWnd,LPCWSTR lpString,HANDLE hData);

HANDLE GetPropA(HWND hWnd,LPCSTR lpString);
HANDLE GetPropW( HWND hWnd,LPCWSTR lpString);

HANDLE RemovePropA(HWND hWnd,LPCSTR lpString);
HANDLE RemovePropW(HWND hWnd,LPCWSTR lpString);

int EnumPropsExA(HWND hWnd,PROPENUMPROCEXA lpEnumFunc,LPARAM lParam);
int EnumPropsExW(HWND hWnd,PROPENUMPROCEXW lpEnumFunc,LPARAM lParam);

int EnumPropsA(HWND hWnd,PROPENUMPROCA lpEnumFunc);
int EnumPropsW(HWND hWnd,PROPENUMPROCW lpEnumFunc);

BOOL SetWindowTextA(HWND hWnd,LPCSTR lpString);
BOOL SetWindowTextW(HWND hWnd,LPCWSTR lpString);

int GetWindowTextA(HWND hWnd,LPSTR lpString,int nMaxCount);
int GetWindowTextW(HWND hWnd,LPWSTR lpString,int nMaxCount);

int GetWindowTextLengthA(HWND hWnd);
int GetWindowTextLengthW(HWND hWnd);

version( STANDALONE ) {
BOOL GetClientRect(HWND hWnd,LPRECT lpRect);
BOOL GetWindowRect(HWND hWnd,LPRECT lpRect);
BOOL AdjustWindowRect(LPRECT lpRect,DWORD dwStyle,BOOL bMenu);
BOOL AdjustWindowRectEx(LPRECT lpRect,DWORD dwStyle,BOOL bMenu,DWORD dwExStyle);
}

enum {
HELPINFO_WINDOW    =0x0001,
HELPINFO_MENUITEM  =0x0002
}
struct HELPINFO /* Structure pointed to by lParam of WM_HELP */
{
    UINT    cbSize;             /* Size in bytes of this struct  */
    int     iContextType;       /* Either HELPINFO_WINDOW or HELPINFO_MENUITEM */
    int     iCtrlId;            /* Control Id or a Menu item Id. */
    HANDLE  hItemHandle;        /* hWnd of control or hMenu.     */
    DWORD   dwContextId;        /* Context Id associated with this item */
    POINT   MousePos;           /* Mouse Position in screen co-ordinates */
}  
alias HELPINFO * LPHELPINFO;

BOOL  SetWindowContextHelpId(HWND, DWORD);
DWORD GetWindowContextHelpId(HWND);
BOOL  SetMenuContextHelpId(HMENU, DWORD);
DWORD GetMenuContextHelpId(HMENU);

version(STANDALONE) {
enum {
/*
 * MessageBox() Flags
 */
MB_OK                       =0x00000000,
MB_OKCANCEL                 =0x00000001,
MB_ABORTRETRYIGNORE         =0x00000002,
MB_YESNOCANCEL              =0x00000003,
MB_YESNO                    =0x00000004,
MB_RETRYCANCEL              =0x00000005,

MB_ICONHAND                 =0x00000010,
MB_ICONQUESTION             =0x00000020,
MB_ICONEXCLAMATION          =0x00000030,
MB_ICONASTERISK             =0x00000040,

MB_USERICON                 =0x00000080,
MB_ICONWARNING              =MB_ICONEXCLAMATION,
MB_ICONERROR                =MB_ICONHAND,

MB_ICONINFORMATION          =MB_ICONASTERISK,
MB_ICONSTOP                 =MB_ICONHAND,

MB_DEFBUTTON1               =0x00000000,
MB_DEFBUTTON2               =0x00000100,
MB_DEFBUTTON3               =0x00000200,
MB_DEFBUTTON4               =0x00000300,

MB_APPLMODAL                =0x00000000,
MB_SYSTEMMODAL              =0x00001000,
MB_TASKMODAL                =0x00002000,
MB_HELP                     =0x00004000, // Help Button

MB_NOFOCUS                  =0x00008000,
MB_SETFOREGROUND            =0x00010000,
MB_DEFAULT_DESKTOP_ONLY     =0x00020000,

MB_TOPMOST                  =0x00040000,
MB_RIGHT                    =0x00080000,
MB_RTLREADING               =0x00100000,

MB_SERVICE_NOTIFICATION          =0x00200000,
MB_SERVICE_NOTIFICATION_NT3X     =0x00040000,

MB_TYPEMASK                 =0x0000000F,
MB_ICONMASK                 =0x000000F0,
MB_DEFMASK                  =0x00000F00,
MB_MODEMASK                 =0x00003000,
MB_MISCMASK                 =0x0000C000
}
}

//int MessageBoxA(HWND hWnd,LPCSTR lpText,LPCSTR lpCaption,UINT uType);
int MessageBoxW(HWND hWnd,LPCWSTR lpText,LPCWSTR lpCaption,UINT uType);

//int MessageBoxExA(HWND hWnd,LPCSTR lpText,LPCSTR lpCaption,UINT uType,WORD wLanguageId);
int MessageBoxExW(HWND hWnd,LPCWSTR lpText,LPCWSTR lpCaption,UINT uType,WORD wLanguageId);

alias void (*MSGBOXCALLBACK)(LPHELPINFO lpHelpInfo);

struct MSGBOXPARAMSA
{
    UINT        cbSize;
    HWND        hwndOwner;
    HINSTANCE   hInstance;
    LPCSTR      lpszText;
    LPCSTR      lpszCaption;
    DWORD       dwStyle;
    LPCSTR      lpszIcon;
    DWORD       dwContextHelpId;
    MSGBOXCALLBACK      lpfnMsgBoxCallback;
    DWORD   dwLanguageId;
} 
alias MSGBOXPARAMSA * PMSGBOXPARAMSA;
alias MSGBOXPARAMSA * LPMSGBOXPARAMSA;

struct MSGBOXPARAMSW
{
    UINT        cbSize;
    HWND        hwndOwner;
    HINSTANCE   hInstance;
    LPCWSTR     lpszText;
    LPCWSTR     lpszCaption;
    DWORD       dwStyle;
    LPCWSTR     lpszIcon;
    DWORD       dwContextHelpId;
    MSGBOXCALLBACK      lpfnMsgBoxCallback;
    DWORD   dwLanguageId;
} 
alias MSGBOXPARAMSW * PMSGBOXPARAMSW;
alias MSGBOXPARAMSW * LPMSGBOXPARAMSW;

int MessageBoxIndirectA(LPMSGBOXPARAMSA);
int MessageBoxIndirectW(LPMSGBOXPARAMSW);

BOOL MessageBeep(UINT uType);

int ShowCursor(BOOL bShow);
BOOL SetCursorPos(int X,int Y);
HCURSOR SetCursor(HCURSOR hCursor);
BOOL GetCursorPos(LPPOINT lpPoint);
//BOOL ClipCursor(CONST RECT *lpRect);
BOOL ClipCursor(RECT *lpRect);
BOOL GetClipCursor(LPRECT lpRect);
HCURSOR GetCursor();
BOOL CreateCaret(HWND hWnd,HBITMAP hBitmap,int nWidth,int nHeight);
UINT GetCaretBlinkTime();
BOOL SetCaretBlinkTime(UINT uMSeconds);
BOOL DestroyCaret();
BOOL HideCaret(HWND hWnd);
BOOL ShowCaret(HWND hWnd);
BOOL SetCaretPos(int X,int Y);
BOOL GetCaretPos(LPPOINT lpPoint);
BOOL ClientToScreen(HWND hWnd,LPPOINT lpPoint);
BOOL ScreenToClient(HWND hWnd,LPPOINT lpPoint);
int MapWindowPoints(HWND hWndFrom,HWND hWndTo,LPPOINT lpPoints,UINT cPoints);
HWND WindowFromPoint(POINT Point);
HWND ChildWindowFromPoint(HWND hWndParent,POINT Point);

enum {
CWP_ALL             =0x0000,
CWP_SKIPINVISIBLE   =0x0001,
CWP_SKIPDISABLED    =0x0002,
CWP_SKIPTRANSPARENT =0x0004
}

HWND ChildWindowFromPointEx(HWND, POINT, UINT);

enum {
/*
 * Color Types
 */
CTLCOLOR_MSGBOX         =0,
CTLCOLOR_EDIT           =1,
CTLCOLOR_LISTBOX        =2,
CTLCOLOR_BTN            =3,
CTLCOLOR_DLG            =4,
CTLCOLOR_SCROLLBAR      =5,
CTLCOLOR_STATIC         =6,
CTLCOLOR_MAX            =7,
}

enum {
COLOR_SCROLLBAR         =0,
COLOR_BACKGROUND        =1,
COLOR_ACTIVECAPTION     =2,
COLOR_INACTIVECAPTION   =3,
COLOR_MENU              =4,
//COLOR_WINDOW            =5,
COLOR_WINDOWFRAME       =6,
COLOR_MENUTEXT          =7,
COLOR_WINDOWTEXT        =8,
COLOR_CAPTIONTEXT       =9,
COLOR_ACTIVEBORDER      =10,
COLOR_INACTIVEBORDER    =11,
COLOR_APPWORKSPACE      =12,
COLOR_HIGHLIGHT         =13,
COLOR_HIGHLIGHTTEXT     =14,
COLOR_BTNFACE           =15,
COLOR_BTNSHADOW         =16,
COLOR_GRAYTEXT          =17,
COLOR_BTNTEXT           =18,
COLOR_INACTIVECAPTIONTEXT= 19,
COLOR_BTNHIGHLIGHT      =20,

COLOR_3DDKSHADOW        =21,
COLOR_3DLIGHT           =22,
COLOR_INFOTEXT          =23,
COLOR_INFOBK            =24,

COLOR_DESKTOP           =COLOR_BACKGROUND,
COLOR_3DFACE            =COLOR_BTNFACE,
COLOR_3DSHADOW          =COLOR_BTNSHADOW,
COLOR_3DHIGHLIGHT       =COLOR_BTNHIGHLIGHT,
COLOR_3DHILIGHT         =COLOR_BTNHIGHLIGHT,
COLOR_BTNHILIGHT        =COLOR_BTNHIGHLIGHT,
}

DWORD GetSysColor(int nIndex);
HBRUSH GetSysColorBrush(int nIndex);
//BOOL SetSysColors(int cElements,CONST INT * lpaElements,CONST COLORREF * lpaRgbValues);
BOOL SetSysColors(int cElements,INT * lpaElements,COLORREF * lpaRgbValues);
//BOOL DrawFocusRect(HDC hDC,CONST RECT * lprc);
//int FillRect(HDC hDC,CONST RECT *lprc,HBRUSH hbr);
//int FrameRect(HDC hDC,CONST RECT *lprc,HBRUSH hbr);
BOOL InvertRect(HDC hDC,RECT *lprc);
BOOL DrawFocusRect(HDC hDC,RECT * lprc);
int FillRect(HDC hDC,RECT *lprc,HBRUSH hbr);
int FrameRect(HDC hDC,RECT *lprc,HBRUSH hbr);
//BOOL InvertRect(HDC hDC,CONST RECT *lprc);
BOOL InvertRect(HDC hDC,RECT *lprc);
BOOL SetRect(LPRECT lprc,int xLeft,int yTop,int xRight,int yBottom);
BOOL SetRectEmpty(LPRECT lprc);

//BOOL CopyRect( LPRECT lprcDst,CONST RECT *lprcSrc);
BOOL CopyRect( LPRECT lprcDst,RECT *lprcSrc);
BOOL InflateRect(LPRECT lprc,int dx,int dy);
//BOOL IntersectRect(LPRECT lprcDst,CONST RECT *lprcSrc1,CONST RECT *lprcSrc2);
//BOOL UnionRect(LPRECT lprcDst,CONST RECT *lprcSrc1,CONST RECT *lprcSrc2);
//BOOL SubtractRect(LPRECT lprcDst,CONST RECT *lprcSrc1,CONST RECT *lprcSrc2);
BOOL IntersectRect(LPRECT lprcDst,RECT *lprcSrc1,RECT *lprcSrc2);
BOOL UnionRect(LPRECT lprcDst,RECT *lprcSrc1,RECT *lprcSrc2);
BOOL SubtractRect(LPRECT lprcDst,RECT *lprcSrc1,RECT *lprcSrc2);
BOOL OffsetRect(LPRECT lprc,int dx,int dy);
//BOOL IsRectEmpty(CONST RECT *lprc);
//BOOL EqualRect(CONST RECT *lprc1,CONST RECT *lprc2);
//BOOL PtInRect(CONST RECT *lprc,POINT pt);
BOOL IsRectEmpty(RECT *lprc);
BOOL EqualRect(RECT *lprc1,RECT *lprc2);
BOOL PtInRect(RECT *lprc,POINT pt);

WORD GetWindowWord(HWND hWnd,int nIndex);
WORD SetWindowWord(HWND hWnd,int nIndex,WORD wNewWord);
LONG GetWindowLongA(HWND hWnd,int nIndex);
LONG GetWindowLongW(HWND hWnd,int nIndex);

LONG SetWindowLongA(HWND hWnd,int nIndex,LONG dwNewLong);
LONG SetWindowLongW(HWND hWnd,int nIndex,LONG dwNewLong);

WORD GetClassWord(HWND hWnd,int nIndex);
WORD SetClassWord(HWND hWnd,int nIndex,WORD wNewWord);

DWORD GetClassLongA(HWND hWnd,int nIndex);
DWORD GetClassLongW(HWND hWnd,int nIndex);


DWORD SetClassLongA(HWND hWnd,int nIndex,LONG dwNewLong);
DWORD SetClassLongW(HWND hWnd,int nIndex,LONG dwNewLong);

HWND GetDesktopWindow();
HWND GetParent(HWND hWnd);
HWND SetParent(HWND hWndChild,HWND hWndNewParent);
BOOL EnumChildWindows(HWND hWndParent,WNDENUMPROC lpEnumFunc,LPARAM lParam);

HWND FindWindowA(LPCSTR lpClassName,LPCSTR lpWindowName);
HWND FindWindowW(LPCWSTR lpClassName,LPCWSTR lpWindowName);

HWND FindWindowExA(HWND, HWND, LPCSTR, LPCSTR);
HWND FindWindowExW(HWND, HWND, LPCWSTR, LPCWSTR);

BOOL EnumWindows(WNDENUMPROC lpEnumFunc,LPARAM lParam);
BOOL EnumThreadWindows(DWORD dwThreadId,WNDENUMPROC lpfn,LPARAM lParam);

//#define EnumTaskWindows(hTask, lpfn, lParam) EnumThreadWindows((DWORD)hTask, lpfn, lParam)

int GetClassNameA(HWND hWnd,LPSTR lpClassName,int nMaxCount);
int GetClassNameW(HWND hWnd,LPWSTR lpClassName,int nMaxCount);

HWND GetTopWindow(HWND hWnd);

//#define GetNextWindow(hWnd, wCmd) GetWindow(hWnd, wCmd)
//#define GetSysModalWindow() (NULL)
//#define SetSysModalWindow(hWnd) (NULL)

DWORD GetWindowThreadProcessId(HWND hWnd,LPDWORD lpdwProcessId);

/*
#define GetWindowTask(hWnd) \
        ((HANDLE)GetWindowThreadProcessId(hWnd, NULL))
*/

HWND GetLastActivePopup(HWND hWnd);

enum {
/*
 * GetWindow() Constants
 */
GW_HWNDFIRST        =0,
GW_HWNDLAST         =1,
GW_HWNDNEXT         =2,
GW_HWNDPREV         =3,
GW_OWNER            =4,
GW_CHILD            =5,
GW_MAX              =5
}

HWND GetWindow(HWND hWnd,UINT uCmd);

HHOOK SetWindowsHookA(int nFilterType,HOOKPROC pfnFilterProc);
HHOOK SetWindowsHookW(int nFilterType,HOOKPROC pfnFilterProc);

BOOL UnhookWindowsHook(int nCode,HOOKPROC pfnFilterProc);

HHOOK SetWindowsHookExA(int idHook,HOOKPROC lpfn,HINSTANCE hmod,DWORD dwThreadId);
HHOOK SetWindowsHookExW(int idHook,HOOKPROC lpfn,HINSTANCE hmod,DWORD dwThreadId);

BOOL UnhookWindowsHookEx(HHOOK hhk);
LRESULT CallNextHookEx(HHOOK hhk,int nCode,WPARAM wParam,LPARAM lParam);


/*
 * Macros for source-level compatibility with old functions.
 */
/*
#define DefHookProc(nCode, wParam, lParam, phhk)\
        CallNextHookEx(*phhk, nCode, wParam, lParam)
*/

enum {
/* ;win40  -- A lot of MF_* flags have been renamed as MFT_* and MFS_* flags */
/*
 * Menu flags for Add/Check/EnableMenuItem()
 */
MF_INSERT           =0x00000000,
MF_CHANGE           =0x00000080,
MF_APPEND           =0x00000100,
MF_DELETE           =0x00000200,
MF_REMOVE           =0x00001000,

MF_BYCOMMAND        =0x00000000,
MF_BYPOSITION       =0x00000400,

MF_SEPARATOR        =0x00000800,

MF_ENABLED          =0x00000000,
MF_GRAYED           =0x00000001,
MF_DISABLED         =0x00000002,

MF_UNCHECKED        =0x00000000,
MF_CHECKED          =0x00000008,
MF_USECHECKBITMAPS  =0x00000200,

MF_STRING           =0x00000000,
MF_BITMAP           =0x00000004,
MF_OWNERDRAW        =0x00000100,

MF_POPUP            =0x00000010,
MF_MENUBARBREAK     =0x00000020,
MF_MENUBREAK        =0x00000040,

MF_UNHILITE         =0x00000000,
MF_HILITE           =0x00000080,

MF_DEFAULT          =0x00001000,
MF_SYSMENU          =0x00002000,
MF_HELP             =0x00004000,
MF_RIGHTJUSTIFY     =0x00004000,

MF_MOUSESELECT      =0x00008000,
MF_END              =0x00000080  /* Obsolete -- only used by old RES files */
}

enum {
MFT_STRING          =MF_STRING,
MFT_BITMAP          =MF_BITMAP,
MFT_MENUBARBREAK    =MF_MENUBARBREAK,
MFT_MENUBREAK       =MF_MENUBREAK,
MFT_OWNERDRAW       =MF_OWNERDRAW,
MFT_RADIOCHECK      =0x00000200,
MFT_SEPARATOR       =MF_SEPARATOR,
MFT_RIGHTORDER      =0x00002000,
MFT_RIGHTJUSTIFY    =MF_RIGHTJUSTIFY
}
enum {
/* Menu flags for Add/Check/EnableMenuItem() */
MFS_GRAYED          =0x00000003,
MFS_DISABLED        =MFS_GRAYED,
MFS_CHECKED         =MF_CHECKED,
MFS_HILITE          =MF_HILITE,
MFS_ENABLED         =MF_ENABLED,
MFS_UNCHECKED       =MF_UNCHECKED,
MFS_UNHILITE        =MF_UNHILITE,
MFS_DEFAULT         =MF_DEFAULT
}

BOOL CheckMenuRadioItem(HMENU, UINT, UINT, UINT, UINT);



/*
 * Menu item resource format
 */
struct MENUITEMTEMPLATEHEADER {
    WORD versionNumber;
    WORD offset;
} 
alias MENUITEMTEMPLATEHEADER  * PMENUITEMTEMPLATEHEADER;

struct MENUITEMTEMPLATE {        // version 0
    WORD mtOption;
    WORD mtID;
    WCHAR mtString[1];
} 
alias MENUITEMTEMPLATE * PMENUITEMTEMPLATE;
/*enum {
MF_END             =0x00000080
}*/

enum {
/*
 * System Menu Command Values
 */
SC_SIZE         =0xF000,
SC_MOVE         =0xF010,
SC_MINIMIZE     =0xF020,
SC_MAXIMIZE     =0xF030,
SC_NEXTWINDOW   =0xF040,
SC_PREVWINDOW   =0xF050,
SC_CLOSE        =0xF060,
SC_VSCROLL      =0xF070,
SC_HSCROLL      =0xF080,
SC_MOUSEMENU    =0xF090,
SC_KEYMENU      =0xF100,
SC_ARRANGE      =0xF110,
SC_RESTORE      =0xF120,
SC_TASKLIST     =0xF130,
SC_SCREENSAVE   =0xF140,
SC_HOTKEY       =0xF150,
SC_DEFAULT      =0xF160,
SC_MONITORPOWER =0xF170,
SC_CONTEXTHELP  =0xF180,
SC_SEPARATOR    =0xF00F,
/*
 * Obsolete names
 */
SC_ICON         =SC_MINIMIZE,
SC_ZOOM         =SC_MAXIMIZE
}


/*
 * Resource Loading Routines
 */

HBITMAP LoadBitmapA(HINSTANCE hInstance,LPCSTR lpBitmapName);
HBITMAP LoadBitmapW(HINSTANCE hInstance,LPCWSTR lpBitmapName);

//HCURSOR LoadCursorA(HINSTANCE hInstance,LPCSTR lpCursorName);
HCURSOR LoadCursorW(HINSTANCE hInstance,LPCWSTR lpCursorName);

HCURSOR LoadCursorFromFileA(LPCSTR    lpFileName);
HCURSOR LoadCursorFromFileW(LPCWSTR    lpFileName);

//HCURSOR CreateCursor(HINSTANCE hInst,int xHotSpot,int yHotSpot,int nWidth,int nHeight,CONST VOID *pvANDPlane,CONST VOID *pvXORPlane);
HCURSOR CreateCursor(HINSTANCE hInst,int xHotSpot,int yHotSpot,int nWidth,int nHeight,VOID *pvANDPlane,VOID *pvXORPlane);

BOOL DestroyCursor(HCURSOR hCursor);

//#define CopyCursor(pcur) ((HCURSOR)CopyIcon((HICON)(pcur)))

enum {
/*
 * Standard Cursor IDs
 */
IDC_ARROW           =(32512),
IDC_IBEAM           =(32513),
IDC_WAIT            =(32514),
//IDC_CROSS           =(32515),
IDC_UPARROW         =(32516),
IDC_SIZE            =(32640),  /* OBSOLETE: use IDC_SIZEALL */
IDC_ICON            =(32641),  /* OBSOLETE: use IDC_ARROW */
IDC_SIZENWSE        =(32642),
IDC_SIZENESW        =(32643),
IDC_SIZEWE          =(32644),
IDC_SIZENS          =(32645),
IDC_SIZEALL         =(32646),
IDC_NO              =(32648), /*not in win3.1 */
IDC_APPSTARTING     =(32650), /*not in win3.1 */
IDC_HELP            =(32651)
/*
IDC_ARROW           =MAKEINTRESOURCE(32512),
IDC_IBEAM           =MAKEINTRESOURCE(32513),
IDC_WAIT            =MAKEINTRESOURCE(32514),
IDC_CROSS           =MAKEINTRESOURCE(32515),
IDC_UPARROW         =MAKEINTRESOURCE(32516),
IDC_SIZE            =MAKEINTRESOURCE(32640),  
IDC_ICON            =MAKEINTRESOURCE(32641),  
IDC_SIZENWSE        =MAKEINTRESOURCE(32642),
IDC_SIZENESW        =MAKEINTRESOURCE(32643),
IDC_SIZEWE          =MAKEINTRESOURCE(32644),
IDC_SIZENS          =MAKEINTRESOURCE(32645),
IDC_SIZEALL         =MAKEINTRESOURCE(32646),
IDC_NO              =MAKEINTRESOURCE(32648), 
IDC_APPSTARTING     =MAKEINTRESOURCE(32650), 
IDC_HELP            =MAKEINTRESOURCE(32651)
*/
}

BOOL SetSystemCursor(HCURSOR hcur,DWORD   id);

struct ICONINFO {
    BOOL    fIcon;
    DWORD   xHotspot;
    DWORD   yHotspot;
    HBITMAP hbmMask;
    HBITMAP hbmColor;
}
alias ICONINFO * PICONINFO;

//HICON LoadIconA(HINSTANCE hInstance,LPCSTR lpIconName);
HICON LoadIconW(HINSTANCE hInstance,LPCWSTR lpIconName);


//HICON CreateIcon( HINSTANCE hInstance,int nWidth,int nHeight,BYTE cPlanes,BYTE cBitsPixel,CONST BYTE *lpbANDbits,CONST BYTE *lpbXORbits);
HICON CreateIcon( HINSTANCE hInstance,int nWidth,int nHeight,BYTE cPlanes,BYTE cBitsPixel,BYTE *lpbANDbits,BYTE *lpbXORbits);
BOOL DestroyIcon(HICON hIcon);
int LookupIconIdFromDirectory(PBYTE presbits,BOOL fIcon);
int LookupIconIdFromDirectoryEx(PBYTE presbits,BOOL  fIcon,int   cxDesired,int   cyDesired,UINT  Flags);
HICON CreateIconFromResource(PBYTE presbits,DWORD dwResSize,BOOL fIcon,DWORD dwVer);
HICON CreateIconFromResourceEx(PBYTE presbits,DWORD dwResSize,BOOL  fIcon,DWORD dwVer,int   cxDesired,int   cyDesired,UINT  Flags);

/* Icon/Cursor header */
struct CURSORSHAPE
{
    int     xHotSpot;
    int     yHotSpot;
    int     cx;
    int     cy;
    int     cbWidth;
    BYTE    Planes;
    BYTE    BitsPixel;
} 
alias CURSORSHAPE * LPCURSORSHAPE;

enum {
IMAGE_BITMAP        =0,
IMAGE_ICON          =1,
IMAGE_CURSOR        =2,
IMAGE_ENHMETAFILE   =3
}

enum {
LR_DEFAULTCOLOR     =0x0000,
LR_MONOCHROME       =0x0001,
LR_COLOR            =0x0002,
LR_COPYRETURNORG    =0x0004,
LR_COPYDELETEORG    =0x0008,
LR_LOADFROMFILE     =0x0010,
LR_LOADTRANSPARENT  =0x0020,
LR_DEFAULTSIZE      =0x0040,
LR_VGACOLOR         =0x0080,
LR_LOADMAP3DCOLORS  =0x1000,
LR_CREATEDIBSECTION =0x2000,
LR_COPYFROMRESOURCE =0x4000,
LR_SHARED           =0x8000
}

HANDLE LoadImageA(HINSTANCE,LPCSTR,UINT,int,int,UINT);
HANDLE LoadImageW(HINSTANCE,LPCWSTR,UINT,int,int,UINT);

HANDLE CopyImage(HANDLE,UINT,int,int,UINT);

enum {
DI_MASK         =0x0001,
DI_IMAGE        =0x0002,
DI_NORMAL       =0x0003,
DI_COMPAT       =0x0004,
DI_DEFAULTSIZE  =0x0008
}

BOOL DrawIconEx(HDC hdc, int xLeft, int yTop,
              HICON hIcon, int cxWidth, int cyWidth,
              UINT istepIfAniCur, HBRUSH hbrFlickerFreeDraw, UINT diFlags);

HICON CreateIconIndirect(PICONINFO piconinfo);
HICON CopyIcon(HICON hIcon);
BOOL GetIconInfo(HICON hIcon,PICONINFO piconinfo);

enum {
RES_ICON    =1,
RES_CURSOR  =2
}


enum {
/*
 * OEM Resource Ordinal Numbers
 */
OBM_CLOSE           =32754,
OBM_UPARROW         =32753,
OBM_DNARROW         =32752,
OBM_RGARROW         =32751,
OBM_LFARROW         =32750,
OBM_REDUCE          =32749,
OBM_ZOOM            =32748,
OBM_RESTORE         =32747,
OBM_REDUCED         =32746,
OBM_ZOOMD           =32745,
OBM_RESTORED        =32744,
OBM_UPARROWD        =32743,
OBM_DNARROWD        =32742,
OBM_RGARROWD        =32741,
OBM_LFARROWD        =32740,
OBM_MNARROW         =32739,
OBM_COMBO           =32738,
OBM_UPARROWI        =32737,
OBM_DNARROWI        =32736,
OBM_RGARROWI        =32735,
OBM_LFARROWI        =32734,

OBM_OLD_CLOSE       =32767,
OBM_SIZE            =32766,
OBM_OLD_UPARROW     =32765,
OBM_OLD_DNARROW     =32764,
OBM_OLD_RGARROW     =32763,
OBM_OLD_LFARROW     =32762,
OBM_BTSIZE          =32761,
OBM_CHECK           =32760,
OBM_CHECKBOXES      =32759,
OBM_BTNCORNERS      =32758,
OBM_OLD_REDUCE      =32757,
OBM_OLD_ZOOM        =32756,
OBM_OLD_RESTORE     =32755
}

enum {
OCR_NORMAL          =32512,
OCR_IBEAM           =32513,
OCR_WAIT            =32514,
OCR_CROSS           =32515,
OCR_UP              =32516,
OCR_SIZE            =32640,   /* OBSOLETE: use OCR_SIZEALL */
OCR_ICON            =32641,   /* OBSOLETE: use OCR_NORMAL */
OCR_SIZENWSE        =32642,
OCR_SIZENESW        =32643,
OCR_SIZEWE          =32644,
OCR_SIZENS          =32645,
OCR_SIZEALL         =32646,
OCR_ICOCUR          =32647,  /* OBSOLETE: use OIC_WINLOGO */
OCR_NO              =32648,
OCR_APPSTARTING     =32650
}
enum  {
OIC_SAMPLE          =32512,
OIC_HAND            =32513,
OIC_QUES            =32514,
OIC_BANG            =32515,
OIC_NOTE            =32516,
OIC_WINLOGO         =32517,
OIC_WARNING         =OIC_BANG,
OIC_ERROR           =OIC_HAND,
OIC_INFORMATION     =OIC_NOTE,
}

enum {
ORD_LANGDRIVER    =1     /* The ordinal number for the entry point of
                                ** language drivers.
                                */
}

/*
 * Standard Icon IDs
 */
/*version(RC_INVOKED) {
	enum {
	IDI_APPLICATION     =32512,
	IDI_HAND            =32513,
	IDI_QUESTION        =32514,
	IDI_EXCLAMATION     =32515,
	IDI_ASTERISK        =32516,
	IDI_WINLOGO         =32517
	}
}else{*/
	enum {
		/*
	IDI_APPLICATION     =MAKEINTRESOURCE(32512),
	IDI_HAND            =MAKEINTRESOURCE(32513),
	IDI_QUESTION        =MAKEINTRESOURCE(32514),
	IDI_EXCLAMATION     =MAKEINTRESOURCE(32515),
	IDI_ASTERISK        =MAKEINTRESOURCE(32516),
	IDI_WINLOGO         =MAKEINTRESOURCE(32517)
		*/
//	IDI_APPLICATION     =(32512),
	IDI_HAND            =(32513),
	IDI_QUESTION        =(32514),
	IDI_EXCLAMATION     =(32515),
	IDI_ASTERISK        =(32516),
	IDI_WINLOGO         =(32517)
	}
//}

enum {
IDI_WARNING     =IDI_EXCLAMATION,
IDI_ERROR       =IDI_HAND,
IDI_INFORMATION =IDI_ASTERISK
}


int LoadStringA(HINSTANCE hInstance,UINT uID,LPSTR lpBuffer,int nBufferMax);
int LoadStringW(HINSTANCE hInstance,UINT uID,LPWSTR lpBuffer,int nBufferMax);


enum {
/*
 * Dialog Box Command IDs
 */
IDOK               = 1,
IDCANCEL           = 2,
IDABORT            = 3,
IDRETRY            = 4,
IDIGNORE           = 5,
IDYES              = 6,
IDNO               = 7,
IDCLOSE         =8,
IDHELP          =9
}


/*
 * Control Manager Structures and Definitions
 */
version(STANDALONE) {
enum {
/*
 * Edit Control Styles
 */
ES_LEFT             =0x0000,
ES_CENTER           =0x0001,
ES_RIGHT            =0x0002,
ES_MULTILINE        =0x0004,
ES_UPPERCASE        =0x0008,
ES_LOWERCASE        =0x0010,
ES_PASSWORD         =0x0020,
ES_AUTOVSCROLL      =0x0040,
ES_AUTOHSCROLL      =0x0080,
ES_NOHIDESEL        =0x0100,
ES_OEMCONVERT       =0x0400,
ES_READONLY         =0x0800,
ES_WANTRETURN       =0x1000,
ES_NUMBER           =0x2000
}
}

enum {
/*
 * Edit Control Notification Codes
 */
EN_SETFOCUS         =0x0100,
EN_KILLFOCUS        =0x0200,
EN_CHANGE           =0x0300,
EN_UPDATE           =0x0400,
EN_ERRSPACE         =0x0500,
EN_MAXTEXT          =0x0501,
EN_HSCROLL          =0x0601,
EN_VSCROLL          =0x0602
}

enum {
/* Edit control EM_SETMARGIN parameters */
EC_LEFTMARGIN       =0x0001,
EC_RIGHTMARGIN      =0x0002,
EC_USEFONTINFO      =0xffff
}

version(STANDALONE){
enum {
/*
 * Edit Control Messages
 */
EM_GETSEL               =0x00B0,
EM_SETSEL               =0x00B1,
EM_GETRECT              =0x00B2,
EM_SETRECT              =0x00B3,
EM_SETRECTNP            =0x00B4,
EM_SCROLL               =0x00B5,
EM_LINESCROLL           =0x00B6,
EM_SCROLLCARET          =0x00B7,
EM_GETMODIFY            =0x00B8,
EM_SETMODIFY            =0x00B9,
EM_GETLINECOUNT         =0x00BA,
EM_LINEINDEX            =0x00BB,
EM_SETHANDLE            =0x00BC,
EM_GETHANDLE            =0x00BD,
EM_GETTHUMB             =0x00BE,
EM_LINELENGTH           =0x00C1,
EM_REPLACESEL           =0x00C2,
EM_GETLINE              =0x00C4,
EM_LIMITTEXT            =0x00C5,
EM_CANUNDO              =0x00C6,
EM_UNDO                 =0x00C7,
EM_FMTLINES             =0x00C8,
EM_LINEFROMCHAR         =0x00C9,
EM_SETTABSTOPS          =0x00CB,
EM_SETPASSWORDCHAR      =0x00CC,
EM_EMPTYUNDOBUFFER      =0x00CD,
EM_GETFIRSTVISIBLELINE  =0x00CE,
EM_SETREADONLY          =0x00CF,
EM_SETWORDBREAKPROC     =0x00D0,
EM_GETWORDBREAKPROC     =0x00D1,
EM_GETPASSWORDCHAR      =0x00D2,
EM_SETMARGINS           =0x00D3,
EM_GETMARGINS           =0x00D4,
EM_SETLIMITTEXT         =EM_LIMITTEXT,   /* ;win40 Name change */
EM_GETLIMITTEXT         =0x00D5,
EM_POSFROMCHAR          =0x00D6,
EM_CHARFROMPOS          =0x00D7
}
} else {
}

enum {
/*
 * EDITWORDBREAKPROC code values
 */
WB_LEFT            =0,
WB_RIGHT           =1,
WB_ISDELIMITER     =2
}

enum {
/*
 * Button Control Styles
 */
BS_PUSHBUTTON       =0x00000000,
BS_DEFPUSHBUTTON    =0x00000001,
BS_CHECKBOX         =0x00000002,
BS_AUTOCHECKBOX     =0x00000003,
BS_RADIOBUTTON      =0x00000004,
BS_3STATE           =0x00000005,
BS_AUTO3STATE       =0x00000006,
BS_GROUPBOX         =0x00000007,
BS_USERBUTTON       =0x00000008,
BS_AUTORADIOBUTTON  =0x00000009,
BS_OWNERDRAW        =0x0000000B,
BS_LEFTTEXT         =0x00000020,
BS_TEXT             =0x00000000,
BS_ICON             =0x00000040,
BS_BITMAP           =0x00000080,
BS_LEFT             =0x00000100,
BS_RIGHT            =0x00000200,
BS_CENTER           =0x00000300,
BS_TOP              =0x00000400,
BS_BOTTOM           =0x00000800,
BS_VCENTER          =0x00000C00,
BS_PUSHLIKE         =0x00001000,
BS_MULTILINE        =0x00002000,
BS_NOTIFY           =0x00004000,
BS_FLAT             =0x00008000,
BS_RIGHTBUTTON      =BS_LEFTTEXT
}

enum {
/*
 * User Button Notification Codes
 */
//BN_CLICKED          =0,
BN_PAINT            =1,
BN_HILITE           =2,
BN_UNHILITE         =3,
BN_DISABLE          =4,
BN_DOUBLECLICKED    =5,
BN_PUSHED           =BN_HILITE,
BN_UNPUSHED         =BN_UNHILITE,
BN_DBLCLK           =BN_DOUBLECLICKED,
BN_SETFOCUS         =6,
BN_KILLFOCUS        =7
}

version(STANDALONE){
enum {
/*
 * Button Control Messages
 */
BM_GETCHECK        =0x00F0,
BM_SETCHECK        =0x00F1,
BM_GETSTATE        =0x00F2,
BM_SETSTATE        =0x00F3,
BM_SETSTYLE        =0x00F4,
BM_CLICK           =0x00F5,
BM_GETIMAGE        =0x00F6,
BM_SETIMAGE        =0x00F7
}
}

enum {
BST_UNCHECKED      =0x0000,
BST_CHECKED        =0x0001,
BST_INDETERMINATE  =0x0002,
BST_PUSHED         =0x0004,
BST_FOCUS          =0x0008
}

enum {
/*
 * Static Control Constants
 */
SS_LEFT             =0x00000000,
SS_CENTER           =0x00000001,
SS_RIGHT            =0x00000002,
SS_ICON             =0x00000003,
SS_BLACKRECT        =0x00000004,
SS_GRAYRECT         =0x00000005,
SS_WHITERECT        =0x00000006,
SS_BLACKFRAME       =0x00000007,
SS_GRAYFRAME        =0x00000008,
SS_WHITEFRAME       =0x00000009,
SS_USERITEM         =0x0000000A,
SS_SIMPLE           =0x0000000B,
SS_LEFTNOWORDWRAP   =0x0000000C,
SS_OWNERDRAW        =0x0000000D,
SS_BITMAP           =0x0000000E,
SS_ENHMETAFILE      =0x0000000F,
SS_ETCHEDHORZ       =0x00000010,
SS_ETCHEDVERT       =0x00000011,
SS_ETCHEDFRAME      =0x00000012,
SS_TYPEMASK         =0x0000001F,
SS_NOPREFIX         =0x00000080, /* Don't do "&" character translation */
SS_NOTIFY           =0x00000100,
SS_CENTERIMAGE      =0x00000200,
SS_RIGHTJUST        =0x00000400,
SS_REALSIZEIMAGE    =0x00000800,
SS_SUNKEN           =0x00001000,
SS_ENDELLIPSIS      =0x00004000,
SS_PATHELLIPSIS     =0x00008000,
SS_WORDELLIPSIS     =0x0000C000,
SS_ELLIPSISMASK     =0x0000C000
}

enum {
/*
 * Static Control Mesages
 */
STM_SETICON         =0x0170,
STM_GETICON         =0x0171,
STM_SETIMAGE        =0x0172,
STM_GETIMAGE        =0x0173,
STM_MSGMAX          =0x0174
}

enum {
STN_CLICKED         =0,
STN_DBLCLK          =1,
STN_ENABLE          =2,
STN_DISABLE         =3
}

/*
 * Dialog window class
 */
const ATOM WC_DIALOG       =((ATOM)(0x8002));

enum {
/*
 * Get/SetWindowWord/Long offsets for use with WC_DIALOG windows
 */
DWL_MSGRESULT   =0,
DWL_DLGPROC     =4,
DWL_USER        =8
}
/*
 * Dialog Manager Routines
 */

BOOL IsDialogMessageA(HWND hDlg,LPMSG lpMsg);
BOOL IsDialogMessageW(HWND hDlg,LPMSG lpMsg);

BOOL MapDialogRect(HWND hDlg,LPRECT lpRect);

int DlgDirListA(HWND hDlg,LPSTR lpPathSpec,int nIDListBox,int nIDStaticPath,UINT uFileType);
int DlgDirListW(HWND hDlg,LPWSTR lpPathSpec,int nIDListBox,int nIDStaticPath,UINT uFileType);

enum {
/*
 * DlgDirList, DlgDirListComboBox flags values
 */
DDL_READWRITE       =0x0000,
DDL_READONLY        =0x0001,
DDL_HIDDEN          =0x0002,
DDL_SYSTEM          =0x0004,
DDL_DIRECTORY       =0x0010,
DDL_ARCHIVE         =0x0020,

DDL_POSTMSGS        =0x2000,
DDL_DRIVES          =0x4000,
DDL_EXCLUSIVE       =0x8000
}


BOOL DlgDirSelectExA(HWND hDlg,LPSTR lpString,int nCount,int nIDListBox);
BOOL DlgDirSelectExW(HWND hDlg,LPWSTR lpString,int nCount,int nIDListBox);

int DlgDirListComboBoxA(HWND hDlg,LPSTR lpPathSpec,int nIDComboBox,int nIDStaticPath,UINT uFiletype);
int DlgDirListComboBoxW(HWND hDlg,LPWSTR lpPathSpec,int nIDComboBox,int nIDStaticPath,UINT uFiletype);

BOOL DlgDirSelectComboBoxExA(HWND hDlg,LPSTR lpString,int nCount,int nIDComboBox);
BOOL DlgDirSelectComboBoxExW(HWND hDlg,LPWSTR lpString,int nCount,int nIDComboBox);

enum {
/*
 * Dialog Styles
 */
DS_ABSALIGN         =0x01,
DS_SYSMODAL         =0x02,
DS_LOCALEDIT        =0x20,   /* Edit items get Local storage. */
DS_SETFONT          =0x40,   /* User specified font for Dlg controls */
DS_MODALFRAME       =0x80,   /* Can be combined with WS_CAPTION  */
DS_NOIDLEMSG        =0x100,  /* WM_ENTERIDLE message will not be sent */
DS_SETFOREGROUND    =0x200,  /* not in win3.1 */

DS_3DLOOK           =0x0004,
DS_FIXEDSYS         =0x0008,
DS_NOFAILCREATE     =0x0010,
DS_CONTROL          =0x0400,
DS_CENTER           =0x0800,
DS_CENTERMOUSE      =0x1000,
DS_CONTEXTHELP      =0x2000
}

enum {
DM_GETDEFID         =(WM_USER+0),
DM_SETDEFID         =(WM_USER+1),
DM_REPOSITION       =(WM_USER+2)
}

enum {
PSM_PAGEINFO        =(WM_USER+100),
PSM_SHEETINFO       =(WM_USER+101)
}

enum {
PSI_SETACTIVE       =0x0001,
PSI_KILLACTIVE      =0x0002,
PSI_APPLY           =0x0003,
PSI_RESET           =0x0004,
PSI_HASHELP         =0x0005,
PSI_HELP            =0x0006,

PSI_CHANGED         =0x0001,
PSI_GUISTART        =0x0002,
PSI_REBOOT          =0x0003,
PSI_GETSIBLINGS     =0x0004
}

enum {
/*
 * Returned in HIWORD() of DM_GETDEFID result if msg is supported
 */
DC_HASDEFID         =0x534B
}

enum {
/*
 * Dialog Codes
 */
DLGC_WANTARROWS     =0x0001,      /* Control wants arrow keys         */
DLGC_WANTTAB        =0x0002,      /* Control wants tab keys           */
DLGC_WANTALLKEYS    =0x0004,      /* Control wants all keys           */
DLGC_WANTMESSAGE    =0x0004,      /* Pass message to control          */
DLGC_HASSETSEL      =0x0008,      /* Understands EM_SETSEL message    */
DLGC_DEFPUSHBUTTON  =0x0010,      /* Default pushbutton               */
DLGC_UNDEFPUSHBUTTON =0x0020,     /* Non-default pushbutton           */
DLGC_RADIOBUTTON    =0x0040,      /* Radio button                     */
DLGC_WANTCHARS      =0x0080,      /* Want WM_CHAR messages            */
DLGC_STATIC         =0x0100,      /* Static item: don't include       */
DLGC_BUTTON         =0x2000       /* Button item: can be checked      */
}

enum {

LB_CTLCODE          =0,

/*
 * Listbox Return Values
 */
LB_OKAY             =0,
LB_ERR              =(-1),
LB_ERRSPACE         =(-2)
}

/*
**  The idStaticPath parameter to DlgDirList can have the following values
**  ORed if the list box should show other details of the files along with
**  the name of the files;
*/
                                  /* all other details also will be returned */


enum {
/*
 * Listbox Notification Codes
 */
LBN_ERRSPACE        =(-2),
LBN_SELCHANGE       =1,
LBN_DBLCLK          =2,
LBN_SELCANCEL       =3,
LBN_SETFOCUS        =4,
LBN_KILLFOCUS       =5
}

enum {
/*
 * Listbox messages
 */
LB_ADDSTRING            =0x0180,
LB_INSERTSTRING         =0x0181,
LB_DELETESTRING         =0x0182,
LB_SELITEMRANGEEX       =0x0183,
LB_RESETCONTENT         =0x0184,
LB_SETSEL               =0x0185,
LB_SETCURSEL            =0x0186,
LB_GETSEL               =0x0187,
LB_GETCURSEL            =0x0188,
LB_GETTEXT              =0x0189,
LB_GETTEXTLEN           =0x018A,
LB_GETCOUNT             =0x018B,
LB_SELECTSTRING         =0x018C,
LB_DIR                  =0x018D,
LB_GETTOPINDEX          =0x018E,
LB_FINDSTRING           =0x018F,
LB_GETSELCOUNT          =0x0190,
LB_GETSELITEMS          =0x0191,
LB_SETTABSTOPS          =0x0192,
LB_GETHORIZONTALEXTENT  =0x0193,
LB_SETHORIZONTALEXTENT  =0x0194,
LB_SETCOLUMNWIDTH       =0x0195,
LB_ADDFILE              =0x0196,
LB_SETTOPINDEX          =0x0197,
LB_GETITEMRECT          =0x0198,
LB_GETITEMDATA          =0x0199,
LB_SETITEMDATA          =0x019A,
LB_SELITEMRANGE         =0x019B,
LB_SETANCHORINDEX       =0x019C,
LB_GETANCHORINDEX       =0x019D,
LB_SETCARETINDEX        =0x019E,
LB_GETCARETINDEX        =0x019F,
LB_SETITEMHEIGHT        =0x01A0,
LB_GETITEMHEIGHT        =0x01A1,
LB_FINDSTRINGEXACT      =0x01A2,
LB_SETLOCALE            =0x01A5,
LB_GETLOCALE            =0x01A6,
LB_SETCOUNT             =0x01A7,
LB_INITSTORAGE          =0x01A8,
LB_ITEMFROMPOINT        =0x01A9,
LB_MSGMAX               =0x01B0
}

enum {
/*
 * Listbox Styles
 */
LBS_NOTIFY            =0x0001,
LBS_SORT              =0x0002,
LBS_NOREDRAW          =0x0004,
LBS_MULTIPLESEL       =0x0008,
LBS_OWNERDRAWFIXED    =0x0010,
LBS_OWNERDRAWVARIABLE =0x0020,
LBS_HASSTRINGS        =0x0040,
LBS_USETABSTOPS       =0x0080,
LBS_NOINTEGRALHEIGHT  =0x0100,
LBS_MULTICOLUMN       =0x0200,
LBS_WANTKEYBOARDINPUT =0x0400,
LBS_EXTENDEDSEL       =0x0800,
LBS_DISABLENOSCROLL   =0x1000,
LBS_NODATA            =0x2000,
LBS_NOSEL             =0x4000,
LBS_STANDARD          =(LBS_NOTIFY | LBS_SORT | WS_VSCROLL | WS_BORDER)
}

enum {
/*
 * Combo Box return Values
 */
CB_OKAY             =0,
CB_ERR              =(-1),
CB_ERRSPACE         =(-2)
}

enum {
/*
 * Combo Box Notification Codes
 */
CBN_ERRSPACE        =(-1),
CBN_SELCHANGE       =1,
CBN_DBLCLK          =2,
CBN_SETFOCUS        =3,
CBN_KILLFOCUS       =4,
CBN_EDITCHANGE      =5,
CBN_EDITUPDATE      =6,
CBN_DROPDOWN        =7,
CBN_CLOSEUP         =8,
CBN_SELENDOK        =9,
CBN_SELENDCANCEL    =10
}

enum {
/*
 * Combo Box styles
 */
CBS_SIMPLE            =0x0001,
CBS_DROPDOWN          =0x0002,
CBS_DROPDOWNLIST      =0x0003,
CBS_OWNERDRAWFIXED    =0x0010,
CBS_OWNERDRAWVARIABLE =0x0020,
CBS_AUTOHSCROLL       =0x0040,
CBS_OEMCONVERT        =0x0080,
CBS_SORT              =0x0100,
CBS_HASSTRINGS        =0x0200,
CBS_NOINTEGRALHEIGHT  =0x0400,
CBS_DISABLENOSCROLL   =0x0800,
CBS_UPPERCASE           =0x2000,
CBS_LOWERCASE           =0x4000
}


enum {
/*
 * Combo Box messages
 */
CB_GETEDITSEL               =0x0140,
CB_LIMITTEXT                =0x0141,
CB_SETEDITSEL               =0x0142,
CB_ADDSTRING                =0x0143,
CB_DELETESTRING             =0x0144,
CB_DIR                      =0x0145,
CB_GETCOUNT                 =0x0146,
CB_GETCURSEL                =0x0147,
CB_GETLBTEXT                =0x0148,
CB_GETLBTEXTLEN             =0x0149,
CB_INSERTSTRING             =0x014A,
CB_RESETCONTENT             =0x014B,
CB_FINDSTRING               =0x014C,
CB_SELECTSTRING             =0x014D,
CB_SETCURSEL                =0x014E,
CB_SHOWDROPDOWN             =0x014F,
CB_GETITEMDATA              =0x0150,
CB_SETITEMDATA              =0x0151,
CB_GETDROPPEDCONTROLRECT    =0x0152,
CB_SETITEMHEIGHT            =0x0153,
CB_GETITEMHEIGHT            =0x0154,
CB_SETEXTENDEDUI            =0x0155,
CB_GETEXTENDEDUI            =0x0156,
CB_GETDROPPEDSTATE          =0x0157,
CB_FINDSTRINGEXACT          =0x0158,
CB_SETLOCALE                =0x0159,
CB_GETLOCALE                =0x015A,
CB_GETTOPINDEX              =0x015b,
CB_SETTOPINDEX              =0x015c,
CB_GETHORIZONTALEXTENT      =0x015d,
CB_SETHORIZONTALEXTENT      =0x015e,
CB_GETDROPPEDWIDTH          =0x015f,
CB_SETDROPPEDWIDTH          =0x0160,
CB_INITSTORAGE              =0x0161,
CB_MSGMAX                   =0x0162
}

enum {
/*
 * Scroll Bar Styles
 */
SBS_HORZ                    =0x0000,
SBS_VERT                    =0x0001,
SBS_TOPALIGN                =0x0002,
SBS_LEFTALIGN               =0x0002,
SBS_BOTTOMALIGN             =0x0004,
SBS_RIGHTALIGN              =0x0004,
SBS_SIZEBOXTOPLEFTALIGN     =0x0002,
SBS_SIZEBOXBOTTOMRIGHTALIGN =0x0004,
SBS_SIZEBOX                 =0x0008,
SBS_SIZEGRIP                =0x0010
}

enum {
/*
 * Scroll bar messages
 */
SBM_SETPOS                  =0x00E0, /*not in win3.1 */
SBM_GETPOS                  =0x00E1, /*not in win3.1 */
SBM_SETRANGE                =0x00E2, /*not in win3.1 */
SBM_SETRANGEREDRAW          =0x00E6, /*not in win3.1 */
SBM_GETRANGE                =0x00E3, /*not in win3.1 */
SBM_ENABLE_ARROWS           =0x00E4, /*not in win3.1 */
SBM_SETSCROLLINFO           =0x00E9,
SBM_GETSCROLLINFO           =0x00EA
}

enum {
SIF_RANGE           =0x0001,
SIF_PAGE            =0x0002,
SIF_POS             =0x0004,
SIF_DISABLENOSCROLL =0x0008,
SIF_TRACKPOS        =0x0010,
SIF_ALL             =(SIF_RANGE | SIF_PAGE | SIF_POS | SIF_TRACKPOS)
}

struct SCROLLINFO
{
    UINT    cbSize;
    UINT    fMask;
    int     nMin;
    int     nMax;
    UINT    nPage;
    int     nPos;
    int     nTrackPos;
}   
alias SCROLLINFO * LPSCROLLINFO;
//alias SCROLLINFO CONST FAR *LPCSCROLLINFO;
alias SCROLLINFO * LPCSCROLLINFO;

int  SetScrollInfo(HWND, int, LPCSCROLLINFO, BOOL);
BOOL GetScrollInfo(HWND, int, LPSCROLLINFO);

enum {
/*
 * MDI client style bits
 */
MDIS_ALLCHILDSTYLES    =0x0001
}

enum {
/*
 * wParam Flags for WM_MDITILE and WM_MDICASCADE messages.
 */
MDITILE_VERTICAL       =0x0000, /*not in win3.1 */
MDITILE_HORIZONTAL     =0x0001, /*not in win3.1 */
MDITILE_SKIPDISABLED   =0x0002  /*not in win3.1 */
}

struct MDICREATESTRUCTA {
    LPCSTR   szClass;
    LPCSTR   szTitle;
    HANDLE hOwner;
    int x;
    int y;
    int cx;
    int cy;
    DWORD style;
    LPARAM lParam;        /* app-defined stuff */
} 
alias MDICREATESTRUCTA  * LPMDICREATESTRUCTA;
struct MDICREATESTRUCTW {
    LPCWSTR  szClass;
    LPCWSTR  szTitle;
    HANDLE hOwner;
    int x;
    int y;
    int cx;
    int cy;
    DWORD style;
    LPARAM lParam;        /* app-defined stuff */
} 
alias MDICREATESTRUCTW * LPMDICREATESTRUCTW;

struct CLIENTCREATESTRUCT {
    HANDLE hWindowMenu;
    UINT idFirstChild;
} 
alias CLIENTCREATESTRUCT * LPCLIENTCREATESTRUCT;

LRESULT DefFrameProcA(HWND hWnd,HWND hWndMDIClient,UINT uMsg,WPARAM wParam,LPARAM lParam);
LRESULT DefFrameProcW(HWND hWnd,HWND hWndMDIClient ,UINT uMsg,WPARAM wParam,LPARAM lParam);

LRESULT DefMDIChildProcA(HWND hWnd,UINT uMsg,WPARAM wParam,LPARAM lParam);
LRESULT DefMDIChildProcW(HWND hWnd,UINT uMsg,WPARAM wParam,LPARAM lParam);

BOOL TranslateMDISysAccel(HWND hWndClient,LPMSG lpMsg);
UINT ArrangeIconicWindows(HWND hWnd);

HWND CreateMDIWindowA(LPSTR lpClassName,LPSTR lpWindowName,DWORD dwStyle,int X,int Y,int nWidth,int nHeight,HWND hWndParent,HINSTANCE hInstance,LPARAM lParam);
HWND CreateMDIWindowW(LPWSTR lpClassName,LPWSTR lpWindowName,DWORD dwStyle,int X,int Y,int nWidth,int nHeight,HWND hWndParent,HINSTANCE hInstance,LPARAM lParam);

//WORD TileWindows(HWND hwndParent, UINT wHow, CONST RECT * lpRect, UINT cKids, const HWND FAR * lpKids);
//WORD CascadeWindows(HWND hwndParent, UINT wHow, CONST RECT * lpRect, UINT cKids,  const HWND FAR * lpKids);
WORD TileWindows(HWND hwndParent, UINT wHow, RECT * lpRect, UINT cKids, HWND * lpKids);
WORD CascadeWindows(HWND hwndParent, UINT wHow, RECT * lpRect, UINT cKids, HWND * lpKids);

/****** Help support ********************************************************/


alias DWORD HELPPOLY;
struct MULTIKEYHELPA {
    DWORD  mkSize;
    CHAR   mkKeylist;
    CHAR   szKeyphrase[1];
} 
alias MULTIKEYHELPA * PMULTIKEYHELPA,LPMULTIKEYHELPA;

struct MULTIKEYHELPW {
    DWORD  mkSize;
    WCHAR  mkKeylist;
    WCHAR  szKeyphrase[1];
} 
alias MULTIKEYHELPW * PMULTIKEYHELPW,LPMULTIKEYHELPW;

struct HELPWININFOA {
    int  wStructSize;
    int  x;
    int  y;
    int  dx;
    int  dy;
    int  wMax;
    CHAR   rgchMember[2];
} 
alias HELPWININFOA * PHELPWININFOA;
alias HELPWININFOA * LPHELPWININFOA;
struct HELPWININFOW {
    int  wStructSize;
    int  x;
    int  y;
    int  dx;
    int  dy;
    int  wMax;
    WCHAR  rgchMember[2];
} 
alias HELPWININFOW * PHELPWININFOW;
alias HELPWININFOW * LPHELPWININFOW;

enum {
/*
 * Commands to pass to WinHelp()
 */
HELP_CONTEXT      =0x0001,  /* Display topic in ulTopic */
HELP_QUIT         =0x0002,  /* Terminate help */
HELP_INDEX        =0x0003,  /* Display index */
HELP_CONTENTS     =0x0003,
HELP_HELPONHELP   =0x0004,  /* Display help on using help */
HELP_SETINDEX     =0x0005,  /* Set current Index for multi index help */
HELP_SETCONTENTS  =0x0005,
HELP_CONTEXTPOPUP =0x0008,
HELP_FORCEFILE    =0x0009,
HELP_KEY          =0x0101,  /* Display topic for keyword in offabData */
HELP_COMMAND      =0x0102,
HELP_PARTIALKEY   =0x0105,
HELP_MULTIKEY     =0x0201,
HELP_SETWINPOS    =0x0203,
HELP_CONTEXTMENU  =0x000a,
HELP_FINDER       =0x000b,
HELP_WM_HELP      =0x000c,
HELP_SETPOPUP_POS =0x000d,
HELP_TCARD              =0x8000,
HELP_TCARD_DATA         =0x0010,
HELP_TCARD_OTHER_CALLER =0x0011
}

enum {
// These are in winhelp.h in Win95.
IDH_NO_HELP                     =28440,
IDH_MISSING_CONTEXT             =28441, // Control doesn't have matching help context
IDH_GENERIC_HELP_BUTTON         =28442, // Property sheet help button
IDH_OK                          =28443,
IDH_CANCEL                      =28444,
IDH_HELP                        =28445
}

BOOL WinHelpA(HWND hWndMain,LPCSTR lpszHelp,UINT uCommand,DWORD dwData);
BOOL WinHelpW(HWND hWndMain,LPCWSTR lpszHelp,UINT uCommand,DWORD dwData);

enum {
/*
 * Parameter for SystemParametersInfo()
 */
SPI_GETBEEP                = 1,
SPI_SETBEEP                = 2,
SPI_GETMOUSE               = 3,
SPI_SETMOUSE               = 4,
SPI_GETBORDER              = 5,
SPI_SETBORDER              =6,
SPI_GETKEYBOARDSPEED       =10,
SPI_SETKEYBOARDSPEED       =11,
SPI_LANGDRIVER             =12,
SPI_ICONHORIZONTALSPACING  =13,
SPI_GETSCREENSAVETIMEOUT   =14,
SPI_SETSCREENSAVETIMEOUT   =15,
SPI_GETSCREENSAVEACTIVE    =16,
SPI_SETSCREENSAVEACTIVE    =17,
SPI_GETGRIDGRANULARITY     =18,
SPI_SETGRIDGRANULARITY     =19,
SPI_SETDESKWALLPAPER       =20,
SPI_SETDESKPATTERN         =21,
SPI_GETKEYBOARDDELAY       =22,
SPI_SETKEYBOARDDELAY       =23,
SPI_ICONVERTICALSPACING    =24,
SPI_GETICONTITLEWRAP       =25,
SPI_SETICONTITLEWRAP       =26,
SPI_GETMENUDROPALIGNMENT   =27,
SPI_SETMENUDROPALIGNMENT   =28,
SPI_SETDOUBLECLKWIDTH      =29,
SPI_SETDOUBLECLKHEIGHT     =30,
SPI_GETICONTITLELOGFONT    =31,
SPI_SETDOUBLECLICKTIME     =32,
SPI_SETMOUSEBUTTONSWAP     =33,
SPI_SETICONTITLELOGFONT    =34,
SPI_GETFASTTASKSWITCH      =35,
SPI_SETFASTTASKSWITCH      =36,
SPI_SETDRAGFULLWINDOWS     =37,
SPI_GETDRAGFULLWINDOWS     =38,
SPI_GETNONCLIENTMETRICS    =41,
SPI_SETNONCLIENTMETRICS    =42,
SPI_GETMINIMIZEDMETRICS    =43,
SPI_SETMINIMIZEDMETRICS    =44,
SPI_GETICONMETRICS         =45,
SPI_SETICONMETRICS         =46,
SPI_SETWORKAREA            =47,
SPI_GETWORKAREA            =48,
SPI_SETPENWINDOWS          =49,
SPI_GETFILTERKEYS          =50,
SPI_SETFILTERKEYS          =51,
SPI_GETTOGGLEKEYS          =52,
SPI_SETTOGGLEKEYS          =53,
SPI_GETMOUSEKEYS           =54,
SPI_SETMOUSEKEYS           =55,
SPI_GETSHOWSOUNDS          =56,
SPI_SETSHOWSOUNDS          =57,
SPI_GETSTICKYKEYS          =58,
SPI_SETSTICKYKEYS          =59,
SPI_GETACCESSTIMEOUT       =60,
SPI_SETACCESSTIMEOUT       =61,
SPI_GETSERIALKEYS          =62,
SPI_SETSERIALKEYS          =63,
SPI_GETSOUNDSENTRY         =64,
SPI_SETSOUNDSENTRY         =65,
SPI_GETHIGHCONTRAST        =66,
SPI_SETHIGHCONTRAST        =67,
SPI_GETKEYBOARDPREF        =68,
SPI_SETKEYBOARDPREF        =69,
SPI_GETSCREENREADER        =70,
SPI_SETSCREENREADER        =71,
SPI_GETANIMATION           =72,
SPI_SETANIMATION           =73,
SPI_GETFONTSMOOTHING       =74,
SPI_SETFONTSMOOTHING       =75,
SPI_SETDRAGWIDTH           =76,
SPI_SETDRAGHEIGHT          =77,
SPI_SETHANDHELD            =78,
SPI_GETLOWPOWERTIMEOUT     =79,
SPI_GETPOWEROFFTIMEOUT     =80,
SPI_SETLOWPOWERTIMEOUT     =81,
SPI_SETPOWEROFFTIMEOUT     =82,
SPI_GETLOWPOWERACTIVE      =83,
SPI_GETPOWEROFFACTIVE      =84,
SPI_SETLOWPOWERACTIVE      =85,
SPI_SETPOWEROFFACTIVE      =86,
SPI_SETCURSORS             =87,
SPI_SETICONS               =88,
SPI_GETDEFAULTINPUTLANG    =89,
SPI_SETDEFAULTINPUTLANG    =90,
SPI_SETLANGTOGGLE          =91,
SPI_GETWINDOWSEXTENSION    =92,
SPI_SETMOUSETRAILS         =93,
SPI_GETMOUSETRAILS         =94,
SPI_SCREENSAVERRUNNING     =97,
SPI_GETSNAPTODEFBUTTON     =95,
SPI_SETSNAPTODEFBUTTON     =96,
SPI_GETMOUSEHOVERWIDTH     =98,
SPI_SETMOUSEHOVERWIDTH     =99,
SPI_GETMOUSEHOVERHEIGHT   =100,
SPI_SETMOUSEHOVERHEIGHT   =101,
SPI_GETMOUSEHOVERTIME     =102,
SPI_SETMOUSEHOVERTIME     =103,
SPI_GETWHEELSCROLLLINES   =104,
SPI_SETWHEELSCROLLLINES   =105
}

enum {
/*
 * SPI User Preferences.
 */

/*
 * Flags
 */
SPIF_UPDATEINIFILE    =0x0001,
SPIF_SENDWININICHANGE =0x0002,
SPIF_SENDCHANGE       =SPIF_SENDWININICHANGE
}

enum { METRICS_USEDEFAULT =-1 }

struct NONCLIENTMETRICSA {
    UINT    cbSize;
    int     iBorderWidth;
    int     iScrollWidth;
    int     iScrollHeight;
    int     iCaptionWidth;
    int     iCaptionHeight;
    LOGFONTA lfCaptionFont;
    int     iSmCaptionWidth;
    int     iSmCaptionHeight;
    LOGFONTA lfSmCaptionFont;
    int     iMenuWidth;
    int     iMenuHeight;
    LOGFONTA lfMenuFont;
    LOGFONTA lfStatusFont;
    LOGFONTA lfMessageFont;
}   
alias NONCLIENTMETRICSA * PNONCLIENTMETRICSA;
alias NONCLIENTMETRICSA * LPNONCLIENTMETRICSA;

struct NONCLIENTMETRICSW {
    UINT    cbSize;
    int     iBorderWidth;
    int     iScrollWidth;
    int     iScrollHeight;
    int     iCaptionWidth;
    int     iCaptionHeight;
    LOGFONTW lfCaptionFont;
    int     iSmCaptionWidth;
    int     iSmCaptionHeight;
    LOGFONTW lfSmCaptionFont;
    int     iMenuWidth;
    int     iMenuHeight;
    LOGFONTW lfMenuFont;
    LOGFONTW lfStatusFont;
    LOGFONTW lfMessageFont;
}   
alias NONCLIENTMETRICSW * PNONCLIENTMETRICSW;
alias NONCLIENTMETRICSW * LPNONCLIENTMETRICSW;

enum {
ARW_BOTTOMLEFT              =0x0000,
ARW_BOTTOMRIGHT             =0x0001,
ARW_TOPLEFT                 =0x0002,
ARW_TOPRIGHT                =0x0003,
ARW_STARTMASK               =0x0003,
ARW_STARTRIGHT              =0x0001,
ARW_STARTTOP                =0x0002,

ARW_LEFT                    =0x0000,
ARW_RIGHT                   =0x0000,
ARW_UP                      =0x0004,
ARW_DOWN                    =0x0004,
ARW_HIDE                    =0x0008,
ARW_VALID                   =0x000F
}

struct MINIMIZEDMETRICS
{
    UINT    cbSize;
    int     iWidth;
    int     iHorzGap;
    int     iVertGap;
    int     iArrange;
}   
alias MINIMIZEDMETRICS * PMINIMIZEDMETRICS;
alias MINIMIZEDMETRICS * LPMINIMIZEDMETRICS;

struct ICONMETRICSA
{
    UINT    cbSize;
    int     iHorzSpacing;
    int     iVertSpacing;
    int     iTitleWrap;
    LOGFONTA lfFont;
}   
alias ICONMETRICSA * PICONMETRICSA;
alias ICONMETRICSA * LPICONMETRICSA;

struct ICONMETRICSW
{
    UINT    cbSize;
    int     iHorzSpacing;
    int     iVertSpacing;
    int     iTitleWrap;
    LOGFONTW lfFont;
}   
alias ICONMETRICSW * PICONMETRICSW;
alias ICONMETRICSW * LPICONMETRICSW;

struct ANIMATIONINFO {
    UINT    cbSize;
    int     iMinAnimate;
}
alias ANIMATIONINFO * LPANIMATIONINFO;

struct SERIALKEYSA {
    UINT    cbSize;
    DWORD   dwFlags;
    LPSTR     lpszActivePort;
    LPSTR     lpszPort;
    UINT    iBaudRate;
    UINT    iPortState;
    UINT    iActive;
}
alias SERIALKEYSA * LPSERIALKEYSA;

struct SERIALKEYSW {
    UINT    cbSize;
    DWORD   dwFlags;
    LPWSTR    lpszActivePort;
    LPWSTR    lpszPort;
    UINT    iBaudRate;
    UINT    iPortState;
    UINT    iActive;
}
alias SERIALKEYSW * LPSERIALKEYSW;

enum {
/* flags for SERIALKEYS dwFlags field */
SERKF_SERIALKEYSON  =0x00000001,
SERKF_AVAILABLE     =0x00000002,
SERKF_INDICATOR     =0x00000004
}

struct HIGHCONTRASTA
{
    UINT    cbSize;
    DWORD   dwFlags;
    LPSTR   lpszDefaultScheme;
}   
alias HIGHCONTRASTA * LPHIGHCONTRASTA;
struct HIGHCONTRASTW
{
    UINT    cbSize;
    DWORD   dwFlags;
    LPWSTR  lpszDefaultScheme;
}   
alias HIGHCONTRASTW * LPHIGHCONTRASTW;

enum {
/* flags for HIGHCONTRAST dwFlags field */
HCF_HIGHCONTRASTON  =0x00000001,
HCF_AVAILABLE       =0x00000002,
HCF_HOTKEYACTIVE    =0x00000004,
HCF_CONFIRMHOTKEY   =0x00000008,
HCF_HOTKEYSOUND     =0x00000010,
HCF_INDICATOR       =0x00000020,
HCF_HOTKEYAVAILABLE =0x00000040
}
enum {
/* Flags for ChangeDisplaySettings */
CDS_UPDATEREGISTRY  =0x00000001,
CDS_TEST            =0x00000002,
CDS_FULLSCREEN      =0x00000004,
CDS_GLOBAL          =0x00000008,
CDS_SET_PRIMARY     =0x00000010,
CDS_RESET           =0x40000000,
CDS_SETRECT         =0x20000000,
CDS_NORESET         =0x10000000
}

enum{
/* Return values for ChangeDisplaySettings */
DISP_CHANGE_SUCCESSFUL      = 0,
DISP_CHANGE_RESTART         = 1,
DISP_CHANGE_FAILED          =-1,
DISP_CHANGE_BADMODE         =-2,
DISP_CHANGE_NOTUPDATED      =-3,
DISP_CHANGE_BADFLAGS        =-4,
DISP_CHANGE_BADPARAM        =-5
}

LONG ChangeDisplaySettingsA(LPDEVMODEA  lpDevMode,DWORD       dwFlags);
LONG ChangeDisplaySettingsW(LPDEVMODEW  lpDevMode,DWORD       dwFlags);

LONG ChangeDisplaySettingsExA(LPCSTR    lpszDeviceName,LPDEVMODEA  lpDevMode,HWND        hwnd,DWORD       dwflags,LPVOID      lParam);
LONG ChangeDisplaySettingsExW(LPCWSTR    lpszDeviceName,LPDEVMODEW  lpDevMode,HWND        hwnd,DWORD       dwflags,LPVOID      lParam);

const DWORD ENUM_CURRENT_SETTINGS       =((DWORD)-1);
const DWORD ENUM_REGISTRY_SETTINGS      =((DWORD)-2);

BOOL EnumDisplaySettingsA(LPCSTR lpszDeviceName,DWORD iModeNum,LPDEVMODEA lpDevMode);
BOOL EnumDisplaySettingsW(LPCWSTR lpszDeviceName,DWORD iModeNum,LPDEVMODEW lpDevMode);

BOOL SystemParametersInfoA(UINT uiAction,UINT uiParam,PVOID pvParam,UINT fWinIni);
BOOL SystemParametersInfoW(UINT uiAction,UINT uiParam,PVOID pvParam,UINT fWinIni);

/*
 * Accessibility support
 */
struct FILTERKEYS {
    UINT  cbSize;
    DWORD dwFlags;
    DWORD iWaitMSec;            // Acceptance Delay
    DWORD iDelayMSec;           // Delay Until Repeat
    DWORD iRepeatMSec;          // Repeat Rate
    DWORD iBounceMSec;          // Debounce Time
} 
alias FILTERKEYS * LPFILTERKEYS;

enum {
/*
 * FILTERKEYS dwFlags field
 */
FKF_FILTERKEYSON    =0x00000001,
FKF_AVAILABLE       =0x00000002,
FKF_HOTKEYACTIVE    =0x00000004,
FKF_CONFIRMHOTKEY   =0x00000008,
FKF_HOTKEYSOUND     =0x00000010,
FKF_INDICATOR       =0x00000020,
FKF_CLICKON         =0x00000040
}

struct STICKYKEYS {
    UINT  cbSize;
    DWORD dwFlags;
} 
alias STICKYKEYS * LPSTICKYKEYS;

enum {
/*
 * STICKYKEYS dwFlags field
 */
SKF_STICKYKEYSON    =0x00000001,
SKF_AVAILABLE       =0x00000002,
SKF_HOTKEYACTIVE    =0x00000004,
SKF_CONFIRMHOTKEY   =0x00000008,
SKF_HOTKEYSOUND     =0x00000010,
SKF_INDICATOR       =0x00000020,
SKF_AUDIBLEFEEDBACK =0x00000040,
SKF_TRISTATE        =0x00000080,
SKF_TWOKEYSOFF      =0x00000100
}

struct MOUSEKEYS {
    UINT cbSize;
    DWORD dwFlags;
    DWORD iMaxSpeed;
    DWORD iTimeToMaxSpeed;
    DWORD iCtrlSpeed;
    DWORD dwReserved1;
    DWORD dwReserved2;
} 
alias MOUSEKEYS * LPMOUSEKEYS;

enum {
/*
 * MOUSEKEYS dwFlags field
 */
MKF_MOUSEKEYSON     =0x00000001,
MKF_AVAILABLE       =0x00000002,
MKF_HOTKEYACTIVE    =0x00000004,
MKF_CONFIRMHOTKEY   =0x00000008,
MKF_HOTKEYSOUND     =0x00000010,
MKF_INDICATOR       =0x00000020,
MKF_MODIFIERS       =0x00000040,
MKF_REPLACENUMBERS  =0x00000080
}

struct ACCESSTIMEOUT {
    UINT  cbSize;
    DWORD dwFlags;
    DWORD iTimeOutMSec;
} 
alias ACCESSTIMEOUT * LPACCESSTIMEOUT;

enum {
/*
 * ACCESSTIMEOUT dwFlags field
 */
ATF_TIMEOUTON       =0x00000001,
ATF_ONOFFFEEDBACK   =0x00000002
}

enum {
/* values for SOUNDSENTRY iFSGrafEffect field */
SSGF_NONE       =0,
SSGF_DISPLAY    =3
}

enum {
/* values for SOUNDSENTRY iFSTextEffect field */
SSTF_NONE       =0,
SSTF_CHARS      =1,
SSTF_BORDER     =2,
SSTF_DISPLAY    =3
}

enum {
/* values for SOUNDSENTRY iWindowsEffect field */
SSWF_NONE     =0,
SSWF_TITLE    =1,
SSWF_WINDOW   =2,
SSWF_DISPLAY  =3,
SSWF_CUSTOM   =4
}

struct SOUNDSENTRYA {
    UINT cbSize;
    DWORD dwFlags;
    DWORD iFSTextEffect;
    DWORD iFSTextEffectMSec;
    DWORD iFSTextEffectColorBits;
    DWORD iFSGrafEffect;
    DWORD iFSGrafEffectMSec;
    DWORD iFSGrafEffectColor;
    DWORD iWindowsEffect;
    DWORD iWindowsEffectMSec;
    LPSTR   lpszWindowsEffectDLL;
    DWORD iWindowsEffectOrdinal;
} 
alias SOUNDSENTRYA * LPSOUNDSENTRYA;
struct SOUNDSENTRYW {
    UINT cbSize;
    DWORD dwFlags;
    DWORD iFSTextEffect;
    DWORD iFSTextEffectMSec;
    DWORD iFSTextEffectColorBits;
    DWORD iFSGrafEffect;
    DWORD iFSGrafEffectMSec;
    DWORD iFSGrafEffectColor;
    DWORD iWindowsEffect;
    DWORD iWindowsEffectMSec;
    LPWSTR  lpszWindowsEffectDLL;
    DWORD iWindowsEffectOrdinal;
} 
alias SOUNDSENTRYW * LPSOUNDSENTRYW;

enum {
/*
 * SOUNDSENTRY dwFlags field
 */
SSF_SOUNDSENTRYON   =0x00000001,
SSF_AVAILABLE       =0x00000002,
SSF_INDICATOR       =0x00000004
}

struct TOGGLEKEYS {
    UINT cbSize;
    DWORD dwFlags;
} 
alias TOGGLEKEYS * LPTOGGLEKEYS;

enum {
/*
 * TOGGLEKEYS dwFlags field
 */
TKF_TOGGLEKEYSON    =0x00000001,
TKF_AVAILABLE       =0x00000002,
TKF_HOTKEYACTIVE    =0x00000004,
TKF_CONFIRMHOTKEY   =0x00000008,
TKF_HOTKEYSOUND     =0x00000010,
TKF_INDICATOR       =0x00000020
}

/*
 * Set debug level
 */
VOID SetDebugErrorLevel(DWORD dwLevel);

enum {
/*
 * SetLastErrorEx() types.
 */
SLE_ERROR       =0x00000001,
SLE_MINORERROR  =0x00000002,
SLE_WARNING     =0x00000003
}

VOID SetLastErrorEx(DWORD dwErrCode,DWORD dwType);

} // extern(Windows)
