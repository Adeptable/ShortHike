
<!DOCTYPE html PUBLIC "-//W3C//DTD HTML 4.01//EN" "http://www.w3.org/TR/html4/strict.dtd">
<html>

<!--
	Copyright (c) 1999-2006 by Digital Mars
	All Rights Reserved
	Written by Walter Bright
	www.digitalmars.com
  -->


<!-- Mirrored from www.shorthike.com/trac/browser/trunk/tools_win32/dmd/html/d/arrays.html?format=raw by HTTrack Website Copier/3.x [XR&CO'2010], Sat, 01 May 2010 04:11:25 GMT -->
<!-- Added by HTTrack --><meta http-equiv="content-type" content="text/html;charset=UTF-8"><!-- /Added by HTTrack -->
<head>
<meta http-equiv="content-type" content="text/html; charset=utf-8" />
<meta name="keywords" content="D programming language" />
<meta name="description" content="D Programming Language" />
<title>D Programming Language - Arrays</title>
<link rel="stylesheet" type="text/css" href="style.html" />
<link rel="shortcut icon" href="favicon.html" />
</head>

<body>
<div id="heading">
	<a href="http://www.digitalmars.com/"><img src="dmlogo.html" width="270" height="53" style="border-style:none" alt="www.digitalmars.com"></a>

	<div id="headingNav">
	<ul>	<li><a href="http://www.prowiki.org/wiki4d/wiki.cgi?DocComments/Arrays" title="Read/write comments and feedback">Comments</a></li>
	<li><a href="index.html" title="D Programming Language" class="dlink">D</a></li>
	<li><a href="http://www.digitalmars.com/advancedsearch.html" title="Search Digital Mars web site">Search</a></li>
	<li><a href="download.html" title="download D">Downloads</a></li>
	<li><a href="http://www.digitalmars.com/" title="www.digitalmars.com">Home</a></li>
	</ul>
	</div>

	<div id="lastupdate">Last update Fri Jun 30 00:30:29 2006
</div>
</div>

<!-- Generated by Ddoc from arrays.d -->



<div id="navigation">
  
<div class="navblock">
<form method="get" action="http://www.google.com/search">
<div id="searchbox">
<input id="q" name="q" size="10" value="Search" onFocus='if(this.value == "Search"){this.value="";}'>
<input type="hidden" id="domains" name="domains" value="www.digitalmars.com">
<input type="hidden" id="sitesearch" name="sitesearch" value="www.digitalmars.com/d">
<input type="hidden" id="sourceid" name="sourceid" value="google-search">
<input type="submit" id="submit" name="submit" value="Go">
</div>
</form>
<div id="toctop">
    <ul>	<li><a href="index.html" title="D Programming Language">D ...</a></li>
	<li><a href="lex.html" title="D Language Specification">Language ...</a></li>
	<li><a href="phobos/phobos.html" title="D Runtime Library">Phobos ...</a></li>
	<li><a href="comparison.html" title="Language Comparisons">Comparisons ...</a></li>
    </ul>
</div>
</div>

  
    <div class="navblock">
    <ul>	<li><a href="lex.html">Lexical</a></li>

	<li><a href="module.html">Modules</a></li>

	<li><a href="declaration.html">Declarations</a></li>

	<li><a href="type.html">Types</a></li>

	<li><a href="property.html">Properties</a></li>

	<li><a href="attribute.html">Attributes</a></li>

	<li><a href="pragma.html">Pragmas</a></li>

	<li><a href="expression.html">Expressions</a></li>

	<li><a href="statement.html">Statements</a></li>

	<li><a href="arrays.html">Arrays</a></li>

	<li><a href="struct.html">Structs &amp; Unions</a></li>

	<li><a href="class.html">Classes</a></li>

	<li><a href="interface.html">Interfaces</a></li>

	<li><a href="enum.html">Enums</a></li>

	<li><a href="function.html">Functions</a></li>

	<li><a href="operatoroverloading.html">Operator Overloading</a></li>

	<li><a href="template.html">Templates</a></li>

	<li><a href="mixin.html">Mixins</a></li>

	<li><a href="dbc.html">Contracts</a></li>

	<li><a href="version.html">Conditional Compilation</a></li>

	<li><a href="errors.html">Handling errors</a></li>

	<li><a href="garbage.html">Garbage Collection</a></li>

	<li><a href="float.html">Floating Point</a></li>

	<li><a href="iasm.html">Inline Assembler</a></li>

	<li><a href="ddoc.html">Documentation Comments</a></li>

	<li><a href="interfaceToC.html">Interfacing To C</a></li>

	<li><a href="portability.html">Portability Guide</a></li>

	<li><a href="html.html">Embedding D in HTML</a></li>

	<li><a href="entity.html">Named Character Entities</a></li>

	<li><a href="abi.html">Application Binary Interface</a></li>

    </ul>
    </div>

</div>
<div id="content">
  <h1>     Arrays</h1>
  
	There are four kinds of arrays:
	<p>

    <table border=1 cellpadding=4 cellspacing=0>	<tr><td>int* p;		<td>Pointers to data

	<tr><td>int[3] s;	<td>Static arrays

	<tr><td>int[] a;	<td>Dynamic arrays

	<tr><td>int[char[]] x;	<td><a href="#associative">Associative arrays</a>
    </table>

<h3>Pointers</h3>

<pre class="d_code"><span class="d_keyword">int</span>* p;
</pre>

	These are simple pointers to data, analogous to C pointers.
	Pointers are provided for interfacing with C and for
	specialized systems work.
	There
	is no length associated with it, and so there is no way for the
	compiler or runtime to do bounds checking, etc., on it.
	Most conventional uses for pointers can be replaced with
	dynamic arrays, <tt>out</tt> and <tt>inout</tt> parameters,
	and reference types.

<h3>Static Arrays</h3>

<pre class="d_code"><span class="d_keyword">int</span>[3] s;
</pre>

	These are analogous to C arrays. Static arrays are distinguished
	by having a length fixed at compile time.
	<p>

	The total size of a static array cannot exceed 16Mb.
	A dynamic array should be used instead for such large arrays.
	<p>

	A static array with a dimension of 0 is allowed, but no
	space is allocated for it. It's useful as the last member
	of a variable length struct, or as the degenerate case of
	a template expansion.

<h3>Dynamic Arrays</h3>

<pre class="d_code"><span class="d_keyword">int</span>[] a;
</pre>

	Dynamic arrays consist of a length and a pointer to the array data.
	Multiple dynamic arrays can share all or parts of the array data.

<h2>Array Declarations</h2>

	There are two ways to declare arrays, prefix and postfix.
	The prefix form is the preferred method, especially for
	non-trivial types.

<h4>Prefix Array Declarations</h4>

	Prefix declarations appear before the identifier being
	declared and read right to left, so:

<pre class="d_code"><span class="d_keyword">int</span>[] a;	<span class="d_comment">// dynamic array of ints
</span><span class="d_keyword">int</span>[4][3] b;	<span class="d_comment">// array of 3 arrays of 4 ints each
</span><span class="d_keyword">int</span>[][5] c;	<span class="d_comment">// array of 5 dynamic arrays of ints.
</span><span class="d_keyword">int</span>*[]*[3] d;	<span class="d_comment">// array of 3 pointers to dynamic arrays of pointers to ints
</span><span class="d_keyword">int</span>[]* e;	<span class="d_comment">// pointer to dynamic array of ints
</span></pre>


<h4>Postfix Array Declarations</h4>

	Postfix declarations appear after the identifier being
	declared and read left to right.
	Each group lists equivalent declarations:

<pre class="d_code"><span class="d_comment">// dynamic array of ints
</span><span class="d_keyword">int</span>[] a;
<span class="d_keyword">int</span> a[];

<span class="d_comment">// array of 3 arrays of 4 ints each
</span><span class="d_keyword">int</span>[4][3] b;
<span class="d_keyword">int</span>[4] b[3];
<span class="d_keyword">int</span> b[3][4];

<span class="d_comment">// array of 5 dynamic arrays of ints.
</span><span class="d_keyword">int</span>[][5] c;
<span class="d_keyword">int</span>[] c[5];
<span class="d_keyword">int</span> c[5][];

<span class="d_comment">// array of 3 pointers to dynamic arrays of pointers to ints
</span><span class="d_keyword">int</span>*[]*[3] d;
<span class="d_keyword">int</span>*[]* d[3];
<span class="d_keyword">int</span>* (*d[3])[];

<span class="d_comment">// pointer to dynamic array of ints
</span><span class="d_keyword">int</span>[]* e;
<span class="d_keyword">int</span> (*e[]);
</pre>

	<b>Rationale:</b> The postfix form matches the way arrays are
	declared in C and C++, and supporting this form provides an
	easy migration path for programmers used to it.

<h2>Usage</h2>

	There are two broad kinds of operations to do on an array - affecting
	the handle to the array,
	and affecting the contents of the array.
	C only has
	operators to affect the handle. In D, both are accessible.
	<p>

	The handle to an array is specified by naming the array, as
	in p, s or a:

<pre class="d_code"><span class="d_keyword">int</span>* p;
<span class="d_keyword">int</span>[3] s;
<span class="d_keyword">int</span>[] a;

<span class="d_keyword">int</span>* q;
<span class="d_keyword">int</span>[3] t;
<span class="d_keyword">int</span>[] b;

p = q;		<span class="d_comment">// p points to the same thing q does.
</span>p = s;		<span class="d_comment">// p points to the first element of the array s.
</span>p = a;		<span class="d_comment">// p points to the first element of the array a.
</span>
s = ...;	<span class="d_comment">// error, since s is a compiled in static
</span>		<span class="d_comment">// reference to an array.
</span>
a = p;		<span class="d_comment">// error, since the length of the array pointed
</span>		<span class="d_comment">// to by p is unknown
</span>a = s;		<span class="d_comment">// a is initialized to point to the s array
</span>a = b;		<span class="d_comment">// a points to the same array as b does
</span></pre>

<h2><a name="slicing">Slicing</a></h2>

	<i>Slicing</i> an array means to specify a subarray of it.
	An array slice does not copy the data, it is only another
	reference to it.
	For example:

<pre class="d_code"><span class="d_keyword">int</span>[10] a;	<span class="d_comment">// declare array of 10 ints
</span><span class="d_keyword">int</span>[] b;

b = a[1..3];	<span class="d_comment">// a[1..3] is a 2 element array consisting of
</span>		<span class="d_comment">// a[1] and a[2]
</span>foo(b[1]);	<span class="d_comment">// equivalent to foo(0)
</span>a[2] = 3;
foo(b[1]);	<span class="d_comment">// equivalent to foo(3)
</span></pre>

	The [] is shorthand for a slice of the entire array.
	For example, the assignments to b:

<pre class="d_code"><span class="d_keyword">int</span>[10] a;
<span class="d_keyword">int</span>[] b;

b = a;
b = a[];
b = a[0 .. a.length];
</pre>

	are all semantically equivalent.
	<p>

	Slicing
	is not only handy for referring to parts of other arrays,
	but for converting pointers into bounds-checked arrays:

<pre class="d_code"><span class="d_keyword">int</span>* p;
<span class="d_keyword">int</span>[] b = p[0..8];
</pre>

<h2>Array Copying</h2>

	When the slice operator appears as the lvalue of an assignment
	expression, it means that the contents of the array are the
	target of the assignment rather than a reference to the array.
	Array copying happens when the lvalue is a slice, and the rvalue
	is an array of or pointer to the same type.

<pre class="d_code"><span class="d_keyword">int</span>[3] s;
<span class="d_keyword">int</span>[3] t;

s[] = t;		<span class="d_comment">// the 3 elements of t[3] are copied into s[3]
</span>s[] = t[];		<span class="d_comment">// the 3 elements of t[3] are copied into s[3]
</span>s[1..2] = t[0..1];	<span class="d_comment">// same as s[1] = t[0]
</span>s[0..2] = t[1..3];	<span class="d_comment">// same as s[0] = t[1], s[1] = t[2]
</span>s[0..4] = t[0..4];	<span class="d_comment">// error, only 3 elements in s
</span>s[0..2] = t;		<span class="d_comment">// error, different lengths for lvalue and rvalue
</span></pre>

	Overlapping copies are an error:

<pre class="d_code">s[0..2] = s[1..3];	<span class="d_comment">// error, overlapping copy
</span>s[1..3] = s[0..2];	<span class="d_comment">// error, overlapping copy
</span></pre>

	Disallowing overlapping makes it possible for more aggressive
	parallel code optimizations than possible with the serial
	semantics of C.

<h2>Array Setting</h2>

	If a slice operator appears as the lvalue of an assignment
	expression, and the type of the rvalue is the same as the element
	type of the lvalue, then the lvalue's array contents
	are set to the rvalue.

<pre class="d_code"><span class="d_keyword">int</span>[3] s;
<span class="d_keyword">int</span>* p;

s[] = 3;		<span class="d_comment">// same as s[0] = 3, s[1] = 3, s[2] = 3
</span>p[0..2] = 3;		<span class="d_comment">// same as p[0] = 3, p[1] = 3
</span></pre>

<h2>Array Concatenation</h2>

	The binary operator ~ is the <i>cat</i> operator. It is used
	to concatenate arrays:

<pre class="d_code"><span class="d_keyword">int</span>[] a;
<span class="d_keyword">int</span>[] b;
<span class="d_keyword">int</span>[] c;

a = b ~ c;	<span class="d_comment">// Create an array from the concatenation of the
</span>		<span class="d_comment">// b and c arrays
</span></pre>

	Many languages overload the + operator to mean concatenation.
	This confusingly leads to, does:

<pre class="d_code"><span class="d_string">"10"</span> + 3
</pre>

	produce the number 13 or the string "103" as the result? It isn't
	obvious, and the language designers wind up carefully writing rules
	to disambiguate it - rules that get incorrectly implemented,
	overlooked, forgotten, and ignored. It's much better to have + mean
	addition, and a separate operator to be array concatenation.
	<p>

	Similarly, the ~= operator means append, as in:

<pre class="d_code">a ~= b;		<span class="d_comment">// a becomes the concatenation of a and b
</span></pre>

	Concatenation always creates a copy of its operands, even
	if one of the operands is a 0 length array, so:

<pre class="d_code">a = b;			<span class="d_comment">// a refers to b
</span>a = b ~ c[0..0];	<span class="d_comment">// a refers to a copy of b
</span></pre>





<h2>Pointer Arithmetic</h2>

<pre class="d_code"><span class="d_keyword">int</span>[3] abc;			<span class="d_comment">// static array of 3 ints
</span><span class="d_keyword">int</span>[] def = [ 1, 2, 3 ];	<span class="d_comment">// dynamic array of 3 ints
</span>
<span class="d_keyword">void</span> dibb(<span class="d_keyword">int</span>* array)
{
	array[2];		<span class="d_comment">// means same thing as *(array + 2)
</span>	*(array + 2);		<span class="d_comment">// get 2nd element
</span>}

<span class="d_keyword">void</span> diss(<span class="d_keyword">int</span>[] array)
{
	array[2];		<span class="d_comment">// ok
</span>	*(array + 2);		<span class="d_comment">// error, array is not a pointer
</span>}

<span class="d_keyword">void</span> ditt(<span class="d_keyword">int</span>[3] array)
{
	array[2];		<span class="d_comment">// ok
</span>	*(array + 2);		<span class="d_comment">// error, array is not a pointer
</span>}
</pre>

<h2>Rectangular Arrays</h2>

	Experienced FORTRAN numerics programmers know that multidimensional 
	"rectangular" arrays for things like matrix operations are much faster than trying to 
	access them via pointers to pointers resulting from "array of pointers to array" semantics. 
	For example, the D syntax:

<pre class="d_code"><span class="d_keyword">double</span>[][] matrix;
</pre>

	declares matrix as an array of pointers to arrays. (Dynamic arrays are implemented as 
	pointers to the array data.) Since the arrays can have varying sizes (being dynamically 
	sized), this is sometimes called "jagged" arrays. Even worse for optimizing the code, the 
	array rows can sometimes point to each other! Fortunately, D static arrays, while using 
	the same syntax, are implemented as a fixed rectangular layout:

<pre class="d_code"><span class="d_keyword">double</span>[3][3] matrix;
</pre>

	declares a rectangular matrix with 3 rows and 3 columns, all contiguously in memory. In 
	other languages, this would be called a multidimensional array and be declared as:

<pre class="d_code"><span class="d_keyword">double</span> matrix[3,3];
</pre>

<h2>Array Length</h2>

	Within the [ ] of a static or a dynamic array,
	the variable <b>length</b>
	is implicitly declared and set to the length of the array.

<pre class="d_code"><span class="d_keyword">int</span>[4] foo;
<span class="d_keyword">int</span>[]  bar = foo;
<span class="d_keyword">int</span>*   p = &amp;foo[0];

<span class="d_comment">// These expressions are equivalent:
</span>bar[]
bar[0 .. 4]
bar[0 .. <b>length</b>]
bar[0 .. bar.length]

p[0 .. length]		<span class="d_comment">// 'length' is not defined, since p is not an array
</span>bar[0]+length		<span class="d_comment">// 'length' is not defined, out of scope of [ ]
</span>
bar[<b>length</b>-1]	<span class="d_comment">// retrieves last element of the array
</span></pre>

<h2>Array Properties</h2>

	Static array properties are:
    <table border=1 cellpadding=4 cellspacing=0>	<tr>
	<td><b>.sizeof</b>
	<td>Returns the array length multiplied by the number of
	bytes per array element.

	<tr>
	<td><b>.length</b>
	<td>Returns the number of elements in the array.
	This is a fixed quantity for static arrays.

	<tr>
	<td><b>.ptr</b>
	<td>Returns a pointer to the first element of the array.

	<tr>
	<td><b>.dup</b>
	<td>Create a dynamic array of the same size
	and copy the contents of the array into it.

	<tr>
	<td><b>.reverse</b>
	<td>Reverses in place the order of the elements in the array.
	Returns the array.

	<tr>
	<td><b>.sort</b>
	<td>Sorts in place the order of the elements in the array.
	Returns the array.

    </table>
	<p>

	Dynamic array properties are:

    <table border=1 cellpadding=4 cellspacing=0>	<tr>
	<td><b>.sizeof</b>
	<td>Returns the size of the dynamic array reference,
	which is 8 on 32 bit machines.

	<tr>
	<td><b>.length</b>
	<td>Get/set number of elements in the array.

	<tr>
	<td><b>.ptr</b>
	<td>Returns a pointer to the first element of the array.

	<tr>
	<td><b>.dup</b>
	<td>Create a dynamic array of the same size
	and copy the contents of the array into it.

	<tr>
	<td><b>.reverse</b>
	<td>Reverses in place the order of the elements in the array.
	Returns the array.

	<tr>
	<td><b>.sort</b>
	<td>Sorts in place the order of the elements in the array.
	Returns the array.

    </table>
    <p>

    Examples:

<pre class="d_code">p.length	<span class="d_comment">// error, length not known for pointer
</span>s.length	<span class="d_comment">// compile time constant 3
</span>a.length	<span class="d_comment">// runtime value
</span>
p.dup		<span class="d_comment">// error, length not known
</span>s.dup		<span class="d_comment">// creates an array of 3 elements, copies
</span>		<span class="d_comment">// elements s into it
</span>a.dup		<span class="d_comment">// creates an array of a.length elements, copies
</span>		<span class="d_comment">// elements of a into it
</span></pre>

<h3><a name="resize">Setting Dynamic Array Length</a></h3>

	The <b><tt>.length</tt></b> property of a dynamic array can be set
	as the lvalue of an = operator:

<pre class="d_code">array.length = 7;
</pre>

	This causes the array to be reallocated in place, and the existing
	contents copied over to the new array. If the new array length is
	shorter,
	only enough are copied to fill the new array. If the new array length
	is longer, the remainder is filled out with the default initializer.
	<p>

	To maximize efficiency, the runtime always tries to resize the
	array in place to avoid extra copying. It will always do a copy
	if the new size is larger and the array was not allocated via the
	new operator or a previous
	resize operation.
	<p>

	This means that if there is an array slice immediately following the
	array being resized, the resized array could overlap the slice; i.e.:

<pre class="d_code"><span class="d_keyword">char</span>[] a = <span class="d_keyword">new</span> <span class="d_keyword">char</span>[20];
<span class="d_keyword">char</span>[] b = a[0..10];
<span class="d_keyword">char</span>[] c = a[10..20];

b.length = 15;	<span class="d_comment">// always resized in place because it is sliced
</span>		<span class="d_comment">// from a[] which has enough memory for 15 chars
</span>b[11] = 'x';	<span class="d_comment">// a[15] and c[5] are also affected
</span>
a.length = 1;
a.length = 20;	<span class="d_comment">// no net change to memory layout
</span>
c.length = 12;	<span class="d_comment">// always does a copy because c[] is not at the
</span>		<span class="d_comment">// start of a gc allocation block
</span>c[5] = 'y';	<span class="d_comment">// does not affect contents of a[] or b[]
</span>
a.length = 25;	<span class="d_comment">// may or may not do a copy
</span>a[3] = 'z';	<span class="d_comment">// may or may not affect b[3] which still overlaps
</span>		<span class="d_comment">// the old a[3]
</span></pre>

	To guarantee copying behavior, use the .dup property to ensure
	a unique array that can be resized.
	<p>

	These issues also apply to concatenating arrays with the ~ and ~=
	operators.
	<p>

	Resizing a dynamic array is a relatively expensive operation.
	So, while the following method of filling an array:

<pre class="d_code"><span class="d_keyword">int</span>[] array;
<span class="d_keyword">while</span> (1)
{   c = getinput();
    <span class="d_keyword">if</span> (!c)
       <span class="d_keyword">break</span>;
    array.length = array.length + 1;
    array[array.length - 1] = c;
}
</pre>

	will work, it will be inefficient. A more practical
	approach would be to minimize the number of resizes:

<pre class="d_code"><span class="d_keyword">int</span>[] array;
array.length = 100;        <span class="d_comment">// guess
</span><span class="d_keyword">for</span> (i = 0; 1; i++)
{   c = getinput();
     <span class="d_keyword">if</span> (!c)
	<span class="d_keyword">break</span>;
     <span class="d_keyword">if</span> (i == array.length)
	array.length = array.length * 2;
     array[i] = c;
}
array.length = i;
</pre>

	Picking a good initial guess is an art, but you usually can
	pick a value covering 99% of the cases.
	For example, when gathering user
	input from the console - it's unlikely to be longer than 80.

<h2><a name="bounds">Array Bounds Checking</a></h2>

	It is an error to index an array with an index that is less than
	0 or greater than or equal to the array length. If an index is
	out of bounds, an ArrayBoundsError exception is raised if detected
	at runtime, and an error if detected at compile time.
	A program may not rely on array bounds checking happening, for
	example, the following program is incorrect:

<pre class="d_code"><span class="d_keyword">try</span>
{
    <span class="d_keyword">for</span> (i = 0; ; i++)
    {
	array[i] = 5;
    }
}
<span class="d_keyword">catch</span> (ArrayBoundsError)
{
    <span class="d_comment">// terminate loop
</span>}
</pre>

	The loop is correctly written:

<pre class="d_code"><span class="d_keyword">for</span> (i = 0; i &lt; array.length; i++)
{
    array[i] = 5;
}
</pre>

	<b>Implementation Note:</b> Compilers should attempt to detect
	array bounds errors at compile time, for example:

<pre class="d_code"><span class="d_keyword">int</span>[3] foo;
<span class="d_keyword">int</span> x = foo[3];		<span class="d_comment">// error, out of bounds
</span></pre>

	Insertion of array bounds checking code at runtime should be
	turned on and off
	with a compile time switch.

<h2>Array Initialization</h2>

<h3>Default Initialization</h3>

	<ul>
	<li> Pointers are initialized to <b>null</b>.
	<li> Static array contents are initialized to the default
	initializer for the array element type.
	<li> Dynamic arrays are initialized to having 0 elements.
	<li> Associative arrays are initialized to having 0 elements.
	</ul>

<h3>Void Initialization</h3>

	Void initialization happens when the <i>Initializer</i> for
	an array is <b>void</b>. What it means is that no initialization
	is done, i.e. the contents of the array will be undefined.
	This is most useful as an efficiency optimization.
	Void initializations are an advanced technique and should only be used
	when profiling indicates that it matters.

<h3>Static Initialization of Static Arrays</h3>

<pre class="d_code"><span class="d_keyword">int</span>[3] a = [ 1:2, 3 ];		<span class="d_comment">// a[0] = 0, a[1] = 2, a[2] = 3
</span></pre>

	This is most handy when the array indices are given by enums:

<pre class="d_code"><span class="d_keyword">enum</span> Color { red, blue, green };

<span class="d_keyword">int</span> value[Color.max + 1] = [ Color.blue:6, Color.green:2, Color.red:5 ];
</pre>



<h2>Special Array Types</h2>

<h3><a name="strings">Strings</a></h3>

	Languages should be good at handling strings. C and C++ are not
	good at it. The primary difficulties are memory management,
	handling of temporaries, constantly rescanning the string looking
	for the terminating 0, and the fixed arrays.
	<p>

	Dynamic arrays in D suggest the obvious solution - a string is
	just a dynamic array of characters. String literals become just
	an easy way to write character arrays.

<pre class="d_code"><span class="d_keyword">char</span>[] str;
<span class="d_keyword">char</span>[] str1 = <span class="d_string">"abc"</span>;
</pre>

	char[] strings are in UTF-8 format.
	wchar[] strings are in UTF-16 format.
	dchar[] strings are in UTF-32 format.
	<p>

	Strings can be copied, compared, concatenated, and appended:

<pre class="d_code">str1 = str2;
<span class="d_keyword">if</span> (str1 &lt; str3) ...
func(str3 ~ str4);
str4 ~= str1;
</pre>

	with the obvious semantics. Any generated temporaries get cleaned up
	by the garbage collector (or by using alloca()). Not only that,
	this works with any 
	array not just a special String array.
	<p>

	A pointer to a char can be generated:

<pre class="d_code"><span class="d_keyword">char</span>* p = &amp;str[3];	<span class="d_comment">// pointer to 4th element
</span><span class="d_keyword">char</span>* p = str;		<span class="d_comment">// pointer to 1st element
</span></pre>

	Since strings, however, are not 0 terminated in D,
	when transferring a pointer
	to a string to C, add a terminating 0:

<pre class="d_code">str ~= <span class="d_string">"\0"</span>;
</pre>

	The type of a string is determined by the semantic phase of
	compilation. The type is 
	one of: char[], wchar[], dchar[], and is determined by
	implicit conversion rules. 
	If there are two equally applicable implicit conversions,
	the result is an error. To 
	disambiguate these cases, a cast is appropriate:

<pre class="d_code"><span class="d_keyword">cast</span>(<span class="d_keyword">wchar</span> [])<span class="d_string">"abc"</span>	<span class="d_comment">// this is an array of wchar characters
</span></pre>

	String literals are implicitly converted between chars,
	wchars, and dchars as necessary.
	<p>

	Strings a single character in length can also be exactly
	converted to a char, wchar or dchar constant:

<pre class="d_code"><span class="d_keyword">char</span> c;
<span class="d_keyword">wchar</span> w;
<span class="d_keyword">dchar</span> d;

c = 'b';		<span class="d_comment">// c is assigned the character 'b'
</span>w = 'b';		<span class="d_comment">// w is assigned the wchar character 'b'
</span>w = 'bc';		<span class="d_comment">// error - only one wchar character at a time
</span>w = <span class="d_string">"b"</span>[0];		<span class="d_comment">// w is assigned the wchar character 'b'
</span>w = <span class="d_string">\r</span>;			<span class="d_comment">// w is assigned the carriage return wchar character
</span>d = 'd';		<span class="d_comment">// d is assigned the character 'd'
</span></pre>

<h4>printf() and Strings</h4>

	<b>printf()</b> is a C function and is not part of D. <b>printf()</b>
	will print C strings, which are 0 terminated. There are two ways
	to use <b>printf()</b> with D strings. The first is to add a
	terminating 0, and cast the result to a char*:

<pre class="d_code">str ~= <span class="d_string">"\0"</span>;
printf(<span class="d_string">"the string is '%s'\n"</span>, (<span class="d_keyword">char</span>*)str);
</pre>

	The second way is to use the precision specifier. The way D arrays
	are laid out, the length comes first, so the following works:

<pre class="d_code">printf(<span class="d_string">"the string is '%.*s'\n"</span>, str);
</pre>

	In the future, it may be necessary to just add a new format
	specifier to <b>printf()</b> instead of relying on an implementation
	dependent detail.

<h3>Implicit Conversions</h3>

	A pointer <tt><i>T</i>*</tt> can be implicitly converted to
	one of the following:

	<ul>
	<li> <i>U</i>* where <i>U</i> is a base class of <i>T</i>.
	<li> <tt>void*</tt>
	</ul>

	A static array <tt><i>T</i>[<i>dim</i>]</tt> can be implicitly
	converted to
	one of the following:

	<ul>
	<li> <i>T</i>*
	<li> <i>T</i>[]
	<li> <i>U</i>[<i>dim</i>] where <i>U</i> is a base class of <i>T</i>.
	<li> <i>U</i>[] where <i>U</i> is a base class of <i>T</i>.
	<li> <i>U</i>* where <i>U</i> is a base class of <i>T</i>.
	<li> <tt>void*</tt>
	<li> <tt>void[]</tt>
	</ul>

	A dynamic array <tt><i>T</i>[]</tt> can be implicitly converted to
	one of the following:

	<ul>
	<li> <i>T</i>*
	<li> <i>U</i>[] where <i>U</i> is a base class of <i>T</i>.
	<li> <i>U</i>* where <i>U</i> is a base class of <i>T</i>.
	<li> <tt>void*</tt>
	</ul>

<!-- Need array literal syntax -->

<hr>
<h1><a name="associative">Associative Arrays</a></h1>

	D goes one step further with arrays - adding associative arrays.
	Associative arrays have an index that is not necessarily an integer,
	and can be sparsely populated. The index for an associative array
	is called the <i>key</i>, and its type is called the <i>KeyType</i>.
	<p>

	Associative arrays are declared by placing the <i>KeyType</i>
	within the [] of an array declaration:

<pre class="d_code"><span class="d_keyword">int</span>[<span class="d_keyword">char</span>[]] b;		<span class="d_comment">// associative array b of ints that are
</span>			<span class="d_comment">// indexed by an array of characters.
</span>			<span class="d_comment">// The <i>KeyType</i> is char[]
</span>b[<span class="d_string">"hello"</span>] = 3;		<span class="d_comment">// set value associated with key "hello" to 3
</span>func(b[<span class="d_string">"hello"</span>]);	<span class="d_comment">// pass 3 as parameter to func()
</span></pre>

	Particular keys in an associative array can be removed with the
	remove function:

<pre class="d_code">b.<b>remove</b>(<span class="d_string">"hello"</span>);
</pre>

	The <i>InExpression</i> yields a pointer to the value
	if the key is in the associative array, or <b>null</b> if not:

<pre class="d_code"><span class="d_keyword">int</span>* p;
p = (<span class="d_string">"hello"</span> <b><span class="d_keyword">in</span></b> b);
<span class="d_keyword">if</span> (p != <b><span class="d_keyword">null</span></b>)
	...
</pre>

	<i>KeyType</i>s cannot be functions or voids.
	<p>

	If the <i>KeyType</i> is a struct type, a default mechanism is used
	to compute the hash and comparisons of it based on the binary
	data within the struct value. A custom mechanism can be used
	by providing the following functions as struct members:

<pre class="d_code"><span class="d_keyword">uint</span> <b>toHash</b>();
<span class="d_keyword">int</span> <b>opCmp</b>(<i>KeyType</i>* s);
</pre>

	For example:

<pre class="d_code"><span class="d_keyword">import</span> std.string;

<span class="d_keyword">struct</span> MyString
{
    <span class="d_keyword">char</span>[] str;

    <span class="d_keyword">uint</span> <b>toHash</b>()
    {   <span class="d_keyword">uint</span> hash;
	<span class="d_keyword">foreach</span> (<span class="d_keyword">char</span> c; s)
	    hash = (hash * 9) + c;
	<span class="d_keyword">return</span> hash;
    }

    <span class="d_keyword">int</span> <b>opCmp</b>(MyString* s)
    {
	<span class="d_keyword">return</span> std.string.cmp(<span class="d_keyword">this</span>.str, s.str);
    }
}
</pre>

<h3>Properties</h3>

Properties for associative arrays are:

    <table border=1 cellpadding=4 cellspacing=0>
	<tr>
	<td><b>.sizeof</b>
	<td>Returns the size of the reference to the associative
	array; it is typically 8.

	<tr>
	<td><b>.length</b>
	<td>Returns number of values in the associative array.
	Unlike for dynamic arrays, it is read-only.

	<tr>
	<td><b>.keys</b>
	<td>Returns dynamic array, the elements of which are the keys in
	the associative array.

	<tr>
	<td><b>.values</b>
	<td>Returns dynamic array, the elements of which are the values in
	the associative array.

	<tr>
	<td><b>.rehash</b>
	<td>Reorganizes the associative array in place so that lookups
	are more efficient. rehash is effective when, for example,
	the program is done loading up a symbol table and now needs
	fast lookups in it.
	Returns a reference to the reorganized array.

    </table>

<hr>
<h3>Associative Array Example: word count</h3>

<pre class="d_code"><span class="d_keyword">import</span> std.file;		<span class="d_comment">// D file I/O
</span>
<span class="d_keyword">int</span> main (<span class="d_keyword">char</span>[][] args)
{
    <span class="d_keyword">int</span> word_total;
    <span class="d_keyword">int</span> line_total;
    <span class="d_keyword">int</span> char_total;
    <span class="d_keyword">int</span>[<span class="d_keyword">char</span>[]] dictionary;

    printf(<span class="d_string">"   lines   words   bytes file\n"</span>);
    <span class="d_keyword">for</span> (<span class="d_keyword">int</span> i = 1; i &lt; args.length; ++i)	<span class="d_comment">// program arguments
</span>    {
	<span class="d_keyword">char</span>[] input;		<span class="d_comment">// input buffer
</span>	<span class="d_keyword">int</span> w_cnt, l_cnt, c_cnt;	<span class="d_comment">// word, line, char counts
</span>	<span class="d_keyword">int</span> inword;
	<span class="d_keyword">int</span> wstart;

	input = std.file.read(args[i]);	<span class="d_comment">// read file into input[]
</span>
	<span class="d_keyword">foreach</span> (<span class="d_keyword">char</span> c; input)
	{
	    <span class="d_keyword">if</span> (c == '\n')
		++l_cnt;
	    <span class="d_keyword">if</span> (c &gt;= '0' &amp;&amp; c &lt;= '9')
	    {
	    }
	    <span class="d_keyword">else</span> <span class="d_keyword">if</span> (c &gt;= 'a' &amp;&amp; c &lt;= 'z' ||
		c &gt;= 'A' &amp;&amp; c &lt;= 'Z')
	    {
		<span class="d_keyword">if</span> (!inword)
		{
		    wstart = j;
		    inword = 1;
		    ++w_cnt;
		}
	    }
	    <span class="d_keyword">else</span> <span class="d_keyword">if</span> (inword)
	    {   <span class="d_keyword">char</span>[] word = input[wstart .. j];

		dictionary[word]++;		<span class="d_comment">// increment count for word
</span>		inword = 0;
	    }
	    ++c_cnt;
	}
	<span class="d_keyword">if</span> (inword)
	{   <span class="d_keyword">char</span>[] word = input[wstart .. input.length];
	    dictionary[word]++;
	}
	printf(<span class="d_string">"%8ld%8ld%8ld %.*s\n"</span>, l_cnt, w_cnt, c_cnt, args[i]);
	line_total += l_cnt;
	word_total += w_cnt;
	char_total += c_cnt;
    }

    <span class="d_keyword">if</span> (args.length &gt; 2)
    {
	printf(<span class="d_string">"-------------------------------------\n%8ld%8ld%8ld total"</span>,
	    line_total, word_total, char_total);
    }

    printf(<span class="d_string">"-------------------------------------\n"</span>);
    <span class="d_keyword">char</span>[][] keys = dictionary.keys;	<span class="d_comment">// find all words in dictionary[]
</span>    <span class="d_keyword">for</span> (<span class="d_keyword">int</span> i = 0; i &lt; keys.length; i++)
    {   <span class="d_keyword">char</span>[] word;

	word = keys[i];
	printf(<span class="d_string">"%3d %.*s\n"</span>, dictionary[word], word);
    }
    <span class="d_keyword">return</span> 0;
}
</pre>


  
<br><br>
<br><br>
<!-- Google ad -->
<script type="text/javascript"><!--
/**/google_ad_client = "pub-5628673096434613";
/**/google_ad_width = 728;
/**/google_ad_height = 90;
/**/google_ad_format = "728x90_as";
/**/google_ad_channel ="3651639259";
/**/google_page_url = document.location;
//--></script>
<script type="text/javascript" src="../../../../../../../../pagead2.googlesyndication.com/pagead/show_ads.js">
</script>

</div>





<div id="copyright">
Copyright &copy; 1999-2006 by Digital Mars, All Rights Reserved |
Page generated by <a href="http://www.digitalmars.com/d/ddoc.html">Ddoc</a>. |
<a href="http://www.prowiki.org/wiki4d/wiki.cgi?DocComments/Arrays" title="Read/write comments and feedback">Comments</a>
</div>

</body>

<!-- Mirrored from www.shorthike.com/trac/browser/trunk/tools_win32/dmd/html/d/arrays.html?format=raw by HTTrack Website Copier/3.x [XR&CO'2010], Sat, 01 May 2010 04:11:25 GMT -->
<!-- Added by HTTrack --><meta http-equiv="content-type" content="text/html;charset=UTF-8"><!-- /Added by HTTrack -->
</html>

