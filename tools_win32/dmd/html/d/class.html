
<!DOCTYPE html PUBLIC "-//W3C//DTD HTML 4.01//EN" "http://www.w3.org/TR/html4/strict.dtd">
<html>

<!--
	Copyright (c) 1999-2006 by Digital Mars
	All Rights Reserved
	Written by Walter Bright
	www.digitalmars.com
  -->


<!-- Mirrored from www.shorthike.com/trac/browser/trunk/tools_win32/dmd/html/d/class.html?format=raw by HTTrack Website Copier/3.x [XR&CO'2010], Sat, 01 May 2010 04:32:23 GMT -->
<!-- Added by HTTrack --><meta http-equiv="content-type" content="text/html;charset=UTF-8"><!-- /Added by HTTrack -->
<head>
<meta http-equiv="content-type" content="text/html; charset=utf-8" />
<meta name="keywords" content="D programming language" />
<meta name="description" content="D Programming Language" />
<title>D Programming Language - Classes</title>
<link rel="stylesheet" type="text/css" href="style.html" />
<link rel="shortcut icon" href="favicon.html" />
</head>

<body>
<div id="heading">
	<a href="http://www.digitalmars.com/"><img src="dmlogo.html" width="270" height="53" style="border-style:none" alt="www.digitalmars.com"></a>

	<div id="headingNav">
	<ul>	<li><a href="http://www.prowiki.org/wiki4d/wiki.cgi?DocComments/Class" title="Read/write comments and feedback">Comments</a></li>
	<li><a href="index.html" title="D Programming Language" class="dlink">D</a></li>
	<li><a href="http://www.digitalmars.com/advancedsearch.html" title="Search Digital Mars web site">Search</a></li>
	<li><a href="download.html" title="download D">Downloads</a></li>
	<li><a href="http://www.digitalmars.com/" title="www.digitalmars.com">Home</a></li>
	</ul>
	</div>

	<div id="lastupdate">Last update Fri Jun 30 00:30:29 2006
</div>
</div>

<!-- Generated by Ddoc from class.d -->



<div id="navigation">
  
<div class="navblock">
<form method="get" action="http://www.google.com/search">
<div id="searchbox">
<input id="q" name="q" size="10" value="Search" onFocus='if(this.value == "Search"){this.value="";}'>
<input type="hidden" id="domains" name="domains" value="www.digitalmars.com">
<input type="hidden" id="sitesearch" name="sitesearch" value="www.digitalmars.com/d">
<input type="hidden" id="sourceid" name="sourceid" value="google-search">
<input type="submit" id="submit" name="submit" value="Go">
</div>
</form>
<div id="toctop">
    <ul>	<li><a href="index.html" title="D Programming Language">D ...</a></li>
	<li><a href="lex.html" title="D Language Specification">Language ...</a></li>
	<li><a href="phobos/phobos.html" title="D Runtime Library">Phobos ...</a></li>
	<li><a href="comparison.html" title="Language Comparisons">Comparisons ...</a></li>
    </ul>
</div>
</div>

  
    <div class="navblock">
    <ul>	<li><a href="lex.html">Lexical</a></li>

	<li><a href="module.html">Modules</a></li>

	<li><a href="declaration.html">Declarations</a></li>

	<li><a href="type.html">Types</a></li>

	<li><a href="property.html">Properties</a></li>

	<li><a href="attribute.html">Attributes</a></li>

	<li><a href="pragma.html">Pragmas</a></li>

	<li><a href="expression.html">Expressions</a></li>

	<li><a href="statement.html">Statements</a></li>

	<li><a href="arrays.html">Arrays</a></li>

	<li><a href="struct.html">Structs &amp; Unions</a></li>

	<li><a href="class.html">Classes</a></li>

	<li><a href="interface.html">Interfaces</a></li>

	<li><a href="enum.html">Enums</a></li>

	<li><a href="function.html">Functions</a></li>

	<li><a href="operatoroverloading.html">Operator Overloading</a></li>

	<li><a href="template.html">Templates</a></li>

	<li><a href="mixin.html">Mixins</a></li>

	<li><a href="dbc.html">Contracts</a></li>

	<li><a href="version.html">Conditional Compilation</a></li>

	<li><a href="errors.html">Handling errors</a></li>

	<li><a href="garbage.html">Garbage Collection</a></li>

	<li><a href="float.html">Floating Point</a></li>

	<li><a href="iasm.html">Inline Assembler</a></li>

	<li><a href="ddoc.html">Documentation Comments</a></li>

	<li><a href="interfaceToC.html">Interfacing To C</a></li>

	<li><a href="portability.html">Portability Guide</a></li>

	<li><a href="html.html">Embedding D in HTML</a></li>

	<li><a href="entity.html">Named Character Entities</a></li>

	<li><a href="abi.html">Application Binary Interface</a></li>

    </ul>
    </div>

</div>
<div id="content">
  <h1>     Classes</h1>
  
	The object-oriented features of D all come from classes. The class hierarchy
	has as its root the class Object. Object defines a minimum level of functionality
	that each derived class has, and a default implementation for that functionality.
	<p>

	Classes are programmer defined types. Support for classes are what
	make D an object oriented language, giving it encapsulation, inheritance,
	and polymorphism. D classes support the single inheritance paradigm, extended
	by adding support for interfaces. Class objects are instantiated by reference
	only.
	<p>

	A class can be exported, which means its name and all its non-private
	members are exposed externally to the DLL or EXE.
	<p>

	A class declaration is defined:

<pre class="bnf"><i>ClassDeclaration</i>:
	<b>class</b> <i>Identifier</i> <i>BaseClassList</i><sub>opt</sub> <i>ClassBody</i>

<i>BaseClassList</i>:
	<b>:</b> <i>SuperClass</i>
	<b>:</b> <i>SuperClass</i> <i>InterfaceClasses</i>
	<b>:</b> <i>InterfaceClass</i>
	<b>:</b> <i>InterfaceClass</i> <i>InterfaceClasses</i>

<i>SuperClass</i>:
	<i>Identifier</i>
	<i>Protection</i> <i>Identifier</i>

<i>InterfaceClasses</i>:
	<i>InterfaceClass</i>
	<i>InterfaceClass</i> <i>InterfaceClasses</i>

<i>InterfaceClass</i>:
	<i>Identifier</i>
	<i>Protection</i> <i>Identifier</i>

<i>Protection</i>:
	<b>private</b>
	<b>package</b>
	<b>public</b>
	<b>export</b>

<i>ClassBody</i>:
	<b>{</b> <b>}</b>
	<b>{</b> <i>ClassBodyDeclarations</i> <b>}</b>

<i>ClassBodyDeclarations</i>:
	<i>ClassBodyDeclaration</i>
	<i>ClassBodyDeclaration</i> <i>ClassBodyDeclarations</i>

<i>ClassBodyDeclaration</i>:
	<i>Declaration</i>
	<i>Constructor</i>
	<i>Destructor</i>
	<i>StaticConstructor</i>
	<i>StaticDestructor</i>
	<i>Invariant</i>
	<i>UnitTest</i>
	<i>ClassAllocator</i>
	<i>ClassDeallocator</i>
</pre>

Classes consist of:

<dl>
	<dt>super class
	<dt>interfaces
	<dt>dynamic fields
	<dt>static fields
	<dt>types
	<dt>functions
	<dd>
	<dl>
	    <dt>static functions
	    <dt>dynamic functions
	    <dt><a href="#constructors">constructors</a>
	    <dt><a href="#destructors">destructors</a>
	    <dt><a href="#staticconstructor">static constructors</a>
	    <dt><a href="#staticdestructor">static destructors</a>
	    <dt><a href="#invariants">invariants</a>
	    <dt><a href="#unittest">unit tests</a>
	    <dt><a href="#allocators">allocators</a>
	    <dt><a href="#deallocators">deallocators</a>
	</dl>
	</dd>
</dl>

	A class is defined:

<pre class="d_code"><span class="d_keyword">class</span> Foo
{
    ... members ...
}
</pre>

	Note that there is no trailing ; after the closing } of the class
	definition.
	It is also not possible to declare a variable var like:

<pre class="d_code"><span class="d_keyword">class</span> Foo { } var;
</pre>

	Instead:

<pre class="d_code"><span class="d_keyword">class</span> Foo { }
Foo var;
</pre>

<h3>Fields</h3>

	Class members are always accessed with the . operator. There are no :: or -&gt; 
	operators as in C++.
	<p>

	The D compiler is free to rearrange the order of fields in a class to
	optimally pack them in an implementation-defined manner.
	Consider the fields much like the local
	variables in a function - 
	the compiler assigns some to registers and shuffles others around all to
	get the optimal 
	stack frame layout. This frees the code designer to organize the fields
	in a manner that 
	makes the code more readable rather than being forced to organize it
	according to 
	machine optimization rules. Explicit control of field layout is provided
	by struct/union 
	types, not classes.

<h3>Field Properties</h3>

	The <b>.offsetof</b> property gives the offset in bytes of the field
	from the beginning of the class instantiation.
	<b>.offsetof</b> can only be applied to fields qualified with the
	type of the class, not expressions which produce the type of
	the field itself:

<pre class="d_code"><span class="d_keyword">class</span> Foo
{
    <span class="d_keyword">int</span> x;
}
...
<span class="d_keyword">void</span> test(Foo foo)
{
    size_t o;

    o = Foo.x<b>.offsetof</b>;   <span class="d_comment">// yields 8
</span>    o = foo.x<b>.offsetof</b>;   <span class="d_comment">// error, .offsetof an int type
</span>}
</pre>

<h3>Super Class</h3>

	All classes inherit from a super class. If one is not specified,
	it inherits from Object. Object forms the root of the D class
	inheritance hierarchy.

<h3><a name="constructors">Constructors</a></h3>

<pre class="bnf"><i>Constructor</i>:
	<b>this</b> <i>Parameters</i> <i>FunctionBody</i>
</pre>

	Members are always initialized to the default initializer
	for their type, which is usually 0 for integer types and
	NAN for floating point types.
	This eliminates an entire
	class of obscure problems that come from 
	neglecting to initialize a member in one of the constructors.
	In the class definition,
	there can be a static initializer to be 
	used instead of the default:

<pre class="d_code"><span class="d_keyword">class</span> Abc
{
    <span class="d_keyword">int</span> a;	<span class="d_comment">// default initializer for a is 0
</span>    <span class="d_keyword">long</span> b = 7;	<span class="d_comment">// default initializer for b is 7
</span>    <span class="d_keyword">float</span> f;	<span class="d_comment">// default initializer for f is NAN
</span>}
</pre>

	This static initialization is done before any constructors are
	called.
	<p>

	Constructors are defined with a function name of <b>this</b>
	and having no return value:

<pre class="d_code"><span class="d_keyword">class</span> Foo
{
    <b><span class="d_keyword">this</span></b>(<span class="d_keyword">int</span> x)		<span class="d_comment">// declare constructor for Foo
</span>    {   ...
    }
    <b><span class="d_keyword">this</span></b>()
    {   ...
    }
}
</pre>

	Base class construction is done by calling the base class
	constructor by the name <b>super</b>:

<pre class="d_code"><span class="d_keyword">class</span> A { <span class="d_keyword">this</span>(<span class="d_keyword">int</span> y) { } }

<span class="d_keyword">class</span> B : A
{
    <span class="d_keyword">int</span> j;
    <span class="d_keyword">this</span>()
    {
	...
	<b><span class="d_keyword">super</span></b>(3);	<span class="d_comment">// call base constructor A.this(3)
</span>	...
    }
}
</pre>

	Constructors can also call other constructors for the same class
	in order to share common initializations:

<pre class="d_code"><span class="d_keyword">class</span> C
{
    <span class="d_keyword">int</span> j;
    <span class="d_keyword">this</span>()
    {
	...
    }
    <span class="d_keyword">this</span>(<span class="d_keyword">int</span> i)
    {
	<b><span class="d_keyword">this</span></b>();
	j = i;
    }
}
</pre>

	If no call to constructors via <b>this</b> or <b>super</b> appear
	in a constructor, and the base class has a constructor, a call
	to <b>super</b>() is inserted at the beginning of the constructor.
	<p>

	If there is no constructor for a class, but there is a constructor
	for the base class, a default constructor of the form:

<pre class="d_code"><span class="d_keyword">this</span>() { }
</pre>

	is implicitly generated.
	<p>

	Class object construction is very flexible, but some restrictions
	apply:
	<ol>
	<li> It is illegal for constructors to mutually call each other:

<pre class="d_code"><span class="d_keyword">this</span>() { <span class="d_keyword">this</span>(1); }
<span class="d_keyword">this</span>(<span class="d_keyword">int</span> i) { <span class="d_keyword">this</span>(); }	<span class="d_comment">// illegal, cyclic constructor calls
</span></pre>

	<li> If any constructor call appears inside a constructor, any
	path through the constructor must make exactly one constructor
	call:

<pre class="d_code"><span class="d_keyword">this</span>()	{ a || <span class="d_keyword">super</span>(); }	<span class="d_comment">// illegal
</span>
<span class="d_keyword">this</span>() { <span class="d_keyword">this</span>(1) || <span class="d_keyword">super</span>(); }	<span class="d_comment">// ok
</span>
<span class="d_keyword">this</span>()
{
    <span class="d_keyword">for</span> (...)
    {
	<span class="d_keyword">super</span>();	<span class="d_comment">// illegal, inside loop
</span>    }
}
</pre>

	<li> It is illegal to refer to <b>this</b> implicitly or explicitly
	prior to making a constructor call.
	<li> Constructor calls cannot appear after labels (in order to make
	it easy to check for the previous conditions in the presence of goto's).
	</ol>

	Instances of class objects are created with <i>NewExpression</i>s:

<pre class="d_code">A a = <span class="d_keyword">new</span> A(3);
</pre>

	The following steps happen:

<ol>
	<li> Storage is allocated for the object.
	If this fails, rather than return <b>null</b>, an 
	<b>OutOfMemoryException</b> is thrown.
	Thus, tedious checks for null references are unnecessary.

	<li> The raw data is statically initialized using the values provided
	in the class definition.
	The pointer to the vtbl is assigned.
	This ensures that constructors are 
	passed fully formed objects.
	This operation is equivalent to doing a memcpy() of a static 
	version of the object onto the newly allocated one,
	although more advanced compilers 
	may be able to optimize much of this away.

	<li> If there is a constructor defined for the class,
	the constructor matching the 
	argument list is called.

	<li> If class invariant checking is turned on, the class invariant
	is called at the end of the constructor.
</ol>

<h3><a name="destructors">Destructors</a></h3>

<pre class="bnf"><i>Destructor</i>:
	<b>~this()</b> <i>FunctionBody</i>
</pre>

	The garbage collector calls the destructor function when the object
	is deleted. The syntax 
	is:

<pre class="d_code"><span class="d_keyword">class</span> Foo
{
	~<span class="d_keyword">this</span>()		<span class="d_comment">// destructor for Foo
</span>	{
	}
}
</pre>

	There can be only one destructor per class, the destructor
	does not have any parameters, 
	and has no attributes. It is always virtual.
	<p>

	The destructor is expected to release any resources held by the object.
	<p>

	The  program can explicitly inform the garbage collector that an
	object is no longer referred to (with the delete expression), and
	then the garbage collector calls the destructor  
	immediately, and adds the object's memory to the free storage.
	The destructor is guaranteed to never be called twice.
	<p>

	The destructor for the super class automatically gets called when
	the destructor ends. There is no way to call the super destructor
	explicitly.
	<p>

	When the garbage collector calls a destructor for an object of a class
	that has
	members that are references to garbage collected objects, those
	references are no longer valid. This means that destructors
	cannot reference sub objects.
	This rule does not apply to auto objects or objects deleted
	with the <i>DeleteExpression</i>.
	<p>

	The garbage collector is not guaranteed to run the destructor
	for all unreferenced objects. Furthermore, the order in which the
	garbage collector calls destructors for unreference objects
	is not specified.
	<p>

	Objects referenced from the data segment never get collected
	by the gc.

<h3><a name="staticconstructor">Static Constructors</a></h3>

<pre class="bnf"><i>StaticConstructor</i>:
	<b>static this()</b> <i>FunctionBody</i>
</pre>

	A static constructor is defined as a function that performs
	initializations before the 
	<tt>main()</tt> function gets control. Static constructors are used to
	initialize
	static class members 
	with values that cannot be computed at compile time.
	<p>

	Static constructors in other languages are built implicitly by using
	member 
	initializers that can't be computed at compile time. The trouble with
	this stems from not 
	having good control over exactly when the code is executed, for example:

<pre class="d_code"><span class="d_keyword">class</span> Foo
{
    <span class="d_keyword">static</span> <span class="d_keyword">int</span> a = b + 1;
    <span class="d_keyword">static</span> <span class="d_keyword">int</span> b = a * 2;
}
</pre>

	What values do a and b end up with, what order are the initializations
	executed in, what 
	are the values of a and b before the initializations are run, is this a
	compile error, or is this 
	a runtime error? Additional confusion comes from it not being obvious if
	an initializer is 
	static or dynamic.
	<p>

	D makes this simple. All member initializations must be determinable by
	the compiler at 
	compile time, hence there is no order-of-evaluation dependency for
	member 
	initializations, and it is not possible to read a value that has not
	been initialized. Dynamic 
	initialization is performed by a static constructor, defined with
	a special syntax <tt>static this()</tt>.

<pre class="d_code"><span class="d_keyword">class</span> Foo
{
    <span class="d_keyword">static</span> <span class="d_keyword">int</span> a;		<span class="d_comment">// default initialized to 0
</span>    <span class="d_keyword">static</span> <span class="d_keyword">int</span> b = 1;
    <span class="d_keyword">static</span> <span class="d_keyword">int</span> c = b + a;	<span class="d_comment">// error, not a constant initializer
</span>
    <b><span class="d_keyword">static</span> <span class="d_keyword">this</span></b>()		<span class="d_comment">// static constructor
</span>    {
	a = b + 1;		<span class="d_comment">// a is set to 2
</span>	b = a * 2;		<span class="d_comment">// b is set to 4
</span>    }
}
</pre>

	<tt>static this()</tt> is called by the startup code before
	<tt>main()</tt> is called. If it returns normally 
	(does not throw an exception), the static destructor is added
	to the list of functions to be 
	called on program termination.
	Static constructors have empty parameter lists.
	<p>

	Static constructors within a module are executed in the lexical
	order in which they appear.
	All the static constructors for modules that are directly or
	indirectly imported
	are executed before the static constructors for the importer.
	<p>

	The <b>static</b> in the static constructor declaration is not
	an attribute, it must appear immediately before the <b>this</b>:

<pre class="d_code"><span class="d_keyword">class</span> Foo
{
    <span class="d_keyword">static</span> <span class="d_keyword">this</span>() { ... }	<span class="d_comment">// a static constructor
</span>    <span class="d_keyword">static</span> <span class="d_keyword">private</span> <span class="d_keyword">this</span>() { ... } <span class="d_comment">// not a static constructor
</span>    <span class="d_keyword">static</span>
    {
	<span class="d_keyword">this</span>() { ... }		<span class="d_comment">// not a static constructor
</span>    }
    <span class="d_keyword">static</span>:
	<span class="d_keyword">this</span>() { ... }		<span class="d_comment">// not a static constructor
</span>}
</pre>

<h3><a name="staticdestructor">Static Destructor</a></h3>

<pre class="bnf"><i>StaticDestructor</i>:
	<b>static ~this()</b> <i>FunctionBody</i>
</pre>

	A static destructor is defined as a special static function with the
	syntax <tt>static ~this()</tt>.

<pre class="d_code"><span class="d_keyword">class</span> Foo
{
    <span class="d_keyword">static</span> ~<span class="d_keyword">this</span>()		<span class="d_comment">// static destructor
</span>    {
    }
}
</pre>

	A static destructor gets called on program termination, but only if
	the static constructor 
	completed successfully.
	Static destructors have empty parameter lists.
	Static destructors get called in the reverse order that the static
	constructors were called in.
	<p>

	The <b>static</b> in the static denstructor declaration is not
	an attribute, it must appear immediately before the <b>~this</b>:

<pre class="d_code"><span class="d_keyword">class</span> Foo
{
    <span class="d_keyword">static</span> ~<span class="d_keyword">this</span>() { ... }	<span class="d_comment">// a static destructor
</span>    <span class="d_keyword">static</span> <span class="d_keyword">private</span> ~<span class="d_keyword">this</span>() { ... } <span class="d_comment">// not a static destructor
</span>    <span class="d_keyword">static</span>
    {
	~<span class="d_keyword">this</span>() { ... }		<span class="d_comment">// not a static destructor
</span>    }
    <span class="d_keyword">static</span>:
	~<span class="d_keyword">this</span>() { ... }		<span class="d_comment">// not a static destructor
</span>}
</pre>

<h3><a name="invariants">Class Invariants</a></h3>

<pre class="bnf"><i>ClassInvariant</i>:
	<b>invariant</b> <i>FunctionBody</i>
</pre>

    Class invariants are used to specify characteristics of a class that always
    must be true (except while executing a member function). For example, a
    class representing a date might have an invariant that the day must be 1..31
    and the hour must be 0..23:

    <!-- invariant and test should be keywords? -->

<pre class="d_code"><span class="d_keyword">class</span> Date
{
    <span class="d_keyword">int</span> day;
    <span class="d_keyword">int</span> hour;

    <b><span class="d_keyword">invariant</span></b>
    {
	<span class="d_keyword">assert</span>(1 &lt;= day &amp;&amp; day &lt;= 31);
	<span class="d_keyword">assert</span>(0 &lt;= hour &amp;&amp; hour &lt; 24);
    }
}
</pre>

	The class invariant is a contract saying that the asserts must hold
	true.
	The invariant is checked when a class constructor completes,
	at the start of the class destructor, before a public or exported
	member is run, and after a public or exported function finishes.
	<p>

	The code in the invariant may not call any public non-static members
	of the
	class, either directly or indirectly.
	Doing so will result in a stack overflow, as the invariant will wind
	up being called in an infinitely recursive manner.

<pre class="d_code"><span class="d_keyword">class</span> Foo
{
    <span class="d_keyword">public</span> <span class="d_keyword">void</span> f() { }
    <span class="d_keyword">private</span> <span class="d_keyword">void</span> g() { }

    <b><span class="d_keyword">invariant</span></b>
    {
	f();  <span class="d_comment">// error, cannot call public member function from invariant
</span>	g();  <span class="d_comment">// ok, g() is not public
</span>    }
}
</pre>

	The invariant
	can be checked when a class object is the argument to an
	<code>assert()</code> expression, as:

<pre class="d_code">Date mydate;
...
<span class="d_keyword">assert</span>(mydate);		<span class="d_comment">// check that class Date invariant holds
</span></pre>

	If the invariant fails, it throws an <code>InvariantException</code>.
	Class invariants are inherited, that is,
	any class invariant is implicitly anded with the invariants of its base classes.
	<p>

	There can be only one <i>ClassInvariant</i> per class.
	<p>

	When compiling for release, the invariant code is not generated, and the compiled program
	runs at maximum speed.

<h3><a name="unittest">Unit Tests</a></h3>

<pre class="bnf"><i>UnitTest</i>:
	<b>unittest</b> <i>FunctionBody</i>
</pre>

	Unit tests are a series of test cases applied to a class to determine
	if it is working properly. Ideally, unit tests should be run every
	time a program is compiled. The best way to make sure that unit
	tests do get run, and that they are maintained along with the class
	code is to put the test code right in with the class implementation
	code.
	<p>

	Classes can have a special member function called:

<pre class="d_code"><span class="d_keyword">unittest</span>
{
    ...test code...
}
</pre>

	A compiler switch, such as <b>-unittest</b> for <b>dmd</b>, will
	cause the unittest test code to be compiled and incorporated into
	the resulting executable. The unittest code gets run after
	static initialization is run and before the <tt>main()</tt>
	function is called.
	<p>

	For example, given a class Sum that is used to add two values:

<pre class="d_code"><span class="d_keyword">class</span> Sum
{
    <span class="d_keyword">int</span> add(<span class="d_keyword">int</span> x, <span class="d_keyword">int</span> y) { <span class="d_keyword">return</span> x + y; }

    <span class="d_keyword">unittest</span>
    {
	Sum sum = <span class="d_keyword">new</span> Sum;
	<span class="d_keyword">assert</span>(sum.add(3,4) == 7);
	<span class="d_keyword">assert</span>(sum.add(-2,0) == -2);
    }
}
</pre>

<h3><a name="allocators">Class Allocators</a></h3>

<pre class="bnf"><i>ClassAllocator</i>:
	<b>new</b> <i>Parameters</i> <i>FunctionBody</i>
</pre>

	A class member function of the form:

<pre class="d_code"><span class="d_keyword">new</span>(<span class="d_keyword">uint</span> size)
{
    ...
}
</pre>

	is called a class allocator.
	The class allocator can have any number of parameters, provided
	the first one is of type uint.
	Any number can be defined for a class, the correct one is
	determined by the usual function overloading rules.
	When a new expression:

<pre class="d_code"><span class="d_keyword">new</span> Foo;
</pre>

	is executed, and Foo is a class that has
	an allocator, the allocator is called with the first argument
	set to the size in bytes of the memory to be allocated for the
	instance.
	The allocator must allocate the memory and return it as a
	<tt>void*</tt>.
	If the allocator fails, it must not return a <b>null</b>, but
	must throw an exception.
	If there is more than one parameter to the allocator, the
	additional arguments are specified within parentheses after
	the <b>new</b> in the <i>NewExpression</i>:

<pre class="d_code"><span class="d_keyword">class</span> Foo
{
    <span class="d_keyword">this</span>(<span class="d_keyword">char</span>[] a) { ... }

    <span class="d_keyword">new</span>(<span class="d_keyword">uint</span> size, <span class="d_keyword">int</span> x, <span class="d_keyword">int</span> y)
    {
	...
    }
}

...

<span class="d_keyword">new</span>(1,2) Foo(a);	<span class="d_comment">// calls new(Foo.sizeof,1,2)
</span></pre>

	Derived classes inherit any allocator from their base class,
	if one is not specified.
	<p>

	See also <a href="memory.html#newdelete">Explicit Class Instance Allocation</a>.

<h3><a name="deallocators">Class Deallocators</a></h3>

<pre class="bnf"><i>ClassDeallocator</i>:
	<b>delete</b> <i>Parameters</i> <i>FunctionBody</i>
</pre>

	A class member function of the form:

<pre class="d_code"><span class="d_keyword">delete</span>(<span class="d_keyword">void</span> *p)
{
    ...
}
</pre>

	is called a class deallocator.
	The deallocator must have exactly one parameter of type <tt>void*</tt>.
	Only one can be specified for a class.
	When a delete expression:

<pre class="d_code"><span class="d_keyword">delete</span> f;
</pre>

	is executed, and f is a reference to a class instance that has
	a deallocator, the deallocator is called with a pointer to the
	class instance after the destructor (if any) for the class is
	called. It is the responsibility of the deallocator to free
	the memory.
	<p>

	Derived classes inherit any deallocator from their base class,
	if one is not specified.
	<p>

	See also <a href="memory.html#newdelete">Explicit Class Instance Allocation</a>.

<h3><a name="auto">Auto Classes</a></h3>

	An auto class is a class with the auto attribute, as in:

<pre class="d_code"><span class="d_keyword">auto</span> <span class="d_keyword">class</span> Foo { ... }
</pre>

	The auto characteristic is inherited, so if any classes derived
	from an auto class are also auto.
	<p>

	An auto class reference can only appear as a function local variable.
	It must be declared as being <b>auto</b>:

<pre class="d_code"><span class="d_keyword">auto</span> <span class="d_keyword">class</span> Foo { ... }

<span class="d_keyword">void</span> func()
{
    Foo f;	<span class="d_comment">// error, reference to auto class must be auto
</span>    <span class="d_keyword">auto</span> Foo g = <span class="d_keyword">new</span> Foo();	<span class="d_comment">// correct
</span>}
</pre>

	When an auto class reference goes out of scope, the destructor
	(if any) and custom deallocator (if any) for it is automatically called.
	This holds true even if
	the scope was exited via a thrown exception.

<h2><a name="nested">Nested Classes</a></h2>

	A <i>nested class</i> is a class that is declared inside the scope
	of a function or another class.
	A nested class has access to the variables and other symbols
	of the classes and functions it is nested inside:

<pre class="d_code"><span class="d_keyword">class</span> Outer
{
    <span class="d_keyword">int</span> m;

    <span class="d_keyword">class</span> Inner
    {
	<span class="d_keyword">int</span> foo()
	{
	    <span class="d_keyword">return</span> m;	<span class="d_comment">// Ok to access member of Outer
</span>	}
    }
}

<span class="d_keyword">void</span> func()
{   <span class="d_keyword">int</span> m;

    <span class="d_keyword">class</span> Inner
    {
	<span class="d_keyword">int</span> foo()
	{
	    <span class="d_keyword">return</span> m;	<span class="d_comment">// Ok to access local variable m of func()
</span>	}
    }
}
</pre>

	If a nested class has the <b>static</b> attribute, then it can
	not access variables of the enclosing scope that are local to the
	stack or need a <b>this</b>:

<pre class="d_code"><span class="d_keyword">class</span> Outer
{
    <span class="d_keyword">int</span> m;
    <span class="d_keyword">static</span> <span class="d_keyword">int</span> n;

    <span class="d_keyword">static</span> <span class="d_keyword">class</span> Inner
    {
	<span class="d_keyword">int</span> foo()
	{
	    <span class="d_keyword">return</span> m;	<span class="d_comment">// Error, Inner is static and m needs a <b>this</b>
</span>	    <span class="d_keyword">return</span> n;	<span class="d_comment">// Ok, n is static
</span>	}
    }
}

<span class="d_keyword">void</span> func()
{   <span class="d_keyword">int</span> m;
    <span class="d_keyword">static</span> <span class="d_keyword">int</span> n;

    <span class="d_keyword">static</span> <span class="d_keyword">class</span> Inner
    {
	<span class="d_keyword">int</span> foo()
	{
	    <span class="d_keyword">return</span> m;	<span class="d_comment">// Error, Inner is static and m is local to the stack
</span>	    <span class="d_keyword">return</span> n;	<span class="d_comment">// Ok, n is static
</span>	}
    }
}
</pre>

	Non-static nested classes work by containing an extra hidden member
	(called the context pointer)
	that is the frame pointer of the enclosing function if it is nested
	inside a function, or the <b>this</b> of the enclosing class's instance
	if it is nested inside a class.
	<p>

	When a non-static nested class is instantiated, the context pointer
	is assigned before the class's constructor is called, therefore
	the constructor has full access to the enclosing variables.
	A non-static nested class can only be instantiated when the necessary
	context pointer information is available:

<pre class="d_code"><span class="d_keyword">class</span> Outer
{
    <span class="d_keyword">class</span> Inner { }

    <span class="d_keyword">static</span> <span class="d_keyword">class</span> SInner { }
}

<span class="d_keyword">void</span> func()
{
    <span class="d_keyword">class</span> Nested { }

    Outer o = <span class="d_keyword">new</span> Outer;	<span class="d_comment">// Ok
</span>    Outer.Inner oi = <span class="d_keyword">new</span> Outer.Inner;	<span class="d_comment">// Error, no 'this' for Outer
</span>    Outer.SInner os = <span class="d_keyword">new</span> Outer.SInner;	<span class="d_comment">// Ok
</span>
    Nested n = <span class="d_keyword">new</span> Nested;	<span class="d_comment">// Ok
</span>}
</pre>

	While a non-static nested class can access the stack variables
	of its enclosing function, that access becomes invalid once
	the enclosing function exits:

<pre class="d_code"><span class="d_keyword">class</span> Base
{
    <span class="d_keyword">int</span> foo() { <span class="d_keyword">return</span> 1; }
}

Base func()
{   <span class="d_keyword">int</span> m = 3;

    <span class="d_keyword">class</span> Nested : Base
    {
	<span class="d_keyword">int</span> foo() { <span class="d_keyword">return</span> m; }
    }

    Base b = <span class="d_keyword">new</span> Nested;

    <span class="d_keyword">assert</span>(b.foo() == 3);	<span class="d_comment">// Ok, func() is still active
</span>    <span class="d_keyword">return</span> b;
}

<span class="d_keyword">int</span> test()
{
    Base b = func();
    <span class="d_keyword">return</span> b.foo();		<span class="d_comment">// Error, func().m is undefined
</span>}
</pre>

	If this kind of functionality is needed, the way to make it work
	is to make copies of the needed variables within the nested class's
	constructor:

<pre class="d_code"><span class="d_keyword">class</span> Base
{
    <span class="d_keyword">int</span> foo() { <span class="d_keyword">return</span> 1; }
}

Base func()
{   <span class="d_keyword">int</span> m = 3;

    <span class="d_keyword">class</span> Nested : Base
    {   <span class="d_keyword">int</span> m_;

	<span class="d_keyword">this</span>() { m_ = m;
	<span class="d_keyword">int</span> foo() { <span class="d_keyword">return</span> m_; }
    }

    Base b = <span class="d_keyword">new</span> Nested;

    <span class="d_keyword">assert</span>(b.foo() == 3);	<span class="d_comment">// Ok, func() is still active
</span>    <span class="d_keyword">return</span> b;
}

<span class="d_keyword">int</span> test()
{
    Base b = func();
    <span class="d_keyword">return</span> b.foo();		<span class="d_comment">// Ok, using cached copy of func().m
</span>}
</pre>

	<p>A <i>this</i> can be supplied to the creation of an
	inner class instance by prefixing it to the <i>NewExpression</i>:
	</p>

<pre class="d_code"><span class="d_keyword">class</span> Outer
{   <span class="d_keyword">int</span> a;

    <span class="d_keyword">class</span> Inner
    {
	<span class="d_keyword">int</span> foo()
	{
	    <span class="d_keyword">return</span> a;
	}
    }
}

<span class="d_keyword">int</span> bar()
{
    Outer o = <span class="d_keyword">new</span> Outer; 
    o.a = 3;
    Outer.Inner oi = <b>o</b>.<span class="d_keyword">new</span> Inner;
    <span class="d_keyword">return</span> oi.foo();	<span class="d_comment">// returns 3
</span>}
</pre>

	<p>Here <b>o</b> supplies the <i>this</i> to the outer class
	instance of <b>Outer</b>.
	</p>

<h3><a name="anonymous">Anonymous Nested Classes</a></h3>

	An anonymous nested class is both defined and instantiated with
	a <i>NewAnonClassExpression</i>:

<pre class="bnf"><i>NewAnonClassExpression</i>:
    <b>new (</b><i>ArgumentList</i><b>)</b><sub>opt</sub> <b>class (</b><i>ArgumentList</i><b>)</b><sub>opt</sub> <i>SuperClass</i><sub>opt</sub> <i>InterfaceClasses</i><sub>opt</sub> <i>ClassBody</i>
</pre>

	which is equivalent to:

<pre class="d_code"><span class="d_keyword">class</span> <i>Identifier</i> : <i>SuperClass</i> <i>InterfaceClasses</i>
	<i>ClassBody</i>

<span class="d_keyword">new</span> (<i>ArgumentList</i>) <i>Identifier</i> (<i>ArgumentList</i>);
</pre>

	where <i>Identifier</i> is the name generated for the anonymous
	nested class.


  
<br><br>
<br><br>
<!-- Google ad -->
<script type="text/javascript"><!--
/**/google_ad_client = "pub-5628673096434613";
/**/google_ad_width = 728;
/**/google_ad_height = 90;
/**/google_ad_format = "728x90_as";
/**/google_ad_channel ="3651639259";
/**/google_page_url = document.location;
//--></script>
<script type="text/javascript" src="../../../../../../../../pagead2.googlesyndication.com/pagead/show_ads.js">
</script>

</div>





<div id="copyright">
Copyright &copy; 1999-2006 by Digital Mars, All Rights Reserved |
Page generated by <a href="http://www.digitalmars.com/d/ddoc.html">Ddoc</a>. |
<a href="http://www.prowiki.org/wiki4d/wiki.cgi?DocComments/Class" title="Read/write comments and feedback">Comments</a>
</div>

</body>

<!-- Mirrored from www.shorthike.com/trac/browser/trunk/tools_win32/dmd/html/d/class.html?format=raw by HTTrack Website Copier/3.x [XR&CO'2010], Sat, 01 May 2010 04:32:23 GMT -->
<!-- Added by HTTrack --><meta http-equiv="content-type" content="text/html;charset=UTF-8"><!-- /Added by HTTrack -->
</html>

