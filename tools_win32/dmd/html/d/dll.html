
<!DOCTYPE html PUBLIC "-//W3C//DTD HTML 4.01//EN" "http://www.w3.org/TR/html4/strict.dtd">
<html>

<!--
	Copyright (c) 1999-2006 by Digital Mars
	All Rights Reserved
	Written by Walter Bright
	www.digitalmars.com
  -->


<!-- Mirrored from www.shorthike.com/trac/browser/trunk/tools_win32/dmd/html/d/dll.html?format=raw by HTTrack Website Copier/3.x [XR&CO'2010], Sat, 01 May 2010 04:37:18 GMT -->
<!-- Added by HTTrack --><meta http-equiv="content-type" content="text/html;charset=UTF-8"><!-- /Added by HTTrack -->
<head>
<meta http-equiv="content-type" content="text/html; charset=utf-8" />
<meta name="keywords" content="D programming language" />
<meta name="description" content="D Programming Language" />
<title>D Programming Language - Writing Win32 DLLs</title>
<link rel="stylesheet" type="text/css" href="style.html" />
<link rel="shortcut icon" href="favicon.html" />
</head>

<body>
<div id="heading">
	<a href="http://www.digitalmars.com/"><img src="dmlogo.html" width="270" height="53" style="border-style:none" alt="www.digitalmars.com"></a>

	<div id="headingNav">
	<ul>	<li><a href="http://www.prowiki.org/wiki4d/wiki.cgi?DocComments/DLLs" title="Read/write comments and feedback">Comments</a></li>
	<li><a href="index.html" title="D Programming Language" class="dlink">D</a></li>
	<li><a href="http://www.digitalmars.com/advancedsearch.html" title="Search Digital Mars web site">Search</a></li>
	<li><a href="download.html" title="download D">Downloads</a></li>
	<li><a href="http://www.digitalmars.com/" title="www.digitalmars.com">Home</a></li>
	</ul>
	</div>

	<div id="lastupdate">Last update Tue Jun  6 16:38:20 2006
</div>
</div>

<!-- Generated by Ddoc from dll.d -->



<div id="navigation">
  
<div class="navblock">
<form method="get" action="http://www.google.com/search">
<div id="searchbox">
<input id="q" name="q" size="10" value="Search" onFocus='if(this.value == "Search"){this.value="";}'>
<input type="hidden" id="domains" name="domains" value="www.digitalmars.com">
<input type="hidden" id="sitesearch" name="sitesearch" value="www.digitalmars.com/d">
<input type="hidden" id="sourceid" name="sourceid" value="google-search">
<input type="submit" id="submit" name="submit" value="Go">
</div>
</form>
<div id="toctop">
    <ul>	<li><a href="index.html" title="D Programming Language">D ...</a></li>
	<li><a href="lex.html" title="D Language Specification">Language ...</a></li>
	<li><a href="phobos/phobos.html" title="D Runtime Library">Phobos ...</a></li>
	<li><a href="comparison.html" title="Language Comparisons">Comparisons ...</a></li>
    </ul>
</div>
</div>

  
    <div class="navblock">
	<ul>		<li><a href="overview.html">Overview</a></li>

		<li><a href="windows.html">D for Win32</a></li>

		<li><a href="dll.html">Win32 DLLs in D</a></li>

		<li><a href="htomodule.html">C .h to D Modules</a></li>

		<li><a href="faq.html">FAQ</a></li>

		<li><a href="dstyle.html">Style Guide</a></li>

		<li><a href="wc.html">Example: wc</a></li>

		<li><a href="future.html">Future</a></li>

		<li><a href="changelog.html">D Change Log</a></li>

		<li><a href="http://www.digitalmars.com/techtips/index.html">Tech Tips</a></li>

		<li><a href="rationale.html">Rationale</a></li>

		<li><a href="warnings.html">Warnings</a></li>

	</ul>
    </div>

    <div class="navblock">
	<h2>Articles</h2>
	<ul>		<li><a href="memory.html">Memory Management</a></li>

		<li><a href="exception-safe.html">Exception Safety</a></li>

		<li><a href="templates-revisited.html">Templates Revisited</a></li>

		<li><a href="regular-expression.html">Regular Expressions</a></li>

	</ul>
    </div>

    <div class="navblock">
	<h2>Tools</h2>
	<ul>		<li><a href="dcompiler.html">DMD D Compiler</a></li>

		<li><a href="http://dgcc.sourceforge.net/">GDC D Compiler</a></li>

		<li><a href="http://www.digitalmars.com/ctg/optlink.html">Linker</a></li>

		<li><a href="http://www.digitalmars.com/ctg/trace.html">Profiler</a></li>

		<li><a href="code_coverage.html">Code Coverage</a></li>

		<li><a href="rdmd.html">DMD Script Shell</a></li>

		<li><a href="windbg.html">Windows Debugger</a></li>

		<li><a href="htod.html">C .h to D .d</a></li>

		<li><a href="http://www.prowiki.org/wiki4d/wiki.cgi?EditorSupport">Editors</a></li>

		<li><a href="http://www.prowiki.org/wiki4d/wiki.cgi?ReferenceForTools">More Tools</a></li>

	</ul>
    </div>

    <div class="navblock">
	<h2>Community</h2>
	<ul>		
		<li><a href="http://www.digitalmars.com/NewsGroup.html">News</a></li>

		<li><a href="http://www.digitalmars.com/drn-bin/wwwnews?digitalmars.D">Forum</a></li>

		<li><a href="http://www.digitalmars.com/drn-bin/wwwnews?digitalmars.D.announce">Announcements</a></li>

		<li><a href="http://www.digitalmars.com/drn-bin/wwwnews?digitalmars.D.learn">Learn</a></li>

		<li><a href="dlinks.html">D links</a></li>

	</ul>
    </div>

    <div class="navblock">
	<h2>Archives</h2>
	<ul>		<li><a href="http://www.digitalmars.com/d/archives/digitalmars/D/index.html">digitalmars.D</a></li>

		<li><a href="http://www.digitalmars.com/d/archives/digitalmars/D/dtl/index.html">digitalmars.D.dtl</a></li>

		<li><a href="http://www.digitalmars.com/d/archives/digitalmars/D/announce/index.html">digitalmars.D.announce</a></li>

		<li><a href="http://www.digitalmars.com/d/archives/digitalmars/D/dwt/index.html">digitalmars.D.dwt</a></li>

		<li><a href="http://www.digitalmars.com/d/archives/digitalmars/D/learn/index.html">digitalmars.D.learn</a></li>

		<li><a href="http://www.digitalmars.com/d/archives/digitalmars/D/bugs/index.html">digitalmars.D.bugs</a></li>

		<li><a href="http://www.digitalmars.com/d/archives/D/gnu/index.html">D.gnu</a></li>

		<li><a href="http://www.digitalmars.com/d/archives/index.html">Old D</a></li>

	</ul>
    </div>

    <div class="navblock">
	<h2>Appendices</h2>
	<ul>		<li><a href="glossary.html">Glossary</a></li>

		<li><a href="ascii-table.html">Ascii Table</a></li>

		<li><a href="acknowledgements.html">Acknowledgements</a></li>

	</ul>
    </div>


</div>
<div id="content">
  <h1>        Writing Win32 DLLs in D</h1>
  
	DLLs (Dynamic Link Libraries) are one of the foundations
	of system programming for Windows. The D programming
	language enables the creation of several different types of
	DLLs.
	<p>

	For background information on what DLLs are and how they work
	Chapter 11 of Jeffrey Richter's book
	<a href="http://www.amazon.com/exec/obidos/ASIN/1572315482/classicempire">
	Advanced Windows</a> is indispensible.
	<p>

	This guide will show how to create DLLs of various types with D.

	<ul>
	<li> <a href="#Cinterface">DLLs with a C interface</a>
	<li> <a href="#com">DLLs that are COM servers</a>
	<li> <a href="#Dcode">D code calling D code in DLLs</a>
	</ul>

<h2><a name="Cinterface">DLLs with a C Interface</a></h2>

	A DLL presenting a C interface can connect to any other code
	in a language that supports calling C functions in a DLL.

	DLLs can be created in D in roughly the same way as in C.
	A <tt>DllMain()</tt>
	is required, looking like:

<pre class="d_code"><span class="d_keyword">import</span> std.c.windows.windows;
HINSTANCE g_hInst;

<span class="d_keyword">extern</span> (C)
{
	<span class="d_keyword">void</span> gc_init();
	<span class="d_keyword">void</span> gc_term();
	<span class="d_keyword">void</span> _minit();
	<span class="d_keyword">void</span> _moduleCtor();
	<span class="d_keyword">void</span> _moduleUnitTests();
}

<span class="d_keyword">extern</span> (Windows)
BOOL <b>DllMain</b>(HINSTANCE hInstance, ULONG ulReason, LPVOID pvReserved)
{
    <span class="d_keyword">switch</span> (ulReason)
    {
	<span class="d_keyword">case</span> DLL_PROCESS_ATTACH:
	    gc_init();			<span class="d_comment">// initialize GC
</span>	    _minit();			<span class="d_comment">// initialize module list
</span>	    _moduleCtor();		<span class="d_comment">// run module constructors
</span>	    _moduleUnitTests();		<span class="d_comment">// run module unit tests
</span>	    <span class="d_keyword">break</span>;

	<span class="d_keyword">case</span> DLL_PROCESS_DETACH:
	    gc_term();			<span class="d_comment">// shut down GC
</span>	    <span class="d_keyword">break</span>;

	<span class="d_keyword">case</span> DLL_THREAD_ATTACH:
	<span class="d_keyword">case</span> DLL_THREAD_DETACH:
	    <span class="d_comment">// Multiple threads not supported yet
</span>	    <span class="d_keyword">return</span> <span class="d_keyword">false</span>;
    }
    g_hInst=hInstance;
    <span class="d_keyword">return</span> <span class="d_keyword">true</span>;
}
</pre>

	Notes:
	<ul>
	<li> The _moduleUnitTests() call is optional.
	<li> The presence of <tt>DllMain()</tt> is recognized by the compiler
		causing it to emit a reference to
		<a href="http://www.digitalmars.com/ctg/acrtused.html">__acrtused_dll</a>
		and the phobos.lib runtime library.
	</ul>

	Link with a .def
	(<a href="http://www.digitalmars.com/ctg/ctgDefFiles.html">Module Definition File</a>)
	along the lines of:

<pre class="moddeffile">LIBRARY         MYDLL
DESCRIPTION     'My DLL written in D'

EXETYPE		NT
CODE            PRELOAD DISCARDABLE
DATA            PRELOAD SINGLE

EXPORTS
		DllGetClassObject       @2
		DllCanUnloadNow         @3
		DllRegisterServer       @4
		DllUnregisterServer     @5
</pre>



	The functions in the EXPORTS list are for illustration.
	Replace them with the actual exported functions from MYDLL.
	Alternatively, use <a href="http://www.digitalmars.com/ctg/implib.html">implib</a>.
	Here's an example of a simple DLL with a function print()
	which prints a string:

	<h4>mydll2.d:</h4>
<pre class="d_code"><span class="d_keyword">module</span> mydll;
<span class="d_keyword">export</span> <span class="d_keyword">void</span> dllprint() { printf(<span class="d_string">"hello dll world\n"</span>); }
</pre>

	<h4>mydll.def:</h4>

<pre class="moddeffile">LIBRARY "mydll.dll"
EXETYPE NT
SUBSYSTEM WINDOWS
CODE SHARED EXECUTE
DATA WRITE
</pre>



	Put the code above that contains DllMain() into a file dll.d.
	Compile and link the dll with the following command:

<pre class="console">C:&gt;dmd -ofmydll.dll mydll2.d dll.d mydll.def
C:&gt;implib/system mydll.lib mydll.dll
C:&gt;
</pre>

	which will create mydll.dll and mydll.lib.
	Now for a program, test.d, which will use the dll:

	<h4>test.d:</h4>
<pre class="d_code"><span class="d_keyword">import</span> mydll;

<span class="d_keyword">int</span> main()
{
   mydll.dllprint();
   <span class="d_keyword">return</span> 0;
}
</pre>

	Create a clone of mydll2.d that doesn't have the function bodies:

	<h4>mydll.d:</h4>
<pre class="d_code"><span class="d_keyword">export</span> <span class="d_keyword">void</span> dllprint();
</pre>

	Compile and link with the command:

<pre class="console">C:&gt;dmd test.d mydll.lib
C:&gt;
</pre>

	and run:
<pre class="console">C:&gt;test
hello dll world
C:&gt;
</pre>



<h3>Memory Allocation</h3>

	D DLLs use garbage collected memory management. The question is what
	happens when pointers to allocated data cross DLL boundaries?
	If the DLL presents a C interface, one would assume the reason
	for that is to connect with code written in other languages.
	Those other languages will not know anything about D's memory
	management. Thus, the C interface will have to shield the
	DLL's callers from needing to know anything about it.
	<p>

	There are many approaches to solving this problem:

	<ul>

	<li> Do not return pointers to D gc allocated memory to the caller of
	the DLL. Instead, have the caller allocate a buffer, and have the DLL
	fill in that buffer.

	<li> Retain a pointer to the data within the D DLL so the GC will not free
	it. Establish a protocol where the caller informs the D DLL when it is
	safe to free the data.

	<li> Use operating system primitives like VirtualAlloc() to allocate
	memory to be transferred between DLLs.

	<li> Use std.c.stdlib.malloc() (or another non-gc allocator) when
	allocating data to be returned to the caller. Export a function
	that will be used by the caller to free the data.

	</ul>

<h2><a name="com">COM Programming</a></h2>

	Many Windows API interfaces are in terms of COM (Common Object Model)
	objects (also called OLE or ActiveX objects). A COM object is an object
	who's first field is a pointer to a vtbl[], and the first 3 entries
	in that vtbl[] are for QueryInterface(), AddRef(), and Release().
	<p>

	For understanding COM, Kraig Brockshmidt's
	<a href="http://www.amazon.com/exec/obidos/ASIN/1556158432/classicempire">
	Inside OLE</a>
	is an indispensible resource.
	<p>

	COM objects are analogous to D interfaces. Any COM object can be
	expressed as a D interface, and every D object with an interface X
	can be exposed as a COM object X.
	This means that D is compatible with COM objects implemented
	in other languages.
	<p>

	While not strictly necessary, the Phobos library provides an Object
	useful as a super class for all D COM objects, called ComObject.
	ComObject provides a default implementation for
	QueryInterface(), AddRef(), and Release().
	<p>

	Windows COM objects use the Windows calling convention, which is not
	the default for D, so COM functions need to have the attribute
	extern (Windows).

	So, to write a COM object:

<pre class="d_code"><span class="d_keyword">import</span> std.c.windows.com;

<span class="d_keyword">class</span> MyCOMobject : ComObject
{
    <span class="d_keyword">extern</span> (Windows):
	...
}
</pre>

	The sample code includes an example COM client program and server DLL.

<h2><a name="Dcode">D code calling D code in DLLs</a></h2>

	Having DLLs in D be able to talk to each other as if they
	were statically linked together is, of course, very desirable
	as code between applications can be shared, and different
	DLLs can be independently developed.
	<p>

	The underlying difficulty is what to do about garbage collection (gc).
	Each EXE and DLL will have their own gc instance. While
	these gc's can coexist without stepping on each other,
	it's redundant and inefficient to have multiple gc's running.
	The idea explored here is to pick one gc and have the DLLs
	redirect their gc's to use that one. The one gc used here will be
	the one in the EXE file, although it's also possible to make a
	separate DLL just for the gc.
	<p>

	The example will show both how to statically load a DLL, and
	to dynamically load/unload it.
	<p>

	Starting with the code for the DLL, mydll.d:
<pre class="d_code"><span class="d_comment">/*
 * MyDll demonstration of how to write D DLLs.
 */</span>

<span class="d_keyword">import</span> std.c.stdio;
<span class="d_keyword">import</span> std.c.stdlib;
<span class="d_keyword">import</span> std.string;
<span class="d_keyword">import</span> std.c.windows.windows;
<span class="d_keyword">import</span> std.gc;

HINSTANCE   g_hInst;

<span class="d_keyword">extern</span> (C)
{
	<span class="d_keyword">void</span> _minit();
	<span class="d_keyword">void</span> _moduleCtor();
	<span class="d_keyword">void</span> _moduleDtor();
	<span class="d_keyword">void</span> _moduleUnitTests();
}

<span class="d_keyword">extern</span> (Windows)
    BOOL <b>DllMain</b>(HINSTANCE hInstance, ULONG ulReason, LPVOID pvReserved)
{
    <span class="d_keyword">switch</span> (ulReason)
    {
        <span class="d_keyword">case</span> DLL_PROCESS_ATTACH:
	    printf(<span class="d_string">"DLL_PROCESS_ATTACH\n"</span>);
	    <span class="d_keyword">break</span>;

        <span class="d_keyword">case</span> DLL_PROCESS_DETACH:
	    printf(<span class="d_string">"DLL_PROCESS_DETACH\n"</span>);
	    <b>std.c.stdio._fcloseallp = <span class="d_keyword">null</span>;</b> <span class="d_comment">// so stdio doesn't get closed
</span>	    <span class="d_keyword">break</span>;

        <span class="d_keyword">case</span> DLL_THREAD_ATTACH:
	    printf(<span class="d_string">"DLL_THREAD_ATTACH\n"</span>);
	    <span class="d_keyword">return</span> <span class="d_keyword">false</span>;

        <span class="d_keyword">case</span> DLL_THREAD_DETACH:
	    printf(<span class="d_string">"DLL_THREAD_DETACH\n"</span>);
	    <span class="d_keyword">return</span> <span class="d_keyword">false</span>;
    }
    g_hInst = hInstance;
    <span class="d_keyword">return</span> <span class="d_keyword">true</span>;
}

<span class="d_keyword">export</span> <span class="d_keyword">void</span> <b>MyDLL_Initialize</b>(<span class="d_keyword">void</span>* gc)
{
    printf(<span class="d_string">"MyDLL_Initialize()\n"</span>);
    std.gc.setGCHandle(gc);
    _minit();
    _moduleCtor();
<span class="d_comment">//  _moduleUnitTests();
</span>}

<span class="d_keyword">export</span> <span class="d_keyword">void</span> <b>MyDLL_Terminate</b>()
{
    printf(<span class="d_string">"MyDLL_Terminate()\n"</span>);
    _moduleDtor();			<span class="d_comment">// run module destructors
</span>    std.gc.endGCHandle();
}

<b><span class="d_keyword">static</span> <span class="d_keyword">this</span></b>()
{
    printf(<span class="d_string">"static this for mydll\n"</span>);
}

<b><span class="d_keyword">static</span> ~<span class="d_keyword">this</span></b>()
{
    printf(<span class="d_string">"static ~this for mydll\n"</span>);
}

<span class="d_comment">/* --------------------------------------------------------- */</span>

<span class="d_keyword">class</span> <b>MyClass</b>
{
    <span class="d_keyword">char</span>[] <b>concat</b>(<span class="d_keyword">char</span>[] a, <span class="d_keyword">char</span>[] b)
    {
	<span class="d_keyword">return</span> a ~ <span class="d_string">" "</span> ~ b;
    }

    <span class="d_keyword">void</span> <b>free</b>(<span class="d_keyword">char</span>[] s)
    {
	<span class="d_keyword">delete</span> s;
    }
}

<span class="d_keyword">export</span> MyClass <b>getMyClass</b>()
{
    <span class="d_keyword">return</span> <span class="d_keyword">new</span> MyClass();
}
</pre>

	<dl>
	<dt><b>DllMain</b>
	<dd>This is the main entry point for any D DLL. It gets called
	by the C startup code
	(for DMC++, the source is <tt>\dm\src\win32\dllstart.c</tt>).
	The <b>printf</b>'s are placed there so one can trace how it gets
	called.
	Notice that the initialization and termination code seen in
	the earlier DllMain sample code isn't there.
	This is because the initialization will depend on who is loading
	the DLL, and how it is loaded (statically or dynamically).
	There isn't much to do here.
	The only oddity is the setting of <b>std.d.stdio._fcloseallp</b> to
	null. If this is not set to null, the C runtime will flush
	and close all the standard I/O buffers (like <b>stdout</b>,
	<b>stderr</b>, etc.)
	shutting off further output. Setting it to null defers the
	responsibility for that to the caller of the DLL.
	<p>

	<dt><b>MyDLL_Initialize</b>
	<dd>So instead we'll have our own DLL initialization routine so
	exactly when it is called can be controlled.
	It must be called after the caller has initialized itself,
	the Phobos runtime library, and the module constructors
	(this would normally be by the time <b>main</b>() was entered).
	This function takes one argument, a handle to the
	caller's gc. We'll see how that handle is obtained later.
	Instead of <b>gc_init</b>() being called to initialize
	the DLL's gc, <b>std.gc.setGCHandle</b>() is called and passed the
	handle to which gc to use.
	This step informs the caller's gc
	which data areas of the DLL to scan.
	Afterwards follows the call to the <b>_minit</b>() to initialize the
	module tables, and <b>_moduleCtor</b>() to run the module constructors.
	<b>_moduleUnitTests</b>() is optional and runs the DLL's unit tests.
	The function is <b>export</b>ed as that is how a function is made
	visible outside of a DLL.
	<p>

	<dt><b>MyDLL_Terminate</b>
	<dd>Correspondingly, this function terminates the DLL, and is
	called prior to unloading it.
	It has two jobs; calling the DLL's module destructors via
	<b>_moduleDtor()</b> and informing the runtime that
	the DLL will no longer be using the caller's gc via
	<b>std.gc.endGCHandle</b>().
	That last step is critical, as the DLL will be unmapped from
	memory, and if the gc continues to scan its data areas it will
	cause segment faults.
	<p>

	<dt><b>static this, static ~this</b>
	<dd>These are examples of the module's static constructor
	and destructor,
	here with a print in each to verify that they are running
	and when.
	<p>

	<dt><b>MyClass</b>
	<dd>This is an example of a class that can be exported from
	and used by the caller of a DLL. The <b>concat</b> member
	function allocates some gc memory, and <b>free</b> frees gc
	memory.
	<p>

	<dt><b>getMyClass</b>
	<dd>An exported factory that allocates an instance of <b>MyClass</b>
	and returns a reference to it.
	<p>

	</dl>

	To build the <tt>mydll.dll</tt> DLL:

	<ol>
	<li><b><tt>dmd -c mydll -g</tt></b>
	<br>Compiles <tt>mydll.d</tt> into <tt>mydll.obj</tt>.
	<b>-g</b> turns on debug info generation.
	<p>

	<li><b><tt>dmd mydll.obj \dmd\lib\gcstub.obj mydll.def -g -L/map</tt></b>
	<br>Links <tt>mydll.obj</tt> into a DLL named </tt>mydll.dll</tt>.
	<tt>gcstub.obj</tt> is not required, but it prevents the bulk
	of the gc code from being linked in, since it will not be used
	anyway. It saves about 12Kb.
	<tt>mydll.def</tt> is the
	<a href="http://www.digitalmars.com/ctg/ctgDefFiles.html">Module Definition File</a>,
	and has the contents:

<pre class="moddeffile">LIBRARY         MYDLL
DESCRIPTION     'MyDll demonstration DLL'
EXETYPE		NT
CODE            PRELOAD DISCARDABLE
DATA            PRELOAD SINGLE
</pre>


	<b>-g</b> turns on debug info generation, and
	<b>-L/map</b> generates a map file <tt>mydll.map</tt>.
	<p>

	<li><b><tt>implib /noi /system mydll.lib mydll.dll</tt></b>
	<br>Creates an
	<a href="http://www.digitalmars.com/ctg/implib.html">import library</a>
	<tt>mydll.lib</tt> suitable
	for linking in with an application that will be statically
	loading <tt>mydll.dll</tt>.
	<p>

	</ol>

	Here's <tt>test.d</tt>, a sample application that makes use of
	<tt>mydll.dll</tt>. There are two versions, one statically binds to
	the DLL, and the other dynamically loads it.

<pre class="d_code"><span class="d_keyword">import</span> std.stdio;
<span class="d_keyword">import</span> std.gc;

<span class="d_keyword">import</span> mydll;

<span class="d_comment">//version=DYNAMIC_LOAD;
</span>
<span class="d_keyword">version</span> (DYNAMIC_LOAD)
{
    <span class="d_keyword">import</span> std.c.windows.windows;

    <span class="d_keyword">alias</span> <span class="d_keyword">void</span> <span class="d_keyword">function</span>(<span class="d_keyword">void</span>*) MyDLL_Initialize_fp;
    <span class="d_keyword">alias</span> <span class="d_keyword">void</span> <span class="d_keyword">function</span>() MyDLL_Terminate_fp;
    <span class="d_keyword">alias</span> MyClass <span class="d_keyword">function</span>() getMyClass_fp;

    <span class="d_keyword">int</span> main()
    {	HMODULE h;
	FARPROC fp;
	MyDLL_Initialize_fp mydll_initialize;
	MyDLL_Terminate_fp  mydll_terminate;

	getMyClass_fp  getMyClass;
	MyClass c;

	printf(<span class="d_string">"Start Dynamic Link...\n"</span>);

	h = LoadLibraryA(<span class="d_string">"mydll.dll"</span>);
	<span class="d_keyword">if</span> (h == <span class="d_keyword">null</span>)
	{   printf(<span class="d_string">"error loading mydll.dll\n"</span>);
	    <span class="d_keyword">return</span> 1;
	}

	fp = GetProcAddress(h, <span class="d_string">"D5mydll16MyDLL_InitializeFPvZv"</span>);
	<span class="d_keyword">if</span> (fp == <span class="d_keyword">null</span>)
	{   printf(<span class="d_string">"error loading symbol MyDLL_Initialize()\n"</span>);
	    <span class="d_keyword">return</span> 1;
	}

	mydll_initialize = <span class="d_keyword">cast</span>(MyDLL_Initialize_fp) fp;
	(*mydll_initialize)(std.gc.getGCHandle());

	fp = GetProcAddress(h, <span class="d_string">"D5mydll10getMyClassFZC5mydll7MyClass"</span>);
	<span class="d_keyword">if</span> (fp == <span class="d_keyword">null</span>)
	{   printf(<span class="d_string">"error loading symbol getMyClass()\n"</span>);
	    <span class="d_keyword">return</span> 1;
	}

	getMyClass = <span class="d_keyword">cast</span>(getMyClass_fp) fp;
	c = (*getMyClass)();
	foo(c);

	fp = GetProcAddress(h, <span class="d_string">"D5mydll15MyDLL_TerminateFZv"</span>);
	<span class="d_keyword">if</span> (fp == <span class="d_keyword">null</span>)
	{   printf(<span class="d_string">"error loading symbol MyDLL_Terminate()\n"</span>);
	    <span class="d_keyword">return</span> 1;
	}

	mydll_terminate = <span class="d_keyword">cast</span>(MyDLL_Terminate_fp) fp;
	(*mydll_terminate)();

	<span class="d_keyword">if</span> (FreeLibrary(h) == FALSE)
	{   printf(<span class="d_string">"error freeing mydll.dll\n"</span>);
	    <span class="d_keyword">return</span> 1;
	}

	printf(<span class="d_string">"End...\n"</span>);
	<span class="d_keyword">return</span> 0;
    }
}
<span class="d_keyword">else</span>
{   <span class="d_comment">// static link the DLL
</span>
    <span class="d_keyword">int</span> main()
    {
	printf(<span class="d_string">"Start Static Link...\n"</span>);
	MyDLL_Initialize(std.gc.getGCHandle());
	foo(getMyClass());
	MyDLL_Terminate();
	printf(<span class="d_string">"End...\n"</span>);
	<span class="d_keyword">return</span> 0;
    }
}

<span class="d_keyword">void</span> foo(MyClass c)
{
    <span class="d_keyword">char</span>[] s;

    s = c.concat(<span class="d_string">"Hello"</span>, <span class="d_string">"world!"</span>);
    writefln(s);
    c.free(s);
    <span class="d_keyword">delete</span> c;
}
</pre>

	Let's start with the statically linked version, which is simpler.
	It's compiled and linked with the command:

<pre class="console">C:&gt;dmd test mydll.lib -g
</pre>

	Note how it is linked with <tt>mydll.lib</tt>, the import library
	for <tt>mydll.dll</tt>.
	The code is straightforward, it initializes <tt>mydll.lib</tt> with
	a call to <b>MyDLL_Initialize</b>(), passing the handle
	to <tt>test.exe</tt>'s gc.
	Then, we can use the DLL and call its functions just as if
	it were part of <tt>test.exe</tt>. In <b>foo</b>(), gc memory
	is allocated and freed both by <tt>test.exe</tt> and <tt>mydll.dll</tt>.
	When we're done using the DLL, it is terminated with
	<b>MyDLL_Terminate</b>().
	<p>

	Running it looks like this:

<pre class="console">C:&gt;test
DLL_PROCESS_ATTACH
Start Static Link...
MyDLL_Initialize()
static this for mydll
Hello world!
MyDLL_Terminate()
static ~this for mydll
End...
C:&gt;
</pre>

	The dynamically linked version is a little harder to set up.
	Compile and link it with the command:

<pre class="console">C:&gt;dmd test -version=DYNAMIC_LOAD -g
</pre>
	The import library <tt>mydll.lib</tt> is not needed.
	The DLL is loaded with a call to
	<a href="http://www.google.com/search?q=cache:Nkwc1opZG2cJ:msdn.microsoft.com/library/en-us/dllproc/base/loadlibrary.asp+loadlibrary&amp;hl=en"><b>LoadLibraryA</b>()</a>,
	and each exported function has to be retrieved via
	a call to
	<a href="http://www.google.com/search?q=cache:dfHVtxR8jnoJ:msdn.microsoft.com/library/en-us/dllproc/base/getprocaddress.asp+getprocaddress&amp;hl=en"><b>GetProcAddress</b>()</a>.
	An easy way to get the decorated name to pass to <b>GetProcAddress</b>()
	is to copy and paste it from the generated <tt>mydll.map</tt> file
	under the <b>Export</b> heading.
	Once this is done, we can use the member functions of the
	DLL classes as if they were part of <tt>test.exe</tt>.
	When done, release the DLL with
	<a href="http://www.google.com/search?q=cache:c5-9u71OxqAJ:msdn.microsoft.com/library/en-us/dllproc/base/freelibrary.asp+freelibrary&amp;hl=en"><b>FreeLibrary</b>()</a>.
	<p>

	Running it looks like this:
<pre class="console">C:&gt;test
Start Dynamic Link...
DLL_PROCESS_ATTACH
MyDLL_Initialize()
static this for mydll
Hello world!
MyDLL_Terminate()
static ~this for mydll
DLL_PROCESS_DETACH
End...
C:&gt;
</pre>


  
<br><br>
<br><br>
<!-- Google ad -->
<script type="text/javascript"><!--
/**/google_ad_client = "pub-5628673096434613";
/**/google_ad_width = 728;
/**/google_ad_height = 90;
/**/google_ad_format = "728x90_as";
/**/google_ad_channel ="3651639259";
/**/google_page_url = document.location;
//--></script>
<script type="text/javascript" src="../../../../../../../../pagead2.googlesyndication.com/pagead/show_ads.js">
</script>

</div>





<div id="copyright">
Copyright &copy; 1999-2006 by Digital Mars, All Rights Reserved |
Page generated by <a href="http://www.digitalmars.com/d/ddoc.html">Ddoc</a>. |
<a href="http://www.prowiki.org/wiki4d/wiki.cgi?DocComments/DLLs" title="Read/write comments and feedback">Comments</a>
</div>

</body>

<!-- Mirrored from www.shorthike.com/trac/browser/trunk/tools_win32/dmd/html/d/dll.html?format=raw by HTTrack Website Copier/3.x [XR&CO'2010], Sat, 01 May 2010 04:37:18 GMT -->
<!-- Added by HTTrack --><meta http-equiv="content-type" content="text/html;charset=UTF-8"><!-- /Added by HTTrack -->
</html>

