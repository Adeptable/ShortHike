
<!DOCTYPE html PUBLIC "-//W3C//DTD HTML 4.01//EN" "http://www.w3.org/TR/html4/strict.dtd">
<html>

<!--
	Copyright (c) 1999-2006 by Digital Mars
	All Rights Reserved
	Written by Walter Bright
	www.digitalmars.com
  -->


<!-- Mirrored from www.shorthike.com/trac/browser/trunk/tools_win32/dmd/html/d/exception-safe.html?format=raw by HTTrack Website Copier/3.x [XR&CO'2010], Sat, 01 May 2010 04:37:18 GMT -->
<!-- Added by HTTrack --><meta http-equiv="content-type" content="text/html;charset=UTF-8"><!-- /Added by HTTrack -->
<head>
<meta http-equiv="content-type" content="text/html; charset=utf-8" />
<meta name="keywords" content="D programming language" />
<meta name="description" content="D Programming Language" />
<title>D Programming Language - Exception Safety</title>
<link rel="stylesheet" type="text/css" href="style.html" />
<link rel="shortcut icon" href="favicon.html" />
</head>

<body>
<div id="heading">
	<a href="http://www.digitalmars.com/"><img src="dmlogo.html" width="270" height="53" style="border-style:none" alt="www.digitalmars.com"></a>

	<div id="headingNav">
	<ul>	<li><a href="http://www.prowiki.org/wiki4d/wiki.cgi?DocComments/ExceptionSafe" title="Read/write comments and feedback">Comments</a></li>
	<li><a href="index.html" title="D Programming Language" class="dlink">D</a></li>
	<li><a href="http://www.digitalmars.com/advancedsearch.html" title="Search Digital Mars web site">Search</a></li>
	<li><a href="download.html" title="download D">Downloads</a></li>
	<li><a href="http://www.digitalmars.com/" title="www.digitalmars.com">Home</a></li>
	</ul>
	</div>

	<div id="lastupdate">Last update Tue Jun 13 16:04:03 2006
</div>
</div>

<!-- Generated by Ddoc from exception-safe.d -->



<div id="navigation">
  
<div class="navblock">
<form method="get" action="http://www.google.com/search">
<div id="searchbox">
<input id="q" name="q" size="10" value="Search" onFocus='if(this.value == "Search"){this.value="";}'>
<input type="hidden" id="domains" name="domains" value="www.digitalmars.com">
<input type="hidden" id="sitesearch" name="sitesearch" value="www.digitalmars.com/d">
<input type="hidden" id="sourceid" name="sourceid" value="google-search">
<input type="submit" id="submit" name="submit" value="Go">
</div>
</form>
<div id="toctop">
    <ul>	<li><a href="index.html" title="D Programming Language">D ...</a></li>
	<li><a href="lex.html" title="D Language Specification">Language ...</a></li>
	<li><a href="phobos/phobos.html" title="D Runtime Library">Phobos ...</a></li>
	<li><a href="comparison.html" title="Language Comparisons">Comparisons ...</a></li>
    </ul>
</div>
</div>

  
    <div class="navblock">
	<ul>		<li><a href="overview.html">Overview</a></li>

		<li><a href="windows.html">D for Win32</a></li>

		<li><a href="dll.html">Win32 DLLs in D</a></li>

		<li><a href="htomodule.html">C .h to D Modules</a></li>

		<li><a href="faq.html">FAQ</a></li>

		<li><a href="dstyle.html">Style Guide</a></li>

		<li><a href="wc.html">Example: wc</a></li>

		<li><a href="future.html">Future</a></li>

		<li><a href="changelog.html">D Change Log</a></li>

		<li><a href="http://www.digitalmars.com/techtips/index.html">Tech Tips</a></li>

		<li><a href="rationale.html">Rationale</a></li>

		<li><a href="warnings.html">Warnings</a></li>

	</ul>
    </div>

    <div class="navblock">
	<h2>Articles</h2>
	<ul>		<li><a href="memory.html">Memory Management</a></li>

		<li><a href="exception-safe.html">Exception Safety</a></li>

		<li><a href="templates-revisited.html">Templates Revisited</a></li>

		<li><a href="regular-expression.html">Regular Expressions</a></li>

	</ul>
    </div>

    <div class="navblock">
	<h2>Tools</h2>
	<ul>		<li><a href="dcompiler.html">DMD D Compiler</a></li>

		<li><a href="http://dgcc.sourceforge.net/">GDC D Compiler</a></li>

		<li><a href="http://www.digitalmars.com/ctg/optlink.html">Linker</a></li>

		<li><a href="http://www.digitalmars.com/ctg/trace.html">Profiler</a></li>

		<li><a href="code_coverage.html">Code Coverage</a></li>

		<li><a href="rdmd.html">DMD Script Shell</a></li>

		<li><a href="windbg.html">Windows Debugger</a></li>

		<li><a href="htod.html">C .h to D .d</a></li>

		<li><a href="http://www.prowiki.org/wiki4d/wiki.cgi?EditorSupport">Editors</a></li>

		<li><a href="http://www.prowiki.org/wiki4d/wiki.cgi?ReferenceForTools">More Tools</a></li>

	</ul>
    </div>

    <div class="navblock">
	<h2>Community</h2>
	<ul>		
		<li><a href="http://www.digitalmars.com/NewsGroup.html">News</a></li>

		<li><a href="http://www.digitalmars.com/drn-bin/wwwnews?digitalmars.D">Forum</a></li>

		<li><a href="http://www.digitalmars.com/drn-bin/wwwnews?digitalmars.D.announce">Announcements</a></li>

		<li><a href="http://www.digitalmars.com/drn-bin/wwwnews?digitalmars.D.learn">Learn</a></li>

		<li><a href="dlinks.html">D links</a></li>

	</ul>
    </div>

    <div class="navblock">
	<h2>Archives</h2>
	<ul>		<li><a href="http://www.digitalmars.com/d/archives/digitalmars/D/index.html">digitalmars.D</a></li>

		<li><a href="http://www.digitalmars.com/d/archives/digitalmars/D/dtl/index.html">digitalmars.D.dtl</a></li>

		<li><a href="http://www.digitalmars.com/d/archives/digitalmars/D/announce/index.html">digitalmars.D.announce</a></li>

		<li><a href="http://www.digitalmars.com/d/archives/digitalmars/D/dwt/index.html">digitalmars.D.dwt</a></li>

		<li><a href="http://www.digitalmars.com/d/archives/digitalmars/D/learn/index.html">digitalmars.D.learn</a></li>

		<li><a href="http://www.digitalmars.com/d/archives/digitalmars/D/bugs/index.html">digitalmars.D.bugs</a></li>

		<li><a href="http://www.digitalmars.com/d/archives/D/gnu/index.html">D.gnu</a></li>

		<li><a href="http://www.digitalmars.com/d/archives/index.html">Old D</a></li>

	</ul>
    </div>

    <div class="navblock">
	<h2>Appendices</h2>
	<ul>		<li><a href="glossary.html">Glossary</a></li>

		<li><a href="ascii-table.html">Ascii Table</a></li>

		<li><a href="acknowledgements.html">Acknowledgements</a></li>

	</ul>
    </div>


</div>
<div id="content">
  <h1>        Exception Safe Programming</h1>
  
Exception safe programming is programming so that if any piece of
code that might throw an exception does throw an exception, the
the state of the program is not corrupted and resources are not leaked.
Getting this right using traditional methods often results in complex,
unappealing and brittle code. As a result, exception safety often
is either buggy or simply ignored for
the sake of expediency.


<h3>Example</h3>

For example, if there's a Mutex m that must be acquired and held
for a few statements, then released:

<pre class="d_code"><span class="d_keyword">void</span> abc()
{
    Mutex m = <span class="d_keyword">new</span> Mutex;
    lock(m);	<span class="d_comment">// lock the mutex
</span>    foo();	<span class="d_comment">// do processing
</span>    unlock(m);	<span class="d_comment">// unlock the mutex
</span>}
</pre>

<p>If foo() throws an exception, then abc() exits via exception unwinding,
unlock(m) is never called and the Mutex is not released. This is a fatal
problem with this code.
</p>

<p>The RAII (Resource Acquisition Is Initialization) idiom
and the try-finally statement form the backbone of
the traditional approaches to writing exception safe programming.
</p>

<p>RAII is scoped destruction, and the example can be fixed by providing
a Lock class with a destructor that gets called upon the exit of the scope:
</p>

<pre class="d_code"><span class="d_keyword">class</span> Lock
{
    Mutex m;

    <span class="d_keyword">this</span>(Mutex m)
    {
	<span class="d_keyword">this</span>.m = m;
	lock(m);
    }

    ~<span class="d_keyword">this</span>()
    {
	unlock(m);
    }
}

<span class="d_keyword">void</span> abc()
{
    Mutex m = <span class="d_keyword">new</span> Mutex;
    <span class="d_keyword">auto</span> Lock L = <span class="d_keyword">new</span> Lock(m);
    foo();	<span class="d_comment">// do processing
</span>}
</pre>

If abc() is exited normally or via an exception thrown from foo(), L gets
its destructor called and the mutex is unlocked.
The try-finally solution to the same problem looks like:

<pre class="d_code"><span class="d_keyword">void</span> abc()
{
    Mutex m = <span class="d_keyword">new</span> Mutex;
    lock(m);	<span class="d_comment">// lock the mutex
</span>    <span class="d_keyword">try</span>
    {
	foo();	<span class="d_comment">// do processing
</span>    }
    <span class="d_keyword">finally</span>
    {
	unlock(m);	<span class="d_comment">// unlock the mutex
</span>    }
}
</pre>

<p>Both solutions work, but both have drawbacks.
The RAII solution often requires
the creation of an extra dummy class, which is both a lot of lines of code to
write and a lot of clutter obscuring the control flow logic.
This is worthwhile to manage resources that must be cleaned up and that appear
more than once in a program, but it is clutter when it only needs to be
done once.
The try-finally
solution separates the unwinding code from the setup, and it can often be
a visually large separation. Closely related code should be grouped together.
</p>

<p>The <a href="statement.html#scope">scope exit</a> statement is an easier
approach:
</p>

<pre class="d_code"><span class="d_keyword">void</span> abc()
{
    Mutex m = <span class="d_keyword">new</span> Mutex;

    lock(m);	<span class="d_comment">// lock the mutex
</span>    <span class="d_keyword">scope</span>(exit) unlock(m);	<span class="d_comment">// unlock on leaving the scope
</span>
    foo();	<span class="d_comment">// do processing
</span>}
</pre>

The <span class="d_keyword">scope</span>(exit) statement is executed at the closing curly
brace upon
normal execution, or when the scope is left due to an exception having
been thrown.
It places the unwinding code where it aesthetically belongs, next to the
creation of the state that needs unwinding. It's far less code to write
than either the RAII or try-finally solutions, and doesn't require the
creation of dummy classes.

<h3>Example</h3>

The next example is in a class of problems known as transaction processing:

<pre class="d_code">Transaction abc()
{
    Foo f;
    Bar b;

    f = dofoo();
    b = dobar();

    <span class="d_keyword">return</span> Transaction(f, b);
}
</pre>

<p>Both dofoo() and dobar() must succeed, or the transaction has failed.
If the transaction failed, the data must be restored to the state
where neither dofoo() nor dobar() have happened. To support that,
dofoo() has an unwind operation, dofoo_undo(Foo f) which will roll back
the creation of a Foo.
</p>

<p>With the RAII approach:
</p>

<pre class="d_code"><span class="d_keyword">class</span> FooX
{
    Foo f;
    <span class="d_keyword">bool</span> commit;

    <span class="d_keyword">this</span>()
    {
	f = dofoo();
    }

    ~<span class="d_keyword">this</span>()
    {
	<span class="d_keyword">if</span> (!commit)
	    dofoo_undo(f);
    }
}

Transaction abc()
{
    <span class="d_keyword">auto</span> FooX f = <span class="d_keyword">new</span> FooX();
    Bar b = dobar();
    f.commit = <span class="d_keyword">true</span>;
    <span class="d_keyword">return</span> Transaction(f.f, b);
}
</pre>

With the try-finally approach:

<pre class="d_code">Transaction abc()
{
    Foo f;
    Bar b;

    f = dofoo();
    <span class="d_keyword">try</span>
    {
	b = dobar();
	<span class="d_keyword">return</span> Transaction(f, b);
    }
    <span class="d_keyword">catch</span> (Object o)
    {
	dofoo_undo(f);
	<span class="d_keyword">throw</span> o;
    }
}
</pre>

<p>These work too, but have the same problems.
The RAII approach involves the creation of dummy classes, and the obtuseness
of moving some of the logic out of the abc() function.
The try-finally approach is wordy even with this simple example, try
writing it if there are more than two components of the transaction that
must succeed. It scales poorly.
</p>

<p>The <span class="d_keyword">scope</span>(failure) statement solution looks like:
</p>

<pre class="d_code">Transaction abc()
{
    Foo f;
    Bar b;

    f = dofoo();
    <span class="d_keyword">scope</span>(failure) dofoo_undo(f);

    b = dobar();

    <span class="d_keyword">return</span> Transaction(f, b);
}
</pre>

The dofoo_undo(f) only is executed if the scope is exited via an
exception. The unwinding code is minimal and kept aesthetically where
it belongs. It scales up in a natural way to more complex transactions:


<pre class="d_code">Transaction abc()
{
    Foo f;
    Bar b;
    Def d;

    f = dofoo();
    <span class="d_keyword">scope</span>(failure) dofoo_undo(f);

    b = dobar();
    <span class="d_keyword">scope</span>(failure) dobar_unwind(b);

    d = dodef();

    <span class="d_keyword">return</span> Transaction(f, b, d);
}
</pre>

<h3>Example</h3>

The next example involves temporarily changing the state of some object.
Suppose there's a class data member <tt>verbose</tt>, which controls the
emission of messages logging the activity of the class.
Inside one of the methods, <tt>verbose</tt> needs to be turned off because
there's a loop that would otherwise cause a blizzard of messages to be output:

<pre class="d_code"><span class="d_keyword">class</span> Foo
{
    <span class="d_keyword">bool</span> verbose;	<span class="d_comment">// true means print messages, false means silence
</span>    ...
    bar()
    {
	<span class="d_keyword">auto</span> verbose_save = verbose;
	verbose = <span class="d_keyword">false</span>;
	... lots of code ...
	verbose = verbose_save;
    }
}
</pre>

There's a problem if <tt>Foo.bar()</tt> exits via an exception - the verbose
flag state is not restored.
That's easily fixed with <span class="d_keyword">scope</span>(exit):

<pre class="d_code"><span class="d_keyword">class</span> Foo
{
    <span class="d_keyword">bool</span> verbose;	<span class="d_comment">// true means print messages, false means silence
</span>    ...
    bar()
    {
	<span class="d_keyword">auto</span> verbose_save = verbose;
	verbose = <span class="d_keyword">false</span>;
	<span class="d_keyword">scope</span>(exit) verbose = verbose_save;

	...lots of code...
    }
}
</pre>

<p>It also neatly solves the problem if <tt>...lots of code...</tt> goes on at
some length, and in the future a maintenance programmer inserts a
return statement in it, not realizing that verbose must be reset upon
exit. The reset code is where it belongs conceptually, rather than where
it gets executed
(an analogous case is the continuation expression in a <i>ForStatement</i>).
It works whether the scope is exited by a return, break, goto, continue,
or exception.
</p>

<p>The RAII solution would be to try and capture the false state of verbose
as a resource, an abstraction that doesn't make much sense.
The try-finally solution requires arbitrarily large separation between
the conceptually linked set and reset code, besides requiring
the addition of an irrelevant scope.
</p>

<h3>Example</h3>

Here's another example of a multi-step transaction,
this time for an email program.
Sending an email consists of two operations:

<ol><li>Perform the SMTP send operation.</li>
<li>Copy the email to the "Sent" folder, which in POP is on the local 
disk, and in IMAP is also remote.</li>
</ol>

<p>Messages should not appear in "Sent" that haven't been actually sent,
and sent messages must actually appear in "Sent".
</p>

<p>Operation (1) is not undoable because it's a well-known distributed 
computing issue. Operation (2) is undoable with some degree of 
reliability. So we break the job down into three steps:
</p>

<ol><li>Copy the message to "Sent" with a changed title "[Sending] 
&lt;Subject&gt;". This operation ensures there's space in the client's IMAP 
account (or on the local disk), the rights are proper, the connection 
exists and works, etc.</li>

<li>Send the message via SMTP.</li>

<li>If sending fails, delete the message from "Sent". If the message 
succeeds,
change its title from "[Sending] &lt;Subject&gt;" to "&lt;Subject&gt;". 
Both of these operation have a high probability to succeed. If the 
folder is local, the probability of success is very high. If the folder 
is remote, probability is still vastly higher than that of step (1) 
because it doesn't involve an arbitrarily large data transfer.</li>

</ol>

<pre class="d_code"><span class="d_keyword">class</span> Mailer
{
    <span class="d_keyword">void</span> Send(Message msg)
    {
	{
	    <span class="d_keyword">char</span>[] origTitle = msg.Title();
	    <span class="d_keyword">scope</span>(exit) msg.SetTitle(origTitle);
	    msg.SetTitle(<span class="d_string">"[Sending] "</span> ~ origTitle);
	    Copy(msg, <span class="d_string">"Sent"</span>);
	}
	<span class="d_keyword">scope</span>(success) SetTitle(msg.ID(), <span class="d_string">"Sent"</span>, msg.Title);
	<span class="d_keyword">scope</span>(failure) Remove(msg.ID(), <span class="d_string">"Sent"</span>);
	SmtpSend(msg);	<span class="d_comment">// do the least reliable part last
</span>    }
}
</pre>

This is a compelling solution to a complex problem.
Rewriting it with RAII would require two extra silly classes, 
MessageTitleSaver and MessageRemover.
Rewriting the example with try-finally would require nested try-finally
statements or use an extra variable to track state evolution.

<h3>Example</h3>

Consider giving feedback to the user about a lengthy 
operation (mouse changes to an hourglass, window title is 
red/italicized, ...).
With <span class="d_keyword">scope</span>(exit) that can be easily done without 
needing to make an artificial resource out of whatever UI state element 
used for the cues:

<pre class="d_code"><span class="d_keyword">void</span> LongFunction()
{
    State save = UIElement.GetState();
    <span class="d_keyword">scope</span>(exit) UIElement.SetState(save);
    ...lots of code...
}
</pre>

Even more so, <span class="d_keyword">scope</span>(success) and <span class="d_keyword">scope</span>(failure)
can be used to give an indication if the operation succeeded or if
an error occurred:

<pre class="d_code"><span class="d_keyword">void</span> LongFunction()
{
    State save = UIElement.GetState();
    <span class="d_keyword">scope</span>(success) UIElement.SetState(save);
    <span class="d_keyword">scope</span>(failure) UIElement.SetState(Failed(save));
    ...lots of code...
}
</pre>

<h2>When to use RAII, try-catch-finally, and Scope</h2>

RAII is for managing resources, which is different from managing state 
or transactions. try-catch is still needed, as on_scope doesn't catch 
exceptions. It's try-finally that becomes redundant.

<h2>Acknowledgements</h2>

I am indebted to Andrei Alexandrescu for his invaluable assistance
with these ideas and text, and to Scott Meyers for teaching
me about exception safe programming.

<h2>References:</h2>

<ol>
<li><a href="http://www.cuj.com/documents/s=8000/cujcexp1812alexandr/alexandr.htm">
Generic&lt;Programming&gt;: Change the Way You Write Exception-Safe Code Forever</a>
by Andrei Alexandrescu and Petru Marginean

</li>

<li>"Item 29: Strive for exception-safe code" in
<a href="http://www.amazon.com/exec/obidos/ASIN/0321334876/classicempire">
 Effective C++ Third Edition</a>, pg. 127 by Scott Meyers

</li>

</ol>


  
<br><br>
<br><br>
<!-- Google ad -->
<script type="text/javascript"><!--
/**/google_ad_client = "pub-5628673096434613";
/**/google_ad_width = 728;
/**/google_ad_height = 90;
/**/google_ad_format = "728x90_as";
/**/google_ad_channel ="3651639259";
/**/google_page_url = document.location;
//--></script>
<script type="text/javascript" src="../../../../../../../../pagead2.googlesyndication.com/pagead/show_ads.js">
</script>

</div>





<div id="copyright">
Copyright &copy; 1999-2006 by Digital Mars, All Rights Reserved |
Page generated by <a href="http://www.digitalmars.com/d/ddoc.html">Ddoc</a>. |
<a href="http://www.prowiki.org/wiki4d/wiki.cgi?DocComments/ExceptionSafe" title="Read/write comments and feedback">Comments</a>
</div>

</body>

<!-- Mirrored from www.shorthike.com/trac/browser/trunk/tools_win32/dmd/html/d/exception-safe.html?format=raw by HTTrack Website Copier/3.x [XR&CO'2010], Sat, 01 May 2010 04:37:18 GMT -->
<!-- Added by HTTrack --><meta http-equiv="content-type" content="text/html;charset=UTF-8"><!-- /Added by HTTrack -->
</html>

