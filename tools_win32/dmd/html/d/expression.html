
<!DOCTYPE html PUBLIC "-//W3C//DTD HTML 4.01//EN" "http://www.w3.org/TR/html4/strict.dtd">
<html>

<!--
	Copyright (c) 1999-2006 by Digital Mars
	All Rights Reserved
	Written by Walter Bright
	www.digitalmars.com
  -->


<!-- Mirrored from www.shorthike.com/trac/browser/trunk/tools_win32/dmd/html/d/expression.html?format=raw by HTTrack Website Copier/3.x [XR&CO'2010], Sat, 01 May 2010 04:37:18 GMT -->
<!-- Added by HTTrack --><meta http-equiv="content-type" content="text/html;charset=UTF-8"><!-- /Added by HTTrack -->
<head>
<meta http-equiv="content-type" content="text/html; charset=utf-8" />
<meta name="keywords" content="D programming language" />
<meta name="description" content="D Programming Language" />
<title>D Programming Language - Expressions</title>
<link rel="stylesheet" type="text/css" href="style.html" />
<link rel="shortcut icon" href="favicon.html" />
</head>

<body>
<div id="heading">
	<a href="http://www.digitalmars.com/"><img src="dmlogo.html" width="270" height="53" style="border-style:none" alt="www.digitalmars.com"></a>

	<div id="headingNav">
	<ul>	<li><a href="http://www.prowiki.org/wiki4d/wiki.cgi?DocComments/Expression" title="Read/write comments and feedback">Comments</a></li>
	<li><a href="index.html" title="D Programming Language" class="dlink">D</a></li>
	<li><a href="http://www.digitalmars.com/advancedsearch.html" title="Search Digital Mars web site">Search</a></li>
	<li><a href="download.html" title="download D">Downloads</a></li>
	<li><a href="http://www.digitalmars.com/" title="www.digitalmars.com">Home</a></li>
	</ul>
	</div>

	<div id="lastupdate">Last update Mon Jun 19 11:50:11 2006
</div>
</div>

<!-- Generated by Ddoc from expression.d -->



<div id="navigation">
  
<div class="navblock">
<form method="get" action="http://www.google.com/search">
<div id="searchbox">
<input id="q" name="q" size="10" value="Search" onFocus='if(this.value == "Search"){this.value="";}'>
<input type="hidden" id="domains" name="domains" value="www.digitalmars.com">
<input type="hidden" id="sitesearch" name="sitesearch" value="www.digitalmars.com/d">
<input type="hidden" id="sourceid" name="sourceid" value="google-search">
<input type="submit" id="submit" name="submit" value="Go">
</div>
</form>
<div id="toctop">
    <ul>	<li><a href="index.html" title="D Programming Language">D ...</a></li>
	<li><a href="lex.html" title="D Language Specification">Language ...</a></li>
	<li><a href="phobos/phobos.html" title="D Runtime Library">Phobos ...</a></li>
	<li><a href="comparison.html" title="Language Comparisons">Comparisons ...</a></li>
    </ul>
</div>
</div>

  
    <div class="navblock">
    <ul>	<li><a href="lex.html">Lexical</a></li>

	<li><a href="module.html">Modules</a></li>

	<li><a href="declaration.html">Declarations</a></li>

	<li><a href="type.html">Types</a></li>

	<li><a href="property.html">Properties</a></li>

	<li><a href="attribute.html">Attributes</a></li>

	<li><a href="pragma.html">Pragmas</a></li>

	<li><a href="expression.html">Expressions</a></li>

	<li><a href="statement.html">Statements</a></li>

	<li><a href="arrays.html">Arrays</a></li>

	<li><a href="struct.html">Structs &amp; Unions</a></li>

	<li><a href="class.html">Classes</a></li>

	<li><a href="interface.html">Interfaces</a></li>

	<li><a href="enum.html">Enums</a></li>

	<li><a href="function.html">Functions</a></li>

	<li><a href="operatoroverloading.html">Operator Overloading</a></li>

	<li><a href="template.html">Templates</a></li>

	<li><a href="mixin.html">Mixins</a></li>

	<li><a href="dbc.html">Contracts</a></li>

	<li><a href="version.html">Conditional Compilation</a></li>

	<li><a href="errors.html">Handling errors</a></li>

	<li><a href="garbage.html">Garbage Collection</a></li>

	<li><a href="float.html">Floating Point</a></li>

	<li><a href="iasm.html">Inline Assembler</a></li>

	<li><a href="ddoc.html">Documentation Comments</a></li>

	<li><a href="interfaceToC.html">Interfacing To C</a></li>

	<li><a href="portability.html">Portability Guide</a></li>

	<li><a href="html.html">Embedding D in HTML</a></li>

	<li><a href="entity.html">Named Character Entities</a></li>

	<li><a href="abi.html">Application Binary Interface</a></li>

    </ul>
    </div>

</div>
<div id="content">
  <h1>     Expressions</h1>
  
	C and C++ programmers will find the D expressions very familiar,
	with a few interesting additions.
	<p>

	Expressions are used to compute values with a resulting type.
	These values can then be assigned,
	tested, or ignored. Expressions can also have side effects.

<pre class="bnf"><a href="#Expression"><i>Expression</i></a>:
	<i>AssignExpression</i>
	<i>AssignExpression</i> <b>,</b> <i>Expression</i>

<a href="#AssignExpression"><i>AssignExpression</i></a>:
	<i>ConditionalExpression</i>
	<i>ConditionalExpression</i> <b>=</b> <i>AssignExpression</i>
	<i>ConditionalExpression</i> <b>+=</b> <i>AssignExpression</i>
	<i>ConditionalExpression</i> <b>-=</b> <i>AssignExpression</i>
	<i>ConditionalExpression</i> <b>*=</b> <i>AssignExpression</i>
	<i>ConditionalExpression</i> <b>/=</b> <i>AssignExpression</i>
	<i>ConditionalExpression</i> <b>%=</b> <i>AssignExpression</i>
	<i>ConditionalExpression</i> <b>&amp;=</b> <i>AssignExpression</i>
	<i>ConditionalExpression</i> <b>|=</b> <i>AssignExpression</i>
	<i>ConditionalExpression</i> <b>^=</b> <i>AssignExpression</i>
	<i>ConditionalExpression</i> <b>~=</b> <i>AssignExpression</i>
	<i>ConditionalExpression</i> <b>&lt;&lt;=</b> <i>AssignExpression</i>
	<i>ConditionalExpression</i> <b>&gt;&gt;=</b> <i>AssignExpression</i>
	<i>ConditionalExpression</i> <b>&gt;&gt;&gt;=</b> <i>AssignExpression</i>

<a href="#ConditionalExpression"><i>ConditionalExpression</i></a>:
	<i>OrOrExpression</i>
	<i>OrOrExpression</i> <b>?</b> <i>Expression</i> <b>:</b> <i>ConditionalExpression</i>

<a href="#OrOrExpression"><i>OrOrExpression</i></a>:
	<i>AndAndExpression</i>
	<i>OrOrExpression</i> <b>||</b> <i>AndAndExpression</i>

<a href="#AndAndExpression"><i>AndAndExpression</i></a>:
	<i>OrExpression</i>
	<i>AndAndExpression</i> <b>&amp;&amp;</b> <i>OrExpression</i>

<a href="#OrExpression"><i>OrExpression</i></a>:
	<i>XorExpression</i>
	<i>OrExpression</i> <b>|</b> <i>XorExpression</i>

<a href="#XorExpression"><i>XorExpression</i></a>:
	<i>AndExpression</i>
	<i>XorExpression</i> <b>^</b> <i>AndExpression</i>

<a href="#AndExpression"><i>AndExpression</i></a>:
	<i>EqualExpression</i>
	<i>AndExpression</i> <b>&amp;</b> <i>EqualExpression</i>

<a href="#EqualExpression"><i>EqualExpression</i></a>:
	<i>RelExpression</i>
	<i>EqualExpression</i> <b>==</b> <i>RelExpression</i>
	<i>EqualExpression</i> <b>!=</b> <i>RelExpression</i>
	<i>EqualExpression</i> <b>is</b> <i>RelExpression</i>
	<i>EqualExpression</i> <b>!is</b> <i>RelExpression</i>

<a href="#RelExpression"><i>RelExpression</i></a>:
	<i>ShiftExpression</i>
	<i>InExpression</i>
	<i>RelExpression</i> <b>&lt;</b> <i>ShiftExpression</i>
	<i>RelExpression</i> <b>&lt;=</b> <i>ShiftExpression</i>
	<i>RelExpression</i> <b>&gt;</b> <i>ShiftExpression</i>
	<i>RelExpression</i> <b>&gt;=</b> <i>ShiftExpression</i>
	<i>RelExpression</i> <b>!&lt;&gt;=</b> <i>ShiftExpression</i>
	<i>RelExpression</i> <b>!&lt;&gt;</b> <i>ShiftExpression</i>
	<i>RelExpression</i> <b>&lt;&gt;</b> <i>ShiftExpression</i>
	<i>RelExpression</i> <b>&lt;&gt;=</b> <i>ShiftExpression</i>
	<i>RelExpression</i> <b>!&gt;</b> <i>ShiftExpression</i>
	<i>RelExpression</i> <b>!&gt;=</b> <i>ShiftExpression</i>
	<i>RelExpression</i> <b>!&lt;</b> <i>ShiftExpression</i>
	<i>RelExpression</i> <b>!&lt;=</b> <i>ShiftExpression</i>

<a href="#InExpression"><i>InExpression</i></a>:
	<i>RelExpression</i> <b>in</b> <i>ShiftExpression</i>

<a href="#ShiftExpression"><i>ShiftExpression</i></a>:
	<i>AddExpression</i>
	<i>ShiftExpression</i> <b>&lt;&lt;</b> <i>AddExpression</i>
	<i>ShiftExpression</i> <b>&gt;&gt;</b> <i>AddExpression</i>
	<i>ShiftExpression</i> <b>&gt;&gt;&gt;</b> <i>AddExpression</i>

<a href="#AddExpression"><i>AddExpression</i></a>:
	<i>MulExpression</i>
	<i>AddExpression</i> <b>+</b> <i>MulExpression</i>
	<i>AddExpression</i> <b>-</b> <i>MulExpression</i>
	<i>AddExpression</i> <b>~</b> <i>MulExpression</i>

<a href="#MulExpression"><i>MulExpression</i></a>:
	<i>UnaryExpression</i>
	<i>MulExpression</i> <b>*</b> <i>UnaryExpression</i>
	<i>MulExpression</i> <b>/</b> <i>UnaryExpression</i>
	<i>MulExpression</i> <b>%</b> <i>UnaryExpression</i>

<a href="#UnaryExpression"><i>UnaryExpression</i></a>:
	<i>PostfixExpression</i>
	<b>&amp;</b> <i>UnaryExpression</i>
	<b>++</b> <i>UnaryExpression</i>
	<b>--</b> <i>UnaryExpression</i>
	<b>*</b> <i>UnaryExpression</i>
	<b>-</b> <i>UnaryExpression</i>
	<b>+</b> <i>UnaryExpression</i>
	<b>!</b> <i>UnaryExpression</i>
	<b>~</b> <i>UnaryExpression</i>
	<a href="#DeleteExpression"><b>delete</b> <i>UnaryExpression</i></a>
	<i>NewExpression</i>
	<i>CastExpression</i>
	<a href="class.html#anonymous"><i>NewAnonClassExpression</i></a>
	<b>(</b> <i>Type</i> <b>) .</b> <i>Identifier</i>

<a href="#CastExpression"><i>CastExpression</i></a>:
	<b>cast (</b> <i>Type</i> <b>)</b> <i>UnaryExpression</i>

<a href="#PostFixExpression"><i>PostfixExpression</i></a>:
	<i>PrimaryExpression</i>
	<i>PostfixExpression</i> <b>.</b> <i>Identifier</i>
	<i>PostfixExpression</i> <b>.</b> <i>NewExpression</i>
	<i>PostfixExpression</i> <b>++</b>
	<i>PostfixExpression</i> <b>--</b>
	<i>PostfixExpression</i> <b>( )</b>
	<i>PostfixExpression</i> <b>(</b> <i>ArgumentList</i> <b>)</b>
	<i>IndexExpression</i>
	<i>SliceExpression</i>

<a href="#IndexExpression"><i>IndexExpression</i></a>:
	<i>PostfixExpression</i> <b>[</b> <i>ArgumentList</i> <b>]</b>

<a href="#SliceExpression"><i>SliceExpression</i></a>:
	<i>PostfixExpression</i> <b>[ ]</b>
	<i>PostfixExpression</i> <b>[</b> <i>AssignExpression</i> <b>..</b> <i>AssignExpression</i> <b>]</b>

<a href="#PrimaryExpression"><i>PrimaryExpression</i></a>:
	<i>Identifier</i>
	<b>.</b><i>Identifier</i>
	<b>this</b>
	<b>super</b>
	<b>null</b>
	<b>true</b>
	<b>false</b>
	<i>NumericLiteral</i>
	<i>CharacterLiteral</i>
	<i>StringLiterals</i>
	<a href="#FunctionLiteral"><i>FunctionLiteral</i></a>
	<a href="#AssertExpression"><i>AssertExpression</i></a>
	<i>BasicType</i> <b>.</b> <i>Identifier</i>
	<b>typeid (</b> <i>Type</i> <b>)</b>
	<a href="#IsExpression"><i>IsExpression</i></a>
	<b>(</b> <i>Expression</i> <b>)</b>

<i>StringLiterals</i>:
	<i>StringLiteral</i>
	<i>StringLiterals</i> <i>StringLiteral</i>

<a href="#AssertExpression"><i>AssertExpression</i></a>:
	<b>assert (</b> <i>Expression</i> <b>)</b>
	<b>assert (</b> <i>Expression</i> <b>,</b> <i>Expression</i> <b>)</b>

<i>ArgumentList</i>:
	<i>AssignExpression</i>
	<i>AssignExpression</i> <b>,</b> <i>ArgumentList</i>

<a href="#NewExpression"><i>NewExpression</i></a>:
	<i>NewArguments</i> <i>Type</i> <b>[</b> <i>AssignExpression</i> <b>]</b>
	<i>NewArguments</i> <i>Type</i> <b>(</b> <i>ArgumentList</i> <b>)</b>
	<i>NewArguments</i> <i>Type</i>
	<i>NewArguments</i> <i>ClassArguments</i> <i>BaseClasslist</i><sub>opt</sub> <b>{</b> <i>DeclDefs</i> <b>} </b>

<i>NewArguments</i>:
	<b>new (</b> <i>ArgumentList</i> <b>)</b>
	<b>new ( )</b>
	<b>new</b>

<i>ClassArguments</i>:
	<b>class (</b> <i>ArgumentList</i> <b>)</b>
	<b>class ( )</b>
	<b>class</b>
</pre>

<h2>Evaluation Order</h2>

	Unless otherwise specified, the implementation is free to evaluate
	the components of an expression in any order. It is an error
	to depend on order of evaluation when it is not specified.
	For example, the following are illegal:
<pre class="d_code">i = ++i;
c = a + (a = b);
func(++i, ++i);
</pre>
	If the compiler can determine that the result of an expression
	is illegally dependent on the order of evaluation, it can issue
	an error (but is not required to). The ability to detect these kinds
	of errors is a quality of implementation issue.

<h2><a name="Expression">Expressions</a></h2>

<pre class="bnf"><i>AssignExpression</i> <b>,</b> <i>Expression</i>
</pre>

	The left operand of the <b>,</b> is evaluated, then the right operand
	is evaluated. The type of the expression is the type of the right
	operand, and the result is the result of the right operand.
	

<h2><a name="AssignExpression">Assign Expressions</a></h2>

<pre class="bnf"><i>ConditionalExpression</i> <b>=</b> <i>AssignExpression</i>
</pre>

	The right operand is implicitly converted to the type of the
	left operand, and assigned to it. The result type is the type
	of the lvalue, and the result value is the value of the lvalue
	after the assignment.
	<p>

	The left operand must be an lvalue.

<h3>Assignment Operator Expressions</h3>

<pre class="bnf"><i>ConditionalExpression</i> <b>+=</b> <i>AssignExpression</i>
<i>ConditionalExpression</i> <b>-=</b> <i>AssignExpression</i>
<i>ConditionalExpression</i> <b>*=</b> <i>AssignExpression</i>
<i>ConditionalExpression</i> <b>/=</b> <i>AssignExpression</i>
<i>ConditionalExpression</i> <b>%=</b> <i>AssignExpression</i>
<i>ConditionalExpression</i> <b>&amp;=</b> <i>AssignExpression</i>
<i>ConditionalExpression</i> <b>|=</b> <i>AssignExpression</i>
<i>ConditionalExpression</i> <b>^=</b> <i>AssignExpression</i>
<i>ConditionalExpression</i> <b>&lt;&lt;=</b> <i>AssignExpression</i>
<i>ConditionalExpression</i> <b>&gt;&gt;=</b> <i>AssignExpression</i>
<i>ConditionalExpression</i> <b>&gt;&gt;&gt;=</b> <i>AssignExpression</i>
</pre>

	Assignment operator expressions, such as:

<pre class="d_code"><i>a op= b</i>
</pre>

	are semantically equivalent to:

<pre class="d_code"><i>a = a op b</i>
</pre>

	except that operand <i>a</i> is only evaluated once.

<h2><a name="ConditionalExpression">Conditional Expressions</a></h2>

<pre class="bnf"><i>OrOrExpression</i> <b>?</b> <i>Expression</i> <b>:</b> <i>ConditionalExpression</i>
</pre>

	The first expression is converted to bool, and is evaluated.
	If it is true, then the second expression is evaluated, and
	its result is the result of the conditional expression.
	If it is false, then the third expression is evaluated, and
	its result is the result of the conditional expression.
	If either the second or third expressions are of type void,
	then the resulting type is void. Otherwise, the second and third
	expressions are implicitly converted to a common type which becomes
	the result type of the conditional expression.

<h2><a name="OrOrExpression">OrOr Expressions</a></h2>

<pre class="bnf"><i>OrOrExpression</i> <b>||</b> <i>AndAndExpression</i>
</pre>

	The result type of an <i>OrOrExpression</i> is bool,
	unless the right operand
	has type void, when the result is type void.
	<p>

	The <i>OrOrExpression</i> evaluates its left operand.

	If the left operand, converted to type bool, evaluates to
	true, then the right operand is not evaluated. If the result type of
	the <i>OrOrExpression</i> is bool then the result of the
	expression is true.

	If the left operand is false, then the right
	operand is evaluated.
	If the result type of
	the <i>OrOrExpression</i> is bool then the result of the
	expression is the right operand converted to type bool.


<h2><a name="AndAndExpression">AndAnd Expressions</a></h2>

<pre class="bnf"><i>AndAndExpression</i> <b>&amp;&amp;</b> <i>OrExpression</i>
</pre>

	<p>The result type of an <i>AndAndExpression</i> is bool, unless the right operand
	has type void, when the result is type void.
	</p>

	<p>The <i>AndAndExpression</i> evaluates its left operand.
	</p>

	<p>If the left operand, converted to type bool, evaluates to
	false, then the right operand is not evaluated. If the result type of
	the <i>AndAndExpression</i> is bool then the result of the
	expression is false.
	</p>

	<p>If the left operand is true, then the right
	operand is evaluated.
	If the result type of
	the <i>AndAndExpression</i> is bool then the result of the
	expression is the right operand converted to type bool.
	</p>


<h2>Bitwise Expressions</h2>

	Bit wise expressions perform a bitwise operation on their operands.
	Their operands must be integral types.
	First, the default integral promotions are done. Then, the bitwise
	operation is done.

<h3><a name="OrExpression">Or Expressions</a></h3>

<pre class="bnf"><i>OrExpression</i> <b>|</b> <i>XorExpression</i>
</pre>

	The operands are OR'd together.

<h3><a name="XorExpression">Xor Expressions</a></h3>

<pre class="bnf"><i>XorExpression</i> <b>^</b> <i>AndExpression</i>
</pre>

	The operands are XOR'd together.

<h3><a name="AndExpression">And Expressions</a></h3>

<pre class="bnf"><i>AndExpression</i> <b>&amp;</b> <i>EqualExpression</i>
</pre>

	The operands are AND'd together.


<h2><a name="EqualExpression">Equality Expressions</a></h2>

<pre class="bnf"><i>EqualExpression</i> <b>==</b> <i>RelExpression</i>
<i>EqualExpression</i> <b>!=</b> <i>RelExpression</i>
</pre>

	Equality expressions compare the two operands for equality (<b>==</b>)
	or inequality (<b>!=</b>).
	The type of the result is bool. The operands
	go through the usual conversions to bring them to a common type before
	comparison.
	<p>

	If they are integral values or pointers, equality
	is defined as the bit pattern of the type matches exactly.
	Equality for struct objects means the bit patterns of the objects
	match exactly (the existence of alignment holes in the objects
	is accounted for, usually by setting them all to 0 upon
	initialization).
	Equality for floating point types is more complicated. -0 and
	+0 compare as equal. If either or both operands are NAN, then
	both the == returns false and != returns true. Otherwise, the bit
	patterns are compared for equality.
	<p>

	For complex numbers, equality is defined as equivalent to:

<pre>
x.re == y.re &amp;&amp; x.im == y.im
</pre>

	and inequality is defined as equivalent to:

<pre>
x.re != y.re || x.im != y.im
</pre>

	For class and struct objects, the expression <tt>(a == b)</tt>
	is rewritten as
	<tt>a.opEquals(b)</tt>, and <tt>(a != b)</tt> is rewritten as
	<tt>!a.opEquals(b)</tt>.
	<p>

	For static and dynamic arrays, equality is defined as the
	lengths of the arrays
	matching, and all the elements are equal.
	

<h2>Identity Expressions</h2>

<pre class="bnf"><i>EqualExpression</i> <b>is</b> <i>RelExpression</i>
<i>EqualExpression</i> <b>!is</b> <i>RelExpression</i>
</pre>

	The <b>is</b> compares for identity.
	To compare for not identity, use <tt><i>e1</i> <b>!is</b> <i>e2</i></tt>.
	The type of the result is bool. The operands
	go through the usual conversions to bring them to a common type before
	comparison.
	<p>

	For operand types other than class objects, static or dynamic arrays,
	identity is defined as being the same as equality.
	<p>

	For class objects, identity is defined as the object references
	are for the same object. Null class objects can be compared with
	<b>is</b>.
	<p>

	For static and dynamic arrays, identity is defined as referring
	to the same array elements.
	<p>

	The identity operator <b>is</b> cannot be overloaded.

<h2><a name="RelExpression">Relational Expressions</a></h2>

<pre class="bnf"><i>RelExpression</i> <b>&lt;</b> <i>ShiftExpression</i>
<i>RelExpression</i> <b>&lt;=</b> <i>ShiftExpression</i>
<i>RelExpression</i> <b>&gt;</b> <i>ShiftExpression</i>
<i>RelExpression</i> <b>&gt;=</b> <i>ShiftExpression</i>
<i>RelExpression</i> <b>!&lt;&gt;=</b> <i>ShiftExpression</i>
<i>RelExpression</i> <b>!&lt;&gt;</b> <i>ShiftExpression</i>
<i>RelExpression</i> <b>&lt;&gt;</b> <i>ShiftExpression</i>
<i>RelExpression</i> <b>&lt;&gt;=</b> <i>ShiftExpression</i>
<i>RelExpression</i> <b>!&gt;</b> <i>ShiftExpression</i>
<i>RelExpression</i> <b>!&gt;=</b> <i>ShiftExpression</i>
<i>RelExpression</i> <b>!&lt;</b> <i>ShiftExpression</i>
<i>RelExpression</i> <b>!&lt;=</b> <i>ShiftExpression</i>
</pre>

	First, the integral promotions are done on the operands.
	The result type of a relational expression is bool.
	<p>

	For class objects, the result of Object.opCmp() forms the left
	operand, and 0 forms the right operand. The result of the
	relational expression (o1 op o2) is:

<pre>
(o1.opCmp(o2) op 0)
</pre>

	It is an error to compare objects if one is <b>null</b>.
	<p>

	For static and dynamic arrays, the result of the relational
	op is the result of the operator applied to the first non-equal
	element of the array. If two arrays compare equal, but are of
	different lengths, the shorter array compares as "less" than the
	longer array.


<h3>Integer comparisons</h3>

	Integer comparisons happen when both operands are integral
	types.
	<p>

	<table align=center border=1 cellpadding=4 cellspacing=0>
	<caption>Integer comparison operators</caption>
	<tr>
	<th>Operator</th><th>Relation</th>
	</tr><tr>
	<td>&lt;</td>		<td>less</td>
	</tr><tr>
	<td>&gt;</td>		<td>greater</td>
	</tr><tr>
	<td>&lt;=</td>		<td>less or equal</td>
	</tr><tr>
	<td>&gt;=</td>		<td>greater or equal</td>
	</tr><tr>
	<td>==</td>		<td>equal</td>
	</tr><tr>
	<td>!=</td>		<td>not equal</td>
	</tr>
	</table>
	<p>

	It is an error to have one operand be signed and the other
	unsigned for a &lt;, &lt;=, &gt; or &gt;= expression.
	Use casts to make both operands signed or both operands unsigned.

<h3>Floating point comparisons</h3>

	If one or both operands are floating point, then a floating
	point comparison is performed.
	<p>

	Useful floating point operations must take into account NAN values.
	In particular, a relational operator can have NAN operands.
	The result of a relational operation on float 
	values is less, greater, equal, or unordered (unordered means
	either or both of the 
	operands is a NAN). That means there are 14 possible comparison
	conditions to test for:
	<p>

	<table align=center border=1 cellpadding=4 cellspacing=0>
	<caption>Floating point comparison operators</caption>
	<tr>
	<th>Operator
	<th>Greater Than
	<th>Less Than
	<th>Equal
	<th>Unordered
	<th>Exception
	<th>Relation

	<tr>
	<td> ==		<td> F <td> F <td> T <td> F <td> no	<td> equal

	<tr>
	<td> !=		<td> T <td> T <td> F <td> T <td> no	<td> unordered, less, or greater

	<tr>
	<td> &gt;	<td> T <td> F <td> F <td> F <td> yes	<td> greater

	<tr>
	<td> &gt;=	<td> T <td> F <td> T <td> F <td> yes	<td> greater or equal

	<tr>
	<td> &lt;	<td> F <td> T <td> F <td> F <td> yes	<td> less

	<tr>
	<td> &lt;=	<td> F <td> T <td> T <td> F <td> yes	<td> less or equal

	<tr>
	<td> !&lt;&gt;=	<td> F <td> F <td> F <td> T <td> no	<td> unordered

	<tr>
	<td> &lt;&gt;	<td> T <td> T <td> F <td> F <td> yes	<td> less or greater

	<tr>
	<td> &lt;&gt;=	<td> T <td> T <td> T <td> F <td> yes	<td> less, equal, or greater

	<tr>
	<td> !&lt;=	<td> T <td> F <td> F <td> T <td> no	<td> unordered or greater

	<tr>
	<td> !&lt;	<td> T <td> F <td> T <td> T <td> no	<td> unordered, greater, or equal

	<tr>
	<td> !&gt;=	<td> F <td> T <td> F <td> T <td> no	<td> unordered or less

	<tr>
	<td> !&gt;	<td> F <td> T <td> T <td> T <td> no	<td> unordered, less, or equal

	<tr>
	<td> !&lt;&gt;	<td> F <td> F <td> T <td> T <td> no	<td> unordered or equal

	</table>

	<h4>Notes:</h4>
	<ol>
	<li> For floating point comparison operators, (a !op b) is not the same as !(a op b).
	<li> "Unordered" means one or both of the operands is a NAN.
	<li> "Exception" means the <i>Invalid Exception</i> is raised if one
		of the operands is a NAN. It does not mean an exception
		is thrown. The <i>Invalid Exception</i> can be checked
		using the functions in <a href="phobos/std_c_fenv.html">std.c.fenv</a>.
	</ol>

<h2><a name="InExpression">In Expressions</a></h2>

<pre class="bnf"><i>RelExpression</i> <b>in</b> <i>ShiftExpression</i>
</pre>

	An associative array can be tested to see if an element is in the array:

<pre class="d_code"><span class="d_keyword">int</span> foo[<span class="d_keyword">char</span>[]];
...
<span class="d_keyword">if</span> (<span class="d_string">"hello"</span> <span class="d_keyword">in</span> foo)
	...
</pre>

	The <b>in</b> expression has the same precedence as the
	relational expressions <b>&lt;</b>, <b>&lt;=</b>, 
	etc.
	The return value of the <i>InExpression</i> is <b>null</b>
	if the element is not in the array;
	if it is in the array it is a pointer to the element.

<h2><a name="ShiftExpression">Shift Expressions</a></h2>

<pre class="bnf"><i>ShiftExpression</i> <b>&lt;&lt;</b> <i>AddExpression</i>
<i>ShiftExpression</i> <b>&gt;&gt;</b> <i>AddExpression</i>
<i>ShiftExpression</i> <b>&gt;&gt;&gt;</b> <i>AddExpression</i>
</pre>

	The operands must be integral types, and undergo the usual integral
	promotions. The result type is the type of the left operand after
	the promotions. The result value is the result of shifting the bits
	by the right operand's value.
	<p>

	<b>&lt;&lt;</b> is a left shift.
	<b>&gt;&gt;</b> is a signed right shift.
	<b>&gt;&gt;&gt;</b> is an unsigned right shift.
	<p>

	It's illegal to shift by more bits than the size of the
	quantity being shifted:

<pre class="d_code"><span class="d_keyword">int</span> c;
c &lt;&lt; 33;	<span class="d_comment">// error
</span></pre>

<h2><a name="AddExpression">Add Expressions</a></h2>

<pre class="bnf"><i>AddExpression</i> <b>+</b> <i>MulExpression</i>
<i>AddExpression</i> <b>-</b> <i>MulExpression</i>
<i>AddExpression</i> <b>~</b> <i>MulExpression</i>
</pre>

	If the operands are of integral types, they undergo integral
	promotions, and then are brought to a common type using the
	usual arithmetic conversions.
	<p>

	If either operand is a floating point type, the other is implicitly
	converted to floating point and they are brought to a common type
	via the usual arithmetic conversions.
	<p>

	If the operator is <b>+</b> or <b>-</b>, and
	the first operand is a pointer, and the second is an integral type,
	the resulting type is the type of the first operand, and the resulting
	value is the pointer plus (or minus) the second operand multiplied by
	the size of the type pointed to by the first operand.
	<p>

	If the second operand is a pointer, and the first is an integral type,
	and the operator is <b>+</b>,
	the operands are reversed and the pointer arithmetic just described
	is applied.
	<p>

	Add expressions for floating point operands are not associative.

<h2><a name="MulExpression">Mul Expressions</a></h2>

<pre class="bnf"><i>MulExpression</i> <b>*</b> <i>UnaryExpression</i>
<i>MulExpression</i> <b>/</b> <i>UnaryExpression</i>
<i>MulExpression</i> <b>%</b> <i>UnaryExpression</i>
</pre>

	The operands must be arithmetic types. They undergo integral
	promotions, and then are brought to a common type using the
	usual arithmetic conversions.
	<p>

	For integral operands, the <b>*</b>, <b>/</b>, and <b>%</b>
	correspond to multiply, divide, and modulus operations.
	For multiply, overflows are ignored and simply chopped to fit
	into the integral type. If the right operand of divide or modulus
	operators is 0, a DivideByZeroException is thrown.
	<p>

	For floating point operands, the operations correspond to the
	IEEE 754 floating point equivalents. The modulus operator only
	works with reals, it is illegal to use it with imaginary or complex
	operands.
	<p>

	Mul expressions for floating point operands are not associative.

<h2><a name="UnaryExpression">Unary Expressions</a></h2>

<pre class="bnf"><b>&amp;</b> <i>UnaryExpression</i>
<b>++</b> <i>UnaryExpression</i>
<b>--</b> <i>UnaryExpression</i>
<b>*</b> <i>UnaryExpression</i>
<b>-</b> <i>UnaryExpression</i>
<b>+</b> <i>UnaryExpression</i>
<b>!</b> <i>UnaryExpression</i>
<b>~</b> <i>UnaryExpression</i>
<b>delete</b> <i>UnaryExpression</i>
<i>NewExpression</i>
<b>cast</b> <b>(</b> <i>Type</i> <b>)</b> <i>UnaryExpression</i>
<b>(</b> <i>Type</i> <b>) .</b> <i>Identifier</i>
<b>(</b> <i>Expression</i> <b>)</b>
</pre>


<h3><a name="NewExpression">New Expressions</a></h3>

	New expressions are used to allocate memory on the garbage
	collected heap (default) or using a class or struct specific allocator.
	<p>

	To allocate multidimensional arrays, the declaration reads
	in the same order as the prefix array declaration order.

<pre class="d_code"><span class="d_keyword">char</span>[][] foo;	<span class="d_comment">// dynamic array of strings
</span>...
foo = <span class="d_keyword">new</span> <span class="d_keyword">char</span>[][30];	<span class="d_comment">// allocate array of 30 strings
</span></pre>

	If there is a <b>new (</b> <i>ArgumentList</i> <b>)</b>, then
	those arguments are passed to the class or struct specific allocator
	function after the size argument.

<h3><a name="DeleteExpression">Delete Expressions</a></h3>

	If the <i>UnaryExpression</i> is a class object reference, and
	there is a destructor for that class, the destructor
	is called for that object instance.
	<p>

	Next, if the <i>UnaryExpression</i> is a class object reference, or
	a pointer to a struct instance, and the class or struct
	has overloaded operator delete, then that operator delete is called
	for that class object instance or struct instance.
	<p>

	Otherwise, the garbage collector is called to immediately free the
	memory allocated for the class instance or struct instance.
	If the garbage collector was not used to allocate the memory for
	the instance, undefined behavior will result.
	<p>

	If the <i>UnaryExpression</i> is a pointer or a dynamic array,
	the garbage collector is called to immediately release the
	memory.
	If the garbage collector was not used to allocate the memory for
	the instance, undefined behavior will result.
	<p>

	The pointer, dynamic array, or reference is set to <b>null</b>
	after the delete is performed.

<h3><a name="CastExpression">Cast Expressions</a></h3>

	A <i>CastExpression</i> converts the <i>UnaryExpression</i>
	to <i>Type</i>.

<pre class="d_code"><b><span class="d_keyword">cast</span></b>(foo) -p;	<span class="d_comment">// cast (-p) to type foo
</span>(foo) - p;	<span class="d_comment">// subtract p from foo
</span></pre>

	Any casting of a class reference to a 
	derived class reference is done with a runtime check to make sure it
	really is a downcast. <b>null</b> is the result if it isn't.
	<b>Note:</b> This is equivalent to the behavior of the
	dynamic_cast operator in C++.

<pre class="d_code"><span class="d_keyword">class</span> A { ... }
<span class="d_keyword">class</span> B : A { ... }

<span class="d_keyword">void</span> test(A a, B b)
{
     B bx = a;		<span class="d_comment">// error, need cast
</span>     B bx = <span class="d_keyword">cast</span>(B) a;	<span class="d_comment">// bx is null if a is not a B
</span>     A ax = b;		<span class="d_comment">// no cast needed
</span>     A ax = <span class="d_keyword">cast</span>(A) b;	<span class="d_comment">// no runtime check needed for upcast
</span>}
</pre>

	In order to determine if an object <tt>o</tt> is an instance of
	a class <tt>B</tt> use a cast:

<pre class="d_code"><span class="d_keyword">if</span> (<b><span class="d_keyword">cast</span></b>(B) o)
{
    <span class="d_comment">// o is an instance of B
</span>}
<span class="d_keyword">else</span>
{
    <span class="d_comment">// o is not an instance of B
</span>}
</pre>

	Casting a floating point literal from one type to another
	changes its type, but internally it is retained at full
	precision for the purposes of constant folding.

<pre class="d_code"><span class="d_keyword">void</span> test()
{
    <span class="d_keyword">real</span> a = 3.40483L;
    <span class="d_keyword">real</span> b;
    b = 3.40483;         <span class="d_comment">// literal is not truncated to double precision
</span>    <span class="d_keyword">assert</span>(a == b);
    <span class="d_keyword">assert</span>(a == 3.40483);
    <span class="d_keyword">assert</span>(a == 3.40483L);
    <span class="d_keyword">assert</span>(a == 3.40483F);
    <span class="d_keyword">double</span> d = 3.40483;	<span class="d_comment">// truncate literal when assigned to variable
</span>    <span class="d_keyword">assert</span>(d != a);     <span class="d_comment">// so it is no longer the same
</span>    <span class="d_keyword">const</span> <span class="d_keyword">double</span> x = 3.40483; <span class="d_comment">// assignment to const is not
</span>    <span class="d_keyword">assert</span>(x == a);           <span class="d_comment">// truncated if the initializer is visible
</span>}
</pre>

<h2><a name="PostfixExpression">Postfix Expressions</a></h2>

<pre class="bnf"><i>PostfixExpression</i> <b>.</b> <i>Identifier</i>
<i>PostfixExpression</i> <b>.</b> <i>NewExpression</i>
<i>PostfixExpression</i> <b>++</b>
<i>PostfixExpression</i> <b>--</b>
<i>PostfixExpression</i> <b>(</b> <i>ArgumentList</i> <b>)</b>
<i>PostfixExpression</i> <b>[</b> <i>ArgumentList</i> <b>]</b>
<i>PostfixExpression</i> <b>[</b> <i>AssignExpression</i> <b>..</b> <i>AssignExpression</i> <b>]</b>
</pre>

<h2><a name="IndexExpression">Index Expressions</a></h2>

<pre class="bnf"><i>PostfixExpression</i> <b>[</b> <i>ArgumentList</i> <b>]</b>
</pre>

	<i>PostfixExpression</i> is evaluated.
	if <i>PostfixExpression</i> is an expression of type
	static array or dynamic array, the variable <b>length</b>
	is declared and set to be the length of the array.
	A new declaration scope is created for the evaluation of the
	<i>ArgumentList</i> and <b>length</b> appears in that scope only.


<h2><a name="SliceExpression">Slice Expressions</a></h2>

<pre class="bnf"><i>PostfixExpression</i> <b>[</b> <i>AssignExpression</i> <b>..</b> <i>AssignExpression</i> <b>]</b>
</pre>

	<i>PostfixExpression</i> is evaluated.
	if <i>PostfixExpression</i> is an expression of type
	static array or dynamic array, the variable <b>length</b>
	is declared and set to be the length of the array.
	A new declaration scope is created for the evaluation of the
	<i>AssignExpression</i>..<i>AssignExpression</i>
	and <b>length</b> appears in that scope only.
	<p>

	The first <i>AssignExpression</i> is taken to be the inclusive
	lower bound
	of the slice, and the second <i>AssignExpression</i> is the
	exclusive upper bound.
	The result of the expression is a slice of the <i>PostfixExpression</i>
	array.

<h2><a name="PrimaryExpression">Primary Expressions</a></h2>

<pre class="bnf"><i>Identifier</i>
<b>.</b><i>Identifier</i>
<b>this</b>
<b>super</b>
<b>null</b>
<b>true</b>
<b>false</b>
<i>NumericLiteral</i>
<i>CharacterLiteral</i>
<i>StringLiteral</i>
<i>FunctionLiteral</i>
<i>AssertExpression</i>
<i>BasicType</i> <b>.</b> <i>Identifier</i>
<b>typeid (</b> <i>Type</i> <b>)</b>
</pre>

<h3>.Identifier</h3>

	<i>Identifier</i> is looked up at module scope, rather than the current
	lexically nested scope.

<h3>this</h3>

	Within a non-static member function, <b>this</b> resolves to
	a reference to the object that called the function.
	If a member function is called with an explicit reference
	to <b>typeof(this)</b>, a non-virtual call is made:

<pre class="d_code"><span class="d_keyword">class</span> A
{
    <span class="d_keyword">char</span> get() { <span class="d_keyword">return</span> 'A'; }

    <span class="d_keyword">char</span> foo() { <span class="d_keyword">return</span> <b><span class="d_keyword">typeof</span>(<span class="d_keyword">this</span>)</b>.get(); }
    <span class="d_keyword">char</span> bar() { <span class="d_keyword">return</span> <b><span class="d_keyword">this</span></b>.get(); }
}

<span class="d_keyword">class</span> B : A
{
    <span class="d_keyword">char</span> get() { <span class="d_keyword">return</span> 'B'; }
}

<span class="d_keyword">void</span> main()
{
    B b = <span class="d_keyword">new</span> B();

    b.foo();		<span class="d_comment">// returns 'A'
</span>    b.bar();		<span class="d_comment">// returns 'B'
</span>}
</pre>


<h3>super</h3>

	Within a non-static member function, <b>super</b> resolves to
	a reference to the object that called the function, cast to
	its base class. It is an error if there is no base class.
	<b>super</b> is not allowed in struct member
	functions.
	If a member function is called with an explicit reference
	to <b>super</b>, a non-virtual call is made.

<h3>null</h3>

	The keyword <b>null</b> represents the null pointer value;
	technically it is of type (void *). It 
	can be implicitly cast to any pointer type.
	The integer 0 cannot be cast to the null pointer. 
	Nulls are also used for empty arrays.

<h3>true, false</h3>

	These are of type <b>bool</b> and when cast to another integral
	type become the values 1 and 0,
	respectively.

<h3>Character Literals</h3>

	Character literals are single characters and resolve to one
	of type <b>char</b>, <b>wchar</b>, or <b>dchar</b>.
	If the literal is a \u escape sequence, it resolves to type <b>wchar</b>.
	If the literal is a \U escape sequence, it resolves to type <b>dchar</b>.
	Otherwise, it resolves to the type with the smallest size it
	will fit into.


<h3><a name="FunctionLiteral">Function Literals</a></h3>

<pre class="bnf"><i>FunctionLiteral</i>
	<b>function</b> <i>Type</i><sub>opt</sub> <b>(</b> <i>ArgumentList</i> <b>)</b><sub>opt</sub> <i>FunctionBody</i>
	<b>delegate</b> <i>Type</i><sub>opt</sub> <b>(</b> <i>ArgumentList</i> <b>)</b><sub>opt</sub> <i>FunctionBody</i>
	<b>(</b> <i>ArgumentList</i> <b>)</b> <i>FunctionBody</i>
	<i>FunctionBody</i>
</pre>

	<i>FunctionLiteral</i>s enable embedding anonymous functions
	and anonymous delegates directly into expressions.
	<i>Type</i> is the return type of the function or delegate,
	if omitted it is inferred from any <i>ReturnStatement</i>s
	in the <i>FunctionBody</i>.
	<b>(</b> <i>ArgumentList</i> <b>)</b>
	forms the arguments to the function.
	If omitted it defaults to the empty argument list <b>()</b>.
	The type of a function literal is pointer to function or
	pointer to delegate.
	If the keywords <b>function</b> or <b>delegate</b> are omitted,
	it defaults to being a delegate.
	<p>

	For example:

<pre class="d_code"><span class="d_keyword">int</span> <span class="d_keyword">function</span>(<span class="d_keyword">char</span> c) fp;	<span class="d_comment">// declare pointer to a function
</span>
<span class="d_keyword">void</span> test()
{
    <span class="d_keyword">static</span> <span class="d_keyword">int</span> foo(<span class="d_keyword">char</span> c) { <span class="d_keyword">return</span> 6; }

    fp = &amp;foo;
}
</pre>

	is exactly equivalent to:

<pre class="d_code"><span class="d_keyword">int</span> <span class="d_keyword">function</span>(<span class="d_keyword">char</span> c) fp;

<span class="d_keyword">void</span> test()
{
    fp = <b><span class="d_keyword">function</span> <span class="d_keyword">int</span>(<span class="d_keyword">char</span> c) { <span class="d_keyword">return</span> 6;}</b> ;
}
</pre>

	And:

<pre class="d_code"><span class="d_keyword">int</span> abc(<span class="d_keyword">int</span> <span class="d_keyword">delegate</span>(<span class="d_keyword">long</span> i));

<span class="d_keyword">void</span> test()
{   <span class="d_keyword">int</span> b = 3;
    <span class="d_keyword">int</span> foo(<span class="d_keyword">long</span> c) { <span class="d_keyword">return</span> 6 + b; }

    abc(&amp;foo);
}
</pre>

	is exactly equivalent to:

<pre class="d_code"><span class="d_keyword">int</span> abc(<span class="d_keyword">int</span> <span class="d_keyword">delegate</span>(<span class="d_keyword">long</span> i));

<span class="d_keyword">void</span> test()
{   <span class="d_keyword">int</span> b = 3;

    abc( <b><span class="d_keyword">delegate</span> <span class="d_keyword">int</span>(<span class="d_keyword">long</span> c) { <span class="d_keyword">return</span> 6 + b; }</b> );
}
</pre>

	<p>and the following where the return type <b>int</b> is
	inferred:</p>

<pre class="d_code"><span class="d_keyword">int</span> abc(<span class="d_keyword">int</span> <span class="d_keyword">delegate</span>(<span class="d_keyword">long</span> i));

<span class="d_keyword">void</span> test()
{   <span class="d_keyword">int</span> b = 3;

    abc( <b>(<span class="d_keyword">long</span> c) { <span class="d_keyword">return</span> 6 + b; }</b> );
}
</pre>

	Anonymous delegates can behave like arbitrary statement literals.
	For example, here an arbitrary statement is executed by a loop:

<pre class="d_code"><span class="d_keyword">double</span> test()
{   <span class="d_keyword">double</span> d = 7.6;
    <span class="d_keyword">float</span> f = 2.3;

    <span class="d_keyword">void</span> loop(<span class="d_keyword">int</span> k, <span class="d_keyword">int</span> j, <span class="d_keyword">void</span> <span class="d_keyword">delegate</span>() statement)
    {
	<span class="d_keyword">for</span> (<span class="d_keyword">int</span> i = k; i &lt; j; i++)
	{
	    statement();
	}
    }

    loop(5, 100, <b>{ d += 1; }</b> );
    loop(3, 10,  <b>{ f += 3; }</b> );

    <span class="d_keyword">return</span> d + f;
}
</pre>

	When comparing with <a href="function.html#nested">nested
	functions</a>, the <b>function</b> form is analogous to static
	or non-nested functions, and the <b>delegate</b> form is
	analogous to non-static nested functions. In other words,
	a delegate literal can access stack variables in its enclosing
	function, a function literal cannot.


<h3><a name="AssertExpression">Assert Expressions</a></h3>

<pre class="bnf"><i>AssertExpression</i>:
	<b>assert (</b> <i>Expression</i> <b>)</b>
	<b>assert (</b> <i>Expression</i> <b>,</b> <i>Expression</i> <b>)</b>
</pre>

	<p>Asserts evaluate the <i>expression</i>. If the result is false,
	an <b>AssertError</b> is thrown. If the result is true, then no
	exception is thrown.
	It is an error if the <i>expression</i> contains any side effects
	that the program depends on. The compiler may optionally not
	evaluate assert expressions at all.
	The result type of an assert expression is <tt>void</tt>.
	Asserts are a fundamental part of the
	<a href="dbc.html">Contract Programming</a>
	support in D.
	</p>

	<p>The expression <tt>assert(0)</tt> is a special case; it
	signifies that it is unreachable code.
	Either <b>AssertError</b> is thrown at runtime if it is reachable,
	or the execution is halted
	(on the x86 processor, a <b>HLT</b> instruction can be used to halt
	execution).
	The optimization and code generation phases of compilation may
	assume that it is unreachable code.
	</p>

	<p>The second <i>Expression</i>, if present, must be implicitly
	convertible to type <tt>char[]</tt>. It is evaluated if the
	result is false, and the string result is appended to the
	<b>AssertError</b>'s message.
	</p>

<pre class="d_code"><span class="d_keyword">void</span> main()
{
    <span class="d_keyword">assert</span>(0, <span class="d_string">"an"</span> ~ <span class="d_string">" error message"</span>);
}
</pre>

	<p>When compiled and run, it will produce the message:</p>

<pre class="console">Error: AssertError Failure test.d(3) an error message
</pre>


<h3><a name="typeidexpression">Typeid Expressions</a></h3>

<pre class="bnf"><i>TypeidExpression</i>:
    <b>typeid (</b> <i>Type</i> <b>)</b>
</pre>

	Returns an instance of class <b>TypeInfo</b> corresponding
	to <i>Type</i>.

<h3><a name="IsExpression">IsExpression</a></h3>

<pre class="bnf"><i>IsExpression</i>:
	<b>is (</b> <i>Type</i> <b>)</b>
	<b>is (</b> <i>Type</i> <b>:</b> <i>TypeSpecialization</i> <b>)</b>
	<b>is (</b> <i>Type</i> <b>==</b> <i>TypeSpecialization</i> <b>)</b>
	<b>is (</b> <i>Type</i> <i>Identifier</i> <b>)</b>
	<b>is (</b> <i>Type</i> <i>Identifier</i> <b>:</b> <i>TypeSpecialization</i> <b>)</b>
	<b>is (</b> <i>Type</i> <i>Identifier</i> <b>==</b> <i>TypeSpecialization</i> <b>)</b>

<i>TypeSpecialization</i>:
	<i>Type</i>
	<b>typedef</b>
	<b>struct</b>
	<b>union</b>
	<b>class</b>
	<b>interface</b>
	<b>enum</b>
	<b>function</b>
	<b>delegate</b>
</pre>

	<i>IsExpression</i>s are evaluated at compile time and are
	used for checking for valid types, comparing types for equivalence,
	determining if one type can be implicitly converted to another,
	and deducing the subtypes of a type.
	The result of an <i>IsExpression</i> is an int of type 0
	if the condition is not satisified, 1 if it is.
	<p>

	<i>Type</i> is the type being tested. It must be syntactically
	correct, but it need not be semantically correct.
	If it is not semantically correct, the condition is not satisfied.
	<p>

	<i>Identifier</i> is declared to be an alias of the resulting
	type if the condition is satisfied. The <i>Identifier</i> forms
	can only be used if the <i>IsExpression</i> appears in a
	<a href="version.html#staticif"><i>StaticIfCondition</i></a>.
	<p>

	<i>TypeSpecialization</i> is the type that <i>Type</i> is being
	compared against.
	<p>

	The forms of the <i>IsExpression</i> are:

	<ol>

	<li> <b>is (</b> <i>Type</i> <b>)</b><br>
	The condition is satisfied if <i>Type</i> is semantically
	correct (it must be syntactically correct regardless).

<pre class="d_code"><span class="d_keyword">alias</span> <span class="d_keyword">int</span> func(<span class="d_keyword">int</span>);	<span class="d_comment">// func is a alias to a function type
</span><span class="d_keyword">void</span> foo()
{
    <span class="d_keyword">if</span> ( <b><span class="d_keyword">is</span></b>(func[]) )	<span class="d_comment">// not satisfied because arrays of
</span>			<span class="d_comment">// functions are not allowed
</span>	printf(<span class="d_string">"satisfied\n"</span>);
    <span class="d_keyword">else</span>
	printf(<span class="d_string">"not satisfied\n"</span>);

    <span class="d_keyword">if</span> (<b><span class="d_keyword">is</span></b>([][]))	<span class="d_comment">// error, [][] is not a syntactically valid type
</span>	...
}
</pre>

	<li> <b>is (</b> <i>Type</i> <b>:</b> <i>TypeSpecialization</i> <b>)</b><br>
	The condition is satisfied if <i>Type</i> is semantically
	correct and it is the same as
	or can be implicitly converted to <i>TypeSpecialization</i>.
	<i>TypeSpecialization</i> is only allowed to be a <i>Type</i>.

<pre class="d_code"><span class="d_keyword">alias</span> <span class="d_keyword">short</span> bar;
<span class="d_keyword">void</span> foo(bar x)
{
    <span class="d_keyword">if</span> ( <b><span class="d_keyword">is</span></b>(bar : <span class="d_keyword">int</span>) )	<span class="d_comment">// satisfied because short can be
</span>				<span class="d_comment">// implicitly converted to int
</span>	printf(<span class="d_string">"satisfied\n"</span>);
    <span class="d_keyword">else</span>
	printf(<span class="d_string">"not satisfied\n"</span>);
}
</pre>

	<li> <b>is (</b> <i>Type</i> <b>==</b> <i>TypeSpecialization</i> <b>)</b><br>
	The condition is satisfied if <i>Type</i> is semantically
	correct and is the same type as <i>TypeSpecialization</i>.
	<p>

	If <i>TypeSpecialization</i> is one of
		<b>typedef</b>
		<b>struct</b>
		<b>union</b>
		<b>class</b>
		<b>interface</b>
		<b>enum</b>
		<b>function</b>
		<b>delegate</b>
	then the condition is satisifed if <i>Type</i> is one of those.

<pre class="d_code"><span class="d_keyword">alias</span> <span class="d_keyword">short</span> bar;
<span class="d_keyword">typedef</span> <span class="d_keyword">char</span> foo;
<span class="d_keyword">void</span> foo(bar x)
{
    <span class="d_keyword">if</span> ( <b><span class="d_keyword">is</span></b>(bar == <span class="d_keyword">int</span>) )	<span class="d_comment">// not satisfied because short is not
</span>				<span class="d_comment">// the same type as int
</span>	printf(<span class="d_string">"satisfied\n"</span>);
    <span class="d_keyword">else</span>
	printf(<span class="d_string">"not satisfied\n"</span>);

    <span class="d_keyword">if</span> ( <b><span class="d_keyword">is</span></b>(foo == <span class="d_keyword">typedef</span>) ) <span class="d_comment">// satisfied because foo is a typedef
</span>	printf(<span class="d_string">"satisfied\n"</span>);
    <span class="d_keyword">else</span>
	printf(<span class="d_string">"not satisfied\n"</span>);
}
</pre>

	<li> <b>is (</b> <i>Type</i> <i>Identifier</i> <b>)</b><br>
	The condition is satisfied if <i>Type</i> is semantically
	correct. If so, <i>Identifier</i>
	is declared to be an alias of <i>Type</i>.

<pre class="d_code"><span class="d_keyword">alias</span> <span class="d_keyword">short</span> bar;
<span class="d_keyword">void</span> foo(bar x)
{
    <span class="d_keyword">static</span> <span class="d_keyword">if</span> ( <b><span class="d_keyword">is</span></b>(bar T) )
	<span class="d_keyword">alias</span> T S;
    <span class="d_keyword">else</span>
	<span class="d_keyword">alias</span> <span class="d_keyword">long</span> S;
    writefln(<span class="d_keyword">typeid</span>(S));   <span class="d_comment">// prints "short"
</span>
    <span class="d_keyword">if</span> ( <b><span class="d_keyword">is</span></b>(bar T) )  <span class="d_comment">// error, <i>Identifier</i> T form can
</span>		      <span class="d_comment">// only be in <a href="version.html#staticif"><i>StaticIfCondition</i></a>s
</span>	...
}
</pre>

	<li> <b>is (</b> <i>Type</i> <i>Identifier</i> <b>:</b> <i>TypeSpecialization</i> <b>)</b><br>
	The condition is satisfied if <i>Type</i> is the same as
	or can be implicitly converted to <i>TypeSpecialization</i>.
	The <i>Identifier</i> is declared to be either an alias of the
	<i>TypeSpecialization</i> or, if <i>TypeSpecialization</i> is
	dependent on <i>Identifier</i>, the deduced type.
	<i>TypeSpecialization</i> is only allowed to be a <i>Type</i>.

<pre class="d_code"><span class="d_keyword">alias</span> <span class="d_keyword">short</span> bar;
<span class="d_keyword">alias</span> <span class="d_keyword">long</span>* abc;
<span class="d_keyword">void</span> foo(bar x, abc a)
{
    <span class="d_keyword">static</span> <span class="d_keyword">if</span> ( <b><span class="d_keyword">is</span></b>(bar T : <span class="d_keyword">int</span>) )
	<span class="d_keyword">alias</span> T S;
    <span class="d_keyword">else</span>
	<span class="d_keyword">alias</span> <span class="d_keyword">long</span> S;

    writefln(<span class="d_keyword">typeid</span>(S));	<span class="d_comment">// prints "int"
</span>
    <span class="d_keyword">static</span> <span class="d_keyword">if</span> ( <b><span class="d_keyword">is</span></b>(abc U : U*) )
	U u;

    writefln(<span class="d_keyword">typeid</span>(<span class="d_keyword">typeof</span>(u)));	<span class="d_comment">// prints "long"
</span>}
</pre>

	The way the type of <i>Identifier</i> is determined is analogous
	to the way template parameter types are determined by
	<i>TemplateTypeParameterSpecialization</i>.
	<p>

	<li> <b>is (</b> <i>Type</i> <i>Identifier</i> <b>==</b> <i>TypeSpecialization</i> <b>)</b><br>
	The condition is satisfied if <i>Type</i> is semantically
	correct and is the same as <i>TypeSpecialization</i>.
	The <i>Identifier</i> is declared to be either an alias of the
	<i>TypeSpecialization</i> or, if <i>TypeSpecialization</i> is
	dependent on <i>Identifier</i>, the deduced type.
	<p>

	If <i>TypeSpecialization</i> is one of
		<b>typedef</b>
		<b>struct</b>
		<b>union</b>
		<b>class</b>
		<b>interface</b>
		<b>enum</b>
		<b>function</b>
		<b>delegate</b>
	then the condition is satisifed if <i>Type</i> is one of those.
	Furthermore, <i>Identifier</i> is set to be an alias of the type:
	<p>

	<table border=1 cellpadding=4 cellspacing=0>
	<tr>
	<th> keyword
	<th> alias type for <i>Identifier</i>
	<tr>
	<td> <b>typedef</b>
	<td> the type that <i>Type</i> is a typedef of
	<tr>
	<td> <b>struct</b>
	<td> <i>Type</i>
	<tr>
	<td> <b>union</b>
	<td> <i>Type</i>
	<tr>
	<td> <b>class</b>
	<td> <i>Type</i>
	<tr>
	<td> <b>interface</b>
	<td> <i>Type</i>
	<tr>
	<td> <b>enum</b>
	<td> the base type of the enum
	<tr>
	<td> <b>function</b>
	<td> the return type of the function
	<tr>
	<td> <b>delegate</b>
	<td> the function type of the delegate
	</table>

<pre class="d_code"><span class="d_keyword">alias</span> <span class="d_keyword">short</span> bar;
<span class="d_keyword">enum</span> E : <span class="d_keyword">byte</span> { Emember }
<span class="d_keyword">void</span> foo(bar x, abc a)
{
    <span class="d_keyword">static</span> <span class="d_keyword">if</span> ( <b><span class="d_keyword">is</span></b>(bar T == <span class="d_keyword">int</span>) ) <span class="d_comment">// not satisfied, short is not int
</span>	<span class="d_keyword">alias</span> T S;
    <span class="d_keyword">alias</span> T U;			   <span class="d_comment">// error, T is not defined
</span>
    <span class="d_keyword">static</span> <span class="d_keyword">if</span> ( <b><span class="d_keyword">is</span></b>(E V == <span class="d_keyword">enum</span>) )  <span class="d_comment">// satisified, E is an enum
</span>	V x;			   <span class="d_comment">// x is declared to be a byte
</span>}
</pre>

	</ol>




  
<br><br>
<br><br>
<!-- Google ad -->
<script type="text/javascript"><!--
/**/google_ad_client = "pub-5628673096434613";
/**/google_ad_width = 728;
/**/google_ad_height = 90;
/**/google_ad_format = "728x90_as";
/**/google_ad_channel ="3651639259";
/**/google_page_url = document.location;
//--></script>
<script type="text/javascript" src="../../../../../../../../pagead2.googlesyndication.com/pagead/show_ads.js">
</script>

</div>





<div id="copyright">
Copyright &copy; 1999-2006 by Digital Mars, All Rights Reserved |
Page generated by <a href="http://www.digitalmars.com/d/ddoc.html">Ddoc</a>. |
<a href="http://www.prowiki.org/wiki4d/wiki.cgi?DocComments/Expression" title="Read/write comments and feedback">Comments</a>
</div>

</body>

<!-- Mirrored from www.shorthike.com/trac/browser/trunk/tools_win32/dmd/html/d/expression.html?format=raw by HTTrack Website Copier/3.x [XR&CO'2010], Sat, 01 May 2010 04:37:18 GMT -->
<!-- Added by HTTrack --><meta http-equiv="content-type" content="text/html;charset=UTF-8"><!-- /Added by HTTrack -->
</html>

