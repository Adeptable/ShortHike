
<!DOCTYPE html PUBLIC "-//W3C//DTD HTML 4.01//EN" "http://www.w3.org/TR/html4/strict.dtd">
<html>

<!--
	Copyright (c) 1999-2006 by Digital Mars
	All Rights Reserved
	Written by Walter Bright
	www.digitalmars.com
  -->


<!-- Mirrored from www.shorthike.com/trac/browser/trunk/tools_win32/dmd/html/d/faq.html?format=raw by HTTrack Website Copier/3.x [XR&CO'2010], Sat, 01 May 2010 04:37:18 GMT -->
<!-- Added by HTTrack --><meta http-equiv="content-type" content="text/html;charset=UTF-8"><!-- /Added by HTTrack -->
<head>
<meta http-equiv="content-type" content="text/html; charset=utf-8" />
<meta name="keywords" content="D programming language" />
<meta name="description" content="D Programming Language" />
<title>D Programming Language - FAQ</title>
<link rel="stylesheet" type="text/css" href="style.html" />
<link rel="shortcut icon" href="favicon.html" />
</head>

<body>
<div id="heading">
	<a href="http://www.digitalmars.com/"><img src="dmlogo.html" width="270" height="53" style="border-style:none" alt="www.digitalmars.com"></a>

	<div id="headingNav">
	<ul>	<li><a href="http://www.prowiki.org/wiki4d/wiki.cgi?DocComments/FAQ" title="Read/write comments and feedback">Comments</a></li>
	<li><a href="index.html" title="D Programming Language" class="dlink">D</a></li>
	<li><a href="http://www.digitalmars.com/advancedsearch.html" title="Search Digital Mars web site">Search</a></li>
	<li><a href="download.html" title="download D">Downloads</a></li>
	<li><a href="http://www.digitalmars.com/" title="www.digitalmars.com">Home</a></li>
	</ul>
	</div>

	<div id="lastupdate">Last update Fri Jun 16 00:33:14 2006
</div>
</div>

<!-- Generated by Ddoc from faq.d -->



<div id="navigation">
  
<div class="navblock">
<form method="get" action="http://www.google.com/search">
<div id="searchbox">
<input id="q" name="q" size="10" value="Search" onFocus='if(this.value == "Search"){this.value="";}'>
<input type="hidden" id="domains" name="domains" value="www.digitalmars.com">
<input type="hidden" id="sitesearch" name="sitesearch" value="www.digitalmars.com/d">
<input type="hidden" id="sourceid" name="sourceid" value="google-search">
<input type="submit" id="submit" name="submit" value="Go">
</div>
</form>
<div id="toctop">
    <ul>	<li><a href="index.html" title="D Programming Language">D ...</a></li>
	<li><a href="lex.html" title="D Language Specification">Language ...</a></li>
	<li><a href="phobos/phobos.html" title="D Runtime Library">Phobos ...</a></li>
	<li><a href="comparison.html" title="Language Comparisons">Comparisons ...</a></li>
    </ul>
</div>
</div>

  
    <div class="navblock">
	<ul>		<li><a href="overview.html">Overview</a></li>

		<li><a href="windows.html">D for Win32</a></li>

		<li><a href="dll.html">Win32 DLLs in D</a></li>

		<li><a href="htomodule.html">C .h to D Modules</a></li>

		<li><a href="faq.html">FAQ</a></li>

		<li><a href="dstyle.html">Style Guide</a></li>

		<li><a href="wc.html">Example: wc</a></li>

		<li><a href="future.html">Future</a></li>

		<li><a href="changelog.html">D Change Log</a></li>

		<li><a href="http://www.digitalmars.com/techtips/index.html">Tech Tips</a></li>

		<li><a href="rationale.html">Rationale</a></li>

		<li><a href="warnings.html">Warnings</a></li>

	</ul>
    </div>

    <div class="navblock">
	<h2>Articles</h2>
	<ul>		<li><a href="memory.html">Memory Management</a></li>

		<li><a href="exception-safe.html">Exception Safety</a></li>

		<li><a href="templates-revisited.html">Templates Revisited</a></li>

		<li><a href="regular-expression.html">Regular Expressions</a></li>

	</ul>
    </div>

    <div class="navblock">
	<h2>Tools</h2>
	<ul>		<li><a href="dcompiler.html">DMD D Compiler</a></li>

		<li><a href="http://dgcc.sourceforge.net/">GDC D Compiler</a></li>

		<li><a href="http://www.digitalmars.com/ctg/optlink.html">Linker</a></li>

		<li><a href="http://www.digitalmars.com/ctg/trace.html">Profiler</a></li>

		<li><a href="code_coverage.html">Code Coverage</a></li>

		<li><a href="rdmd.html">DMD Script Shell</a></li>

		<li><a href="windbg.html">Windows Debugger</a></li>

		<li><a href="htod.html">C .h to D .d</a></li>

		<li><a href="http://www.prowiki.org/wiki4d/wiki.cgi?EditorSupport">Editors</a></li>

		<li><a href="http://www.prowiki.org/wiki4d/wiki.cgi?ReferenceForTools">More Tools</a></li>

	</ul>
    </div>

    <div class="navblock">
	<h2>Community</h2>
	<ul>		
		<li><a href="http://www.digitalmars.com/NewsGroup.html">News</a></li>

		<li><a href="http://www.digitalmars.com/drn-bin/wwwnews?digitalmars.D">Forum</a></li>

		<li><a href="http://www.digitalmars.com/drn-bin/wwwnews?digitalmars.D.announce">Announcements</a></li>

		<li><a href="http://www.digitalmars.com/drn-bin/wwwnews?digitalmars.D.learn">Learn</a></li>

		<li><a href="dlinks.html">D links</a></li>

	</ul>
    </div>

    <div class="navblock">
	<h2>Archives</h2>
	<ul>		<li><a href="http://www.digitalmars.com/d/archives/digitalmars/D/index.html">digitalmars.D</a></li>

		<li><a href="http://www.digitalmars.com/d/archives/digitalmars/D/dtl/index.html">digitalmars.D.dtl</a></li>

		<li><a href="http://www.digitalmars.com/d/archives/digitalmars/D/announce/index.html">digitalmars.D.announce</a></li>

		<li><a href="http://www.digitalmars.com/d/archives/digitalmars/D/dwt/index.html">digitalmars.D.dwt</a></li>

		<li><a href="http://www.digitalmars.com/d/archives/digitalmars/D/learn/index.html">digitalmars.D.learn</a></li>

		<li><a href="http://www.digitalmars.com/d/archives/digitalmars/D/bugs/index.html">digitalmars.D.bugs</a></li>

		<li><a href="http://www.digitalmars.com/d/archives/D/gnu/index.html">D.gnu</a></li>

		<li><a href="http://www.digitalmars.com/d/archives/index.html">Old D</a></li>

	</ul>
    </div>

    <div class="navblock">
	<h2>Appendices</h2>
	<ul>		<li><a href="glossary.html">Glossary</a></li>

		<li><a href="ascii-table.html">Ascii Table</a></li>

		<li><a href="acknowledgements.html">Acknowledgements</a></li>

	</ul>
    </div>


</div>
<div id="content">
  <h1>        FAQ</h1>
  
	<p>The same questions keep cropping up, so the obvious thing to do is
	prepare a FAQ.</p>

	<ul>
	<li><a href="http://www.wikiservice.at/wiki4d/wiki.cgi?FaqRoadmap">The D FAQ wiki</a>
	with many more questions answered</li>
	<li><a href="comparison.html">What does D have that C++ doesn't?</a></li>
	<li><a href="#q1">Why the name D?</a></li>
	<li><a href="#q1_1">When can I get a D compiler?</a></li>
	<li><a href="#q1_2">Is there linux port of D?</a></li>
	<li><a href="#gdc">Is there a GNU version of D?</a></li>
	<li><a href="#backend">How do I write my own D compiler for CPU X?</a></li>
	<li><a href="#gui">Where can I get a GUI library for D?</a></li>
	<li><a href="#ide">Where can I get an IDE for D?</a></li>
	<li><a href="#q2">What about templates?</a></li>
	<li><a href="#q3">Why emphasize implementation ease?</a></li>
	<li><a href="#q4">Why did you leave [expletive deleted] printf in?</a></li>
	<li><a href="#q5">Will D be open source?</a></li>
	<li><a href="#q6">Why fall through on switch statements?</a></li>
	<li><a href="#q7">Why should I use D instead of Java?</a></li>
	<li><a href="#q7_2">Doesn't C++ support strings, bit arrays, etc. with STL?</a></li>
	<li><a href="#q7_3">Can't garbage collection be done in C++ with an add-on library?</a></li>
	<li><a href="#q7_4">Can't unit testing be done in C++ with an add-on library?</a></li>
	<li><a href="#q8">Why have an asm statement in a portable language?</a></li>
	<li><a href="#real">What is the point of 80 bit reals?</a></li>
	<li><a href="#anonymous">How do I do anonymous struct/unions in D?</a></li>
	<li><a href="#printf">How do I get printf() to work with strings?</a></li>
	<li><a href="#nan">Why are floating point values default initialized to nan rather than 0?</a></li>
	<li><a href="#assignmentoverloading">Why is overloading of the assignment operator not supported?</a></li>
	<li><a href="#keys">The '~' is not on my keyboard?</a></li>
	<li><a href="#omf">Can I link in C object files created with another compiler?</a></li>
	<li><a href="#regexp_literals">Why not support regular expression literals
		with the /foo/g syntax?</a></li>
	<li><a href="#dogfood">Why is the D front end written in C++ rather than D?</a></li>
	<li><a href="#cpp_interface">Why doesn't D have an interface to C++ as well as C?</a></li>
	<li><a href="#cpp_to_D">Why aren't all Digital Mars programs translated to D?</a></li>
	<li><a href="#foreach">When should I use a foreach loop rather than a for?</a></li>
	<li><a href="#call-cpp-code">Why cannot D code directly call existing C++ code?</a></li>
	<li><a href="#reference-counting">Why doesn't D use reference counting for garbage collection?</a></li>

	</ul>

<hr><h3><a name="q1">Why the name D?</a></h3>

	<p>The original name was the Mars Programming Language. But my friends
	kept calling it D, and I found myself starting to call it D.
	The idea of D being a successor to C goes back at least as far as 1988,
	as in this
	<a href="http://groups.google.com/groups?q=%22d+programming+language&amp;hl=en&amp;lr=&amp;ie=UTF8&amp;oe=UTF8&amp;selm=12055%40brl-adm.ARPA&amp;rnum=1">thread</a>.
	</p>

<hr><h3><a name="q1_1">Where can I get a D compiler?</a></h3>

	<p>Right <a href="dcompiler.html">here</a>.
	</p>

<hr><h3><a name="q1_2">Is there a linux port of D?</a></h3>

	<p>Yes, the D compiler includes a linux version.
	</p>

<hr><h3><a name="gdc">Is there a GNU version of D?</a></h3>

	<p>Yes, David Friedman has integrated the
	<a href="http://home.earthlink.net/~dvdfrdmn/d">D frontend with GCC</a>.
	</p>

<hr><h3><a name="backend">How do I write my own D compiler for CPU X?</a></h3>

	<p>Burton Radons has written a
	<a href="http://www.opend.org/dli/DLinux.html">back end</a>.
	you can use as a guide.
	</p>

<hr><h3><a name="gui">Where can I get a GUI library for D?</a></h3>

	<p>Since D can call C functions, any GUI library with a C interface is 
	accessible from D. Various D GUI libraries and ports can be found at 
	<a href="http://www.prowiki.org/wiki4d/wiki.cgi?AvailableGuiLibraries">AvailableGuiLibraries</a>.
	</p>

<hr><h3><a name="ide">Where can I get an IDE for D?</a></h3>

	<p><a href="http://leds.sourceforge.net/">LEDS</a> is a D language
	editor for Linux.
	</p>

<hr><h3><a name="q2">What about templates?</a></h3>

	<p>D now supports advanced templates.
	</p>

<hr><h3><a name="q3">Why emphasize implementation ease?</a></h3>

	<p>Isn't ease of use for the user of the language more important? Yes,
	it is.
	But a vaporware language is useless to everyone. The easier a language
	is to implement, the more robust implementations there will be. In C's
	heyday, there were 30 different commercial C compilers for the IBM PC.
	Not many made the transition to C++. In looking at
	the C++ compilers on the market today, how many years of development
	went into each? At least 10 years? Programmers waited years
	for the various pieces of C++ to get implemented after they were
	specified.
	If C++ was not so enormously popular, it's doubtful that very complex
	features
	like multiple inheritance, templates, etc., would ever have been
	implemented.
	</p>

	<p>I suggest that if a language is easier to implement, then it is
	likely also easier to understand. Isn't it better to spend time learning
	to write better programs than language arcana? If a language can capture
	90% of the power of
	C++ with 10% of its complexity, I argue that is a worthwhile tradeoff.
	</p>


<hr><h3><a name="q4">Why is [expletive deleted] printf in D?</a></h3>

	<p><b>printf</b> is not typesafe. It's old fashioned. It's not object-oriented.
	It's not usable with user-defined types. <b>printf</b> is guilty as
	charged. But it's just so darned useful. Nothing beats it for banging out
	a quick dump of a value when debugging.
	</p>

	<p><b>Note:</b> <b>printf</b> is actually not really
	part of D anyway, but since D provides easy access to C's runtime library,
	D gets it when needed.
	</p>


<hr><h3><a name="q5">Will D be open source?</a></h3>

	<p>The front end for D is open source, and the source comes with the
	<a href="dcompiler.html">compiler</a>.
	There is a <a href="http://sourceforge.net/projects/brightd">SourceForge</a>
	project underway to create a Gnu implementation of
	D from this.
	</p>

<hr><h3><a name="q6">Why fall through on switch statements?</a></h3>

	<p>Many people have asked for a requirement that there be a break between
	cases in a switch statement, that C's behavior of silently falling through
	is the cause of many bugs.
	</p>

	<p>The reason D doesn't change this is for the same reason that integral
	promotion rules and operator precedence rules were kept the same - to
	make code that looks the same as in C operate the same. If it had subtly
	different semantics, it will cause frustratingly subtle bugs.
	</p>


<hr><h3><a name="q7">Why should I use D instead of Java?</a></h3>

	D is distinct from Java in purpose, philosophy and reality.
	See this <a href="comparison.html">comparison</a>.
	<p>

	Java is designed to be write once, run everywhere. D is designed for writing
	efficient native system apps. Although D and Java share the notion that
	garbage collection is good and multiple inheritance is bad &lt;g&gt;, their
	different design goals mean the languages have very different feels.

<hr><h3><a name="q7_2">Doesn't C++ support strings, bit arrays, etc. with STL?</a></h3>

	In the C++ standard library are mechanisms for doing strings,
	bit arrays, dynamic arrays, associative arrays, bounds checked
	arrays, and complex numbers.
	<p>

	Sure, all this stuff can be done with libraries,
	following certain coding disciplines, etc. But you can also do
	object oriented programming in C (I've seen it done).
	Isn't it incongruous that something like strings,
	supported by the simplest BASIC interpreter, requires a very
	large and complicated infrastructure to support?
	Just the implementation of a string type in STL is over two
	thousand lines of code, using every advanced feature of templates.
	How much confidence can you have that this is all working
	correctly, how do you fix it if it is not, what do you do with the
	notoriously inscrutable error messages when there's an error
	using it, how can you be sure you are using it correctly
	(so there are no memory leaks, etc.)?
	<p>

	D's implementation of strings is simple and straightforward.
	There's little doubt how to use it, no worries about memory leaks,
	error messages are to the point, and it isn't hard to see if it
	is working as expected or not.

<hr><h3><a name="q7_3">Can't garbage collection be done in C++ with an add-on library?</a></h3>

	Yes, I use one myself. It isn't part of the language, though, and
	requires some subverting of the language to make it work.
	Using gc with C++ isn't for the standard or casual C++ programmer.
	Building it into the
	language, like in D, makes it practical for everyday programming chores.
	<p>

	GC isn't that hard to implement, either, unless you're building one
	of the more advanced ones. But a more advanced one is like building
	a better optimizer - the language still works 100% correctly even
	with a simple, basic one. The programming community is better served
	by multiple implementations competing on quality of code generated
	rather than by which corners of the spec are implemented at all.

<hr><h3><a name="q7_4">Can't unit testing be done in C++ with an add-on library?</a></h3>

	Sure. Try one out and then compare it with how D does it.
	It'll be quickly obvious what an improvement building it into
	the language is.

<hr><h3><a name="q8">Why have an asm statement in a portable language?</a></h3>

	An asm statement allows assembly code to be inserted directly into a D
	function. Assembler code will obviously be inherently non-portable. D is
	intended, however, to be a useful language for developing systems apps.
	Systems apps almost invariably wind up with system dependent code in them
	anyway, inline asm isn't much different. Inline asm will be useful for
	things like accessing special CPU instructions, accessing flag bits, special
	computational situations, and super optimizing a piece of code.
	<p>

	Before the C compiler had an inline assembler, I used external assemblers.
	There was constant grief because many, many different versions of the
	assembler were out there, the vendors kept changing the syntax of the
	assemblers, there were many different bugs in different versions, and even
	the command line syntax kept changing. What it all meant was that users
	could not reliably rebuild any code that needed assembler. An inline
	assembler provided reliability and consistency.

<hr><h3><a name="real">What is the point of 80 bit reals?</a></h3>

	More precision enables more accurate floating point computations
	to be done, especially when adding together large numbers of small
	real numbers. Prof. Kahan, who designed the Intel floating point
	unit, has an eloquent
	<a href="../../../../../../../../www.eecs.berkeley.edu/_wkahan/JAVAhurt.pdf">paper</a>
	on the subject.

<hr><h3><a name="anonymous">How do I do anonymous struct/unions in D?</a></h3>

<pre class="d_code"><span class="d_keyword">struct</span> Foo
{
    <span class="d_keyword">union</span> { <span class="d_keyword">int</span> a; <span class="d_keyword">int</span> b; }
    <span class="d_keyword">struct</span> { <span class="d_keyword">int</span> c; <span class="d_keyword">int</span> d; }
}

<span class="d_keyword">void</span> main()
{
    Foo f;

    printf(<span class="d_string">"Foo.sizeof = %d, a.offset = %d, b.offset = %d, c.offset = %d, d.offset = %d\n"</span>,
	f.sizeof,
	0,
	&amp;f.b - &amp;f.a,
	&amp;f.c - &amp;f.a,
	&amp;f.d - &amp;f.a);
}
</pre>

<hr><h3><a name="printf">How do I get printf() to work with strings?</a></h3>

	In C, the normal way to printf a string is to use the <b>%s</b>
	format:

<pre class="ccode">char s[8];
strcpy(s, "foo");
printf("string = '<b>%s</b>'\n", s);
</pre>

	Attempting this in D, as in:

<pre class="d_code"><span class="d_keyword">char</span>[] s;
s = <span class="d_string">"foo"</span>;
printf(<span class="d_string">"string = '<b>%s</b>'\n"</span>, s);
</pre>

	usually results in garbage being printed, or an access violation.
	The cause is that in C, strings are terminated by a 0 character.
	The <b>%s</b> format prints until a 0 is encountered.
	In D, strings are not 0 terminated, the size is determined
	by a separate length value. So, strings are printf'd using the
	<b>%.*s</b> format:

<pre class="d_code"><span class="d_keyword">char</span>[] s;
s = <span class="d_string">"foo"</span>;
printf(<span class="d_string">"string = '<b>%.*s</b>'\n"</span>, s);
</pre>

	which will behave as expected.
	Remember, though, that printf's <b>%.*s</b> will print until the length
	is reached or a 0 is encountered, so D strings with embedded 0's
	will only print up to the first 0.

<hr><h3><a name="nan">Why are floating point values default initialized to nan rather than 0?</a></h3>

	A floating point value, if no explicit initializer is given,
	is initialized to nan (Not A Number):

<pre class="d_code"><span class="d_keyword">double</span> d;	<span class="d_comment">// d is set to double.nan
</span></pre>

	Nan's have the interesting property in that whenever a nan is
	used as an operand in a computation, the result is a nan. Therefore,
	nan's will propagate and appear in the output whenever a computation
	made use of one. This implies that a nan appearing in the output
	is an unambiguous indication of the use of an uninitialized
	variable.
	<p>

	If 0.0 was used as the default initializer for floating point
	values, its effect can easily be unnoticed in the output, and so
	if the default initializer was unintended, the bug may go
	unrecognized.
	<p>

	The default initializer value is not meant to be a useful value,
	it is meant to expose bugs. Nan fills that role well.
	<p>

	But surely the compiler can detect and issue an error message
	for variables used that are not initialized? Most of the time,
	it can, but not always, and what it can do is dependent on the
	sophistication of the compiler's internal data flow analysis.
	Hence, relying on such is unportable and unreliable.
	<p>

	Because of the way CPUs are designed, there is no nan value for
	integers, so D uses 0 instead. It doesn't have the advantages of
	error detection that nan has, but at least errors resulting from
	unintended default initializations will be consistent and therefore more
	debuggable.

<hr><h3><a name="assignmentoverloading">Why is overloading of the assignment operator not supported?</a></h3>

	Most of the assignment operator overloading in C++ seems to be needed to
	just keep track of who owns the memory. So by using reference types
	coupled with GC, most of this just gets replaced with copying the
	reference itself. For example, given an array of class objects, the
	array's contents can be moved, sorted, shifted, etc., all without any
	need for overloaded assignments. Ditto for function parameters and
	return values. The references themselves just get moved about. There
	just doesn't seem to be any need for copying the entire contents of one
	class object into another pre-existing class object.
	<p>

	Sometimes, one does need to create a copy of a class object, and for
	that one can still write a copy constructor in D, but they just don't
	seem to be needed remotely as much as in C++.
	<p>

	Structs, being value objects, do get copied about. A copy is defined in
	D to be a bit copy. I've never been comfortable with any object in C++
	that does something other than a bit copy when copied. Most of this
	other behavior stems from that old problem of trying to manage memory.
	Absent that, there doesn't seem to be a compelling rationale for
	having anything other than a bit copy.

<hr><h3><a name="keys">The '~' is not on my keyboard?</a></h3>

	<p>On PC keyboards, hold down the [Alt] key and press the 1, 2, and 6
	keys in sequence on the numeric pad. That will generate a '~'
	character.
	</p>

<hr><h3><a name="omf">Can I link in C object files created with another compiler?</a></h3>


	DMD produces OMF (Microsoft Object Module Format) object 
	files while other compilers such as VC++ produce COFF object
	files.
	DMD's output is designed to work with DMC, the Digital Mars C
	compiler, which also produces object files in OMF format.
	<p>

	The OMF format that DMD uses is a Microsoft defined format based on an
	earlier Intel designed one. Microsoft at one point decided to abandon it
	in favor of a Microsoft defined variant on COFF.
	<p>

	Using the same object format doesn't mean that any C library in that
	format will successfully link and run. There is a lot more compatibility
	required - such as calling conventions, name mangling, compiler helper
	functions, and hidden assumptions about the way things work. If DMD
	produced Microsoft COFF output files, there is still little chance that
	they would work successfully with object files designed and tested for
	use with VC. There were a lot of problems with this back when
	Microsoft's compilers did generate OMF.
	<p>

	Having a different object file format makes it helpful in identifying
	library files that were not tested to work with DMD. If they are not,
	weird problems would result even if they successfully managed to link
	them together. It really takes an expert to get a binary built with a
	compiler from one vendor to work with the output of another vendor's
	compiler.
	<p>

	That said, the linux version of DMD produces object files in the ELF
	format which is standard on linux, and it is specifically designed to
	work with the standard linux C compiler, gcc.
	<p>

	There is one case where using existing C libraries does work - when
	those libraries come in the form of a DLL conforming to the usual C ABI
	interface. The linkable part of this is called an "import library", and
	Microsoft COFF format import libraries can be successfully converted to
	DMD OMF using the
	<a href="http://www.digitalmars.com/ctg/coff2omf.html">coff2omf</a>
	tool.

<hr><h3><a name="regexp_literals">Why not support regular expression literals
	with the <tt>/foo/g</tt> syntax?</a></h3>

	<p>There are two reasons:
	</p>

	<ol>
	<li>The <tt>/foo/g</tt> syntax would make it impossible to separate
	the lexer from the parser, as / is the divide token.</li>

	<li>There are already 3 string types; adding the regex literals
	would add 3 more. This would proliferate through much of the compiler,
	debugger info, and library, and is not worth it.</li>

	</ol>

<hr><h3><a name="dogfood">Why is the D front end written in C++ rather than D?</a></h3>

	<p>The front end is in C++ in order to interface to the existing gcc
	and dmd back ends. 
	It's also meant to be easily interfaced to other existing back ends,
	which are likely written in C++.
	The D implementation of
	<a href="http://www.digitalmars.com/dscript/index.html">DMDScript</a>,
	which performs better than the
	<a href="http://www.digitalmars.com/dscript/cppscript.html">C++ version</a>,
	shows that there is no problem
	writing a professional quality compiler in 100% D.
	</p>

<hr><h3><a name="cpp_interface">Why doesn't D have an interface to C++ as well as C?</a></h3>

	<p>Attempting to have D interface with C++ is 
	nearly as complicated as writing a C++ compiler, which would destroy the 
	goal of having D be a reasonably easy language to implement.
	For people with an existing C++ code base that they must work with, they are 
	stuck with C++ (they can't move it to any other language, either).</p>

<hr><h3><a name="cpp_to_D">Why aren't all Digital Mars programs translated to D?</a></h3>

	<p>There is little benefit to translating a complex, debugged, working
	application from one language to another. But new Digital Mars apps are
	implemented in D.</p>


<hr><h3><a name="foreach">When should I use a foreach loop rather than a for?</a></h3>

	<p>Is it just performance or readability?
	</p>

	<p>By using foreach, you are letting the compiler decide on the
	optimization rather than worrying about it yourself. For example - are
	pointers or indices better?
	Should I cache the termination condition or not?
	Should I rotate the loop or not?
	The answers to these questions are not easy, and can vary from machine
	to machine. Like register assignment, let the compiler do the
	optimization.</p>

<pre class="d_code"><span class="d_keyword">for</span> (<span class="d_keyword">int</span> i = 0; i &lt; foo.length; i++)
</pre>

or:

<pre class="d_code"><span class="d_keyword">for</span> (<span class="d_keyword">int</span> i = 0; i &lt; foo.length; ++i)
</pre>

or:

<pre class="d_code"><span class="d_keyword">for</span> (T* p = &amp;foo[0]; p &lt; &amp;foo[length]; p++)
</pre>

or:

<pre class="d_code">T* end = &amp;foo[length];
<span class="d_keyword">for</span> (T* p = &amp;foo[0]; p &lt; pend; ++p)
</pre>

or:

<pre class="d_code">T* end = &amp;foo[length];
T* p = &amp;foo[0];
<span class="d_keyword">if</span> (p &lt; pend)
{
	<span class="d_keyword">do</span>
	{
	...
	} <span class="d_keyword">while</span> (++p &lt; end);
}
</pre>

and, of course, should I use size_t or int?

<pre class="d_code"><span class="d_keyword">for</span> (size_t i = 0; i &lt; foo.length; i++)
</pre>

Let the compiler pick!

<pre class="d_code"><span class="d_keyword">foreach</span> (v; foo)
	...
</pre>

<p>Note that we don't even need to know what the type T needs to be, thus
avoiding bugs when T changes. I don't even have to know if foo is an array, or
an associative array, or a struct, or a collection class. This will also avoid
the common fencepost bug:</p>

<pre class="d_code"><span class="d_keyword">for</span> (<span class="d_keyword">int</span> i = 0; i &lt;= foo.length; i++)
</pre>

<p>And it also avoids the need to manually create a temporary if foo is a
function call.</p>

<p>The only reason to use a for loop is if your loop does not fit in the
conventional form, like if you want to go through the array backwards, or change
the termination condition on the fly.</p>


<hr><h3><a name="call-cpp-code">Why cannot D code directly call existing C++ code?</a></h3>

	<p>There are many issues that would have to be resolved in order for D
	code to call some arbitrary C++ code that is presumed to be unmodifiable. This
	list certainly isn't complete, it's just to show the scope of the
	difficulties involved.
	</p>

	<ol>	<li>D source code is unicode, C++'s is ascii with code pages. Or not.
	It's unspecified. This impacts the contents of string literals.</li>

	<li>std::string cannot deal with multibyte UTF.</li>

	<li>C++ has a tag name space. D does not. Some sort of renaming would
	have to happen.</li>

	<li>C++ code often relies on compiler specific extensions.</li>

	<li>C++ has namespaces. D has modules. There is no obvious mapping
	between the two.</li>

	<li>C++ views source code as one gigantic file (after preprocessing). D
	sees source code as a hierarchy of modules and packages.</li>

	<li>Enum name scoping rules behave differently.</li>

	<li>C++ code, despite decades of attempts to replace macro features
	with inbuilt ones, relies more heavily than ever on layer after layer of
	arbitrary macros. There is no D analog for token pasting or
	stringizing.</li>

	<li>Macro names have global scope across #include files, but are local
	to the gigantic source files.</li>

	<li>C++ has arbitrary multiple inheritance and virtual base classes. D
	does not.</li>

	<li>C++ does not distinguish between in, out and inout parameters.</li>

	<li>The C++ name mangling varies from compiler to compiler.</li>

	<li>C++ throws exceptions of arbitrary type, not just descendants of
	Object.</li>

	<li>C++ overloads based on const and volatile. D does not.</li>

	<li>C++ overloads operators in significantly different ways - for
	example, operator[]() overloading for lvalue and rvalue is based on
	const overloading and a proxy class.</li>

	<li>C++ overloads operators like &lt; completely independently of
	&gt;.</li>

	<li>C++ overloads indirection (operator*).</li>

	<li>C++ does not distinguish between a class and a struct object.</li>

	<li>The vtbl[] location and layout is different between C++ and D.</li>

	<li>The way RTTI is done is completely different. C++ has no
	classinfo.</li>

	<li>D does not allow overloading of assignment.</li>

	<li>D does not have constructors or destructors for struct objects.</li>

	<li>D does not have two phase lookup, nor does it have Koenig (ADL)
	lookup.</li>

	<li>C++ relates classes with the 'friend' system, D uses packages and
	modules.</li>

	<li>C++ class design tends to revolve around explicit memory allocation
	issues, D's do not.</li>

	<li>D's template system is very different.</li>

	<li>C++ has 'exception specifications'.</li>

	<li>C++ has global operator overloading.</li>

	<li>C++ name mangling depends on const and volatile being type
	modifiers.
	Since D does not have const and volatile type modifiers, there is
	no straightforward way to infer the C++ mangled identifier from a D
	type.</li>

	</ol>

	<p>The bottom line is the language features affect the design of the code. C++
	designs just don't fit with D. Even if you could find a way to automatically
	adapt between the two, the result will be about as enticing as the left side of
	a honda welded to the right side of a camaro. 
	</p>

<hr><h3><a name="reference-counting">Why doesn't D use reference counting for garbage collection?</a></h3>

	<p>Reference counting has its advantages, but some severe disadvantages:
	</p>

	<ul>
	<li>cyclical data structures won't get free'd</li>

	<li>every pointer copy requires an increment and a corresponding
	decrement - including when simply passing a reference to a function</li>

	<li>in a multithreaded app, the incs and decs must be synchronized</li>

	<li>exception handlers (finally's) must be inserted to handle all the
	decs so there are no leaks. Contrary to assertions otherwise, there is
	no such thing as "zero overhead exceptions."</li>

	<li>in order to support slicing and interior pointers, as well as
	supporting reference counting on arbitrary allocations of non-object
	data, a separate "wrapper" object must be allocated for each allocation
	to be ref counted. This essentially doubles the number of allocations
	needed.</li>

	<li>The wrapper object will mean that all pointers will need to be
	double-dereferenced to access the data.</li>

	<li>Fixing the compiler to hide all this stuff from the programmer will
	make it difficult to interface cleanly with C.</li>

	<li>Ref counting can fragment the heap thereby consuming more memory
	just like the gc can, though the gc typically will consume more memory
	overall.</li>

	<li>Ref counting does not eliminated latency problems, it just reduces
	them.</li>

	</ul>

	<p>The proposed C++ shared_ptr&lt;&gt;, which implements ref counting,
	suffers from all these faults. I haven't seen a heads up benchmark of
	shared_ptr&lt;&gt; vs mark/sweep, but I wouldn't be surprised if shared_ptr&lt;&gt;
	turned out to be a significant loser in terms of both performance and
	memory consumption.
	</p>

	<p>That said, D may in the future optionally support some form of ref
	counting, as rc is better for managing scarce resources like file
	handles. 
	</p>




  
<br><br>
<br><br>
<!-- Google ad -->
<script type="text/javascript"><!--
/**/google_ad_client = "pub-5628673096434613";
/**/google_ad_width = 728;
/**/google_ad_height = 90;
/**/google_ad_format = "728x90_as";
/**/google_ad_channel ="3651639259";
/**/google_page_url = document.location;
//--></script>
<script type="text/javascript" src="../../../../../../../../pagead2.googlesyndication.com/pagead/show_ads.js">
</script>

</div>





<div id="copyright">
Copyright &copy; 1999-2006 by Digital Mars, All Rights Reserved |
Page generated by <a href="http://www.digitalmars.com/d/ddoc.html">Ddoc</a>. |
<a href="http://www.prowiki.org/wiki4d/wiki.cgi?DocComments/FAQ" title="Read/write comments and feedback">Comments</a>
</div>

</body>

<!-- Mirrored from www.shorthike.com/trac/browser/trunk/tools_win32/dmd/html/d/faq.html?format=raw by HTTrack Website Copier/3.x [XR&CO'2010], Sat, 01 May 2010 04:37:26 GMT -->
<!-- Added by HTTrack --><meta http-equiv="content-type" content="text/html;charset=UTF-8"><!-- /Added by HTTrack -->
</html>

