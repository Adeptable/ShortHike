
<!DOCTYPE html PUBLIC "-//W3C//DTD HTML 4.01//EN" "http://www.w3.org/TR/html4/strict.dtd">
<html>

<!--
	Copyright (c) 1999-2006 by Digital Mars
	All Rights Reserved
	Written by Walter Bright
	www.digitalmars.com
  -->


<!-- Mirrored from www.shorthike.com/trac/browser/trunk/tools_win32/dmd/html/d/function.html?format=raw by HTTrack Website Copier/3.x [XR&CO'2010], Sat, 01 May 2010 04:37:26 GMT -->
<!-- Added by HTTrack --><meta http-equiv="content-type" content="text/html;charset=UTF-8"><!-- /Added by HTTrack -->
<head>
<meta http-equiv="content-type" content="text/html; charset=utf-8" />
<meta name="keywords" content="D programming language" />
<meta name="description" content="D Programming Language" />
<title>D Programming Language - Functions</title>
<link rel="stylesheet" type="text/css" href="style.html" />
<link rel="shortcut icon" href="favicon.html" />
</head>

<body>
<div id="heading">
	<a href="http://www.digitalmars.com/"><img src="dmlogo.html" width="270" height="53" style="border-style:none" alt="www.digitalmars.com"></a>

	<div id="headingNav">
	<ul>	<li><a href="http://www.prowiki.org/wiki4d/wiki.cgi?DocComments/Function" title="Read/write comments and feedback">Comments</a></li>
	<li><a href="index.html" title="D Programming Language" class="dlink">D</a></li>
	<li><a href="http://www.digitalmars.com/advancedsearch.html" title="Search Digital Mars web site">Search</a></li>
	<li><a href="download.html" title="download D">Downloads</a></li>
	<li><a href="http://www.digitalmars.com/" title="www.digitalmars.com">Home</a></li>
	</ul>
	</div>

	<div id="lastupdate">Last update Tue Jun  6 16:38:20 2006
</div>
</div>

<!-- Generated by Ddoc from function.d -->



<div id="navigation">
  
<div class="navblock">
<form method="get" action="http://www.google.com/search">
<div id="searchbox">
<input id="q" name="q" size="10" value="Search" onFocus='if(this.value == "Search"){this.value="";}'>
<input type="hidden" id="domains" name="domains" value="www.digitalmars.com">
<input type="hidden" id="sitesearch" name="sitesearch" value="www.digitalmars.com/d">
<input type="hidden" id="sourceid" name="sourceid" value="google-search">
<input type="submit" id="submit" name="submit" value="Go">
</div>
</form>
<div id="toctop">
    <ul>	<li><a href="index.html" title="D Programming Language">D ...</a></li>
	<li><a href="lex.html" title="D Language Specification">Language ...</a></li>
	<li><a href="phobos/phobos.html" title="D Runtime Library">Phobos ...</a></li>
	<li><a href="comparison.html" title="Language Comparisons">Comparisons ...</a></li>
    </ul>
</div>
</div>

  
    <div class="navblock">
    <ul>	<li><a href="lex.html">Lexical</a></li>

	<li><a href="module.html">Modules</a></li>

	<li><a href="declaration.html">Declarations</a></li>

	<li><a href="type.html">Types</a></li>

	<li><a href="property.html">Properties</a></li>

	<li><a href="attribute.html">Attributes</a></li>

	<li><a href="pragma.html">Pragmas</a></li>

	<li><a href="expression.html">Expressions</a></li>

	<li><a href="statement.html">Statements</a></li>

	<li><a href="arrays.html">Arrays</a></li>

	<li><a href="struct.html">Structs &amp; Unions</a></li>

	<li><a href="class.html">Classes</a></li>

	<li><a href="interface.html">Interfaces</a></li>

	<li><a href="enum.html">Enums</a></li>

	<li><a href="function.html">Functions</a></li>

	<li><a href="operatoroverloading.html">Operator Overloading</a></li>

	<li><a href="template.html">Templates</a></li>

	<li><a href="mixin.html">Mixins</a></li>

	<li><a href="dbc.html">Contracts</a></li>

	<li><a href="version.html">Conditional Compilation</a></li>

	<li><a href="errors.html">Handling errors</a></li>

	<li><a href="garbage.html">Garbage Collection</a></li>

	<li><a href="float.html">Floating Point</a></li>

	<li><a href="iasm.html">Inline Assembler</a></li>

	<li><a href="ddoc.html">Documentation Comments</a></li>

	<li><a href="interfaceToC.html">Interfacing To C</a></li>

	<li><a href="portability.html">Portability Guide</a></li>

	<li><a href="html.html">Embedding D in HTML</a></li>

	<li><a href="entity.html">Named Character Entities</a></li>

	<li><a href="abi.html">Application Binary Interface</a></li>

    </ul>
    </div>

</div>
<div id="content">
  <h1>     Functions</h1>
  
<pre class="bnf"><i>FunctionBody</i>:
	<i>BlockStatement</i>
	<i>BodyStatement</i>
	<i>InStatement</i> <i>BodyStatement</i>
	<i>OutStatement</i> <i>BodyStatement</i>
	<i>InStatement</i> <i>OutStatement</i> <i>BodyStatement</i>
	<i>OutStatement</i> <i>InStatement</i> <i>BodyStatement</i>

<i>InStatement</i>:
	<b>in</b> <i>BlockStatement</i>

<i>OutStatement</i>:
	<b>out</b> <i>BlockStatement</i>
	<b>out</b> <b>(</b> <i>Identifier</i> <b>)</b> <i>BlockStatement</i>

<i>BodyStatement</i>:
	<b>body</b> <i>BlockStatement</i>
</pre>

<h3>Virtual Functions</h3>

	All non-static non-private member functions are virtual.
	This may sound
	inefficient, but since the D compiler knows all of the class
	hierarchy when generating code, all
	functions that are not overridden can be optimized to be non-virtual.
	In fact, since
	C++ programmers tend to "when in doubt, make it virtual", the D way of
	"make it
	virtual unless we can prove it can be made non-virtual" results on
	average much
	more direct function calls. It also results in fewer bugs caused by
	not declaring
	a function virtual that gets overridden.
	<p>

	Functions with non-D linkage cannot be virtual, and hence cannot be overridden.
	<p>

	Functions marked as <tt>final</tt> may not be overridden in a
	derived class, unless they are also <tt>private</tt>.
	For example:

<pre class="d_code"><span class="d_keyword">class</span> A
{
    <span class="d_keyword">int</span> def() { ... }
    <span class="d_keyword">final</span> <span class="d_keyword">int</span> foo() { ... }
    <span class="d_keyword">final</span> <span class="d_keyword">private</span> <span class="d_keyword">int</span> bar() { ... }
    <span class="d_keyword">private</span> <span class="d_keyword">int</span> abc() { ... }
}

<span class="d_keyword">class</span> B : A
{
    <span class="d_keyword">int</span> def() { ... }	<span class="d_comment">// ok, overrides A.def
</span>    <span class="d_keyword">int</span> foo() { ... }	<span class="d_comment">// error, A.foo is final
</span>    <span class="d_keyword">int</span> bar() { ... }	<span class="d_comment">// ok, A.bar is final private, but not virtual
</span>    <span class="d_keyword">int</span> abc() { ... }	<span class="d_comment">// ok, A.abc is not virtual, B.abc is virtual
</span>}

<span class="d_keyword">void</span> test(A a)
{
    a.def();	<span class="d_comment">// calls B.def
</span>    a.foo();	<span class="d_comment">// calls A.foo
</span>    a.bar();	<span class="d_comment">// calls A.bar
</span>    a.abc();	<span class="d_comment">// calls A.abc
</span>}

<span class="d_keyword">void</span> func()
{   B b = <span class="d_keyword">new</span> B();
    test(b);
}
</pre>

	<a name="covariant">Covariant return types</a>
	are supported, which means that the
	overriding function in a derived class can return a type
	that is derived from the type returned by the overridden function:

<pre class="d_code"><span class="d_keyword">class</span> A { }
<span class="d_keyword">class</span> B : A { }

<span class="d_keyword">class</span> Foo
{
    A test() { <span class="d_keyword">return</span> <span class="d_keyword">null</span>; }
}

<span class="d_keyword">class</span> Bar : Foo
{
    B test() { <span class="d_keyword">return</span> <span class="d_keyword">null</span>; }	<span class="d_comment">// overrides and is covariant with Foo.test()
</span>}
</pre>

<h3>Function Inheritance and Overriding</h3>

	A functions in a derived class with the same name and parameter
	types as a function in a base class overrides that function:

<pre class="d_code"><span class="d_keyword">class</span> A
{
    <span class="d_keyword">int</span> foo(<span class="d_keyword">int</span> x) { ... }
}

<span class="d_keyword">class</span> B : A
{
    <span class="d_keyword">override</span> <span class="d_keyword">int</span> foo(<span class="d_keyword">int</span> x) { ... }
}

<span class="d_keyword">void</span> test()
{
    B b = <span class="d_keyword">new</span> B();
    bar(b);
}

<span class="d_keyword">void</span> bar(A a)
{
    a.foo();	<span class="d_comment">// calls B.foo(int)
</span>}
</pre>

	However, when doing overload resolution, the functions in the base
	class are not considered:

<pre class="d_code"><span class="d_keyword">class</span> A
{
    <span class="d_keyword">int</span> foo(<span class="d_keyword">int</span> x) { ... }
    <span class="d_keyword">int</span> foo(<span class="d_keyword">long</span> y) { ... }
}

<span class="d_keyword">class</span> B : A
{
    <span class="d_keyword">override</span> <span class="d_keyword">int</span> foo(<span class="d_keyword">long</span> x) { ... }
}

<span class="d_keyword">void</span> test()
{
    B b = <span class="d_keyword">new</span> B();
    b.foo(1);		<span class="d_comment">// calls B.foo(long), since A.foo(int) not considered
</span>    A a = b;
    a.foo(1);		<span class="d_comment">// calls A.foo(int)
</span>}
</pre>

	To consider the base class's functions in the overload resolution
	process, use an <i>AliasDeclaration</i>:

<pre class="d_code"><span class="d_keyword">class</span> A
{
    <span class="d_keyword">int</span> foo(<span class="d_keyword">int</span> x) { ... }
    <span class="d_keyword">int</span> foo(<span class="d_keyword">long</span> y) { ... }
}

<span class="d_keyword">class</span> B : A
{
    <b><span class="d_keyword">alias</span> A.foo foo;</b>
    <span class="d_keyword">override</span> <span class="d_keyword">int</span> foo(<span class="d_keyword">long</span> x) { ... }
}

<span class="d_keyword">void</span> test()
{
    B b = <span class="d_keyword">new</span> B();
    bar(b);
}

<span class="d_keyword">void</span> bar(A a)
{
    a.foo(1);		<span class="d_comment">// calls A.foo(int)
</span>    B b = <span class="d_keyword">new</span> B();
    b.foo(1);		<span class="d_comment">// calls A.foo(int)
</span>}
</pre>

	A function parameter's default value is not inherited:

<pre class="d_code"><span class="d_keyword">class</span> A
{
    <span class="d_keyword">void</span> foo(<span class="d_keyword">int</span> <b>x = 5</b>) { ... }
}

<span class="d_keyword">class</span> B : A
{
    <span class="d_keyword">void</span> foo(<span class="d_keyword">int</span> <b>x = 7</b>) { ... }
}

<span class="d_keyword">class</span> C : B
{
    <span class="d_keyword">void</span> foo(<span class="d_keyword">int</span> <b>x</b>) { ... }
}


<span class="d_keyword">void</span> test()
{
    A a = <span class="d_keyword">new</span> A();
    a.foo();		<span class="d_comment">// calls A.foo(5)
</span>
    B b = <span class="d_keyword">new</span> B();
    b.foo();		<span class="d_comment">// calls B.foo(7)
</span>
    C c = <span class="d_keyword">new</span> C();
    c.foo();		<span class="d_comment">// error, need an argument for C.foo
</span>}
</pre>


<h3>Inline Functions</h3>

	There is no inline keyword. The compiler makes the decision whether to 
	inline a function or not, analogously to the register keyword no
	longer being relevant to a 
	compiler's decisions on enregistering variables.
	(There is no register keyword either.)


<a name="overloading"><h3>Function Overloading</h3></a>

	In C++, there are many complex levels of function overloading, with
	some defined as "better" matches than others. If the code designer
	takes advantage of the more subtle 
	behaviors of overload function selection, the code can become
	difficult to maintain. Not 
	only will it take a C++ expert to understand why one function is
	selected over another, but different C++ compilers can implement
	this tricky feature differently, producing 
	subtly disastrous results.
	<p>

	In D, function overloading is simple. It matches exactly, it matches with 
	implicit conversions, or it does not match. If there is more than one match, it is an error.
	<p>

	Functions defined with non-D linkage cannot be overloaded.

<a name="parameters"><h3>Function Parameters</h3></a>

	Parameters are <b>in</b>, <b>out</b>, or <b>inout</b>.
	<b>in</b> is the default; <b>out</b> and <b>inout</b> work like 
	storage classes. For example:

<pre class="d_code"><span class="d_keyword">int</span> foo(<span class="d_keyword">int</span> x, <span class="d_keyword">out</span> <span class="d_keyword">int</span> y, <span class="d_keyword">inout</span> <span class="d_keyword">int</span> z, <span class="d_keyword">int</span> q);
</pre>

	x is <b>in</b>, y is <b>out</b>, z is <b>inout</b>, and q is <b>in</b>.
	<p>

	<b>out</b> is rare enough, and <b>inout</b> even rarer, to
	attach the keywords to
	them and leave <b>in</b> as 
	the default. The reasons to have them are:

	<ul>
	<li> The function declaration makes it clear what the inputs and
	outputs to the function 
	are.
	<li> It eliminates the need for IDL as a separate language.
	<li> It provides more information to the compiler, enabling more
	error checking and 
	possibly better code generation.
	<li> It (perhaps?) eliminates the need for reference (&amp;) declarations.
	</ul>

	<b>out</b> parameters are set to the default initializer for the
	type of it. For example:

<pre class="d_code"><span class="d_keyword">void</span> foo(<span class="d_keyword">out</span> <span class="d_keyword">int</span> bar)
{
}

<span class="d_keyword">int</span> bar = 3;
foo(bar);
<span class="d_comment">// bar is now 0
</span></pre>


<a name="variadic"><h2>Variadic Functions</h2></a>

	Functions taking a variable number of arguments are called
	variadic functions. A variadic function can take one of
	three forms:

	<ol>
	<li> C-style variadic functions
	<li> Variadic functions with type info
	<li> Typesafe variadic functions
	</ol>


<h3>C-style Variadic Functions</h3>

	A C-style variadic function is declared as taking
	a parameter of ... after the required function parameters.
	It has non-D linkage, such as <tt>extern (C)</tt>:

<pre class="d_code"><span class="d_keyword">extern</span> (C) <span class="d_keyword">int</span> foo(<span class="d_keyword">int</span> x, <span class="d_keyword">int</span> y, ...);

foo(3, 4);	<span class="d_comment">// ok
</span>foo(3, 4, 6.8);	<span class="d_comment">// ok, one variadic argument
</span>foo(2);		<span class="d_comment">// error, y is a required argument
</span></pre>

	There must have at least one non-variadic parameter declared.

<pre class="d_code"><span class="d_keyword">extern</span> (C) <span class="d_keyword">int</span> def(...); <span class="d_comment">// error, must have at least one parameter
</span></pre>

	This kind of function matches the C calling convention for
	variadic functions, and is most useful for calling C library
	functions like <tt>printf</tt>.

	The implementiations of these variadic functions have a special
	local variable declared for them,
	<b>_argptr</b>, which is a <tt>void*</tt> pointer to the first of the
	variadic
	arguments. To access the arguments, <b>_argptr</b> must be cast
	to a pointer to the expected argument type:

<pre class="d_code">foo(3, 4, 5);	<span class="d_comment">// first variadic argument is 5
</span>
<span class="d_keyword">int</span> foo(<span class="d_keyword">int</span> x, <span class="d_keyword">int</span> y, ...)
{   <span class="d_keyword">int</span> z;

    z = *<span class="d_keyword">cast</span>(<span class="d_keyword">int</span>*)<b>_argptr</b>;	<span class="d_comment">// z is set to 5
</span>}
</pre>

	To protect against the vagaries of stack layouts on different
	CPU architectures, use <b>std.c.stdarg</b> to access the variadic
	arguments:

<pre class="d_code"><span class="d_keyword">import</span> <b>std.c.stdarg</b>;
</pre>

<h3>Variadic Functions With Type Info</h3>

	Variadic functions with argument and type info are declared as taking
	a parameter of ... after the required function parameters.
	It has D linkage, and need not have any non-variadic parameters
	declared:

<pre class="d_code"><span class="d_keyword">int</span> abc(<span class="d_keyword">char</span> c, ...);	<span class="d_comment">// one required parameter: c
</span><span class="d_keyword">int</span> def(...);		<span class="d_comment">// ok
</span></pre>

	These variadic functions have a special local variable declared for
	them,
	<b>_argptr</b>, which is a <tt>void*</tt> pointer to the first of the
	variadic
	arguments. To access the arguments, <b>_argptr</b> must be cast
	to a pointer to the expected argument type:

<pre class="d_code">foo(3, 4, 5);	<span class="d_comment">// first variadic argument is 5
</span>
<span class="d_keyword">int</span> foo(<span class="d_keyword">int</span> x, <span class="d_keyword">int</span> y, ...)
{   <span class="d_keyword">int</span> z;

    z = *<span class="d_keyword">cast</span>(<span class="d_keyword">int</span>*)<b>_argptr</b>;	<span class="d_comment">// z is set to 5
</span>}
</pre>

	An additional hidden argument
	with the name <b>_arguments</b></tt> and type <tt>TypeInfo[]</tt>
	is passed to the function.
	<b>_arguments</b> gives the number of arguments and the type
	of each, enabling the creation of typesafe variadic functions.

<pre class="d_code"><span class="d_keyword">class</span> FOO { }

<span class="d_keyword">void</span> foo(<span class="d_keyword">int</span> x, ...)
{
    printf(<span class="d_string">"%d arguments\n"</span>, <b>_arguments</b>.length);
    <span class="d_keyword">for</span> (<span class="d_keyword">int</span> i = 0; i &lt; <b>_arguments</b>.length; i++)
    {   <b>_arguments</b>[i].print();

	<span class="d_keyword">if</span> (<b>_arguments</b>[i] == <span class="d_keyword">typeid</span>(<span class="d_keyword">int</span>))
	{
	    <span class="d_keyword">int</span> j = *<span class="d_keyword">cast</span>(<span class="d_keyword">int</span> *)<b>_argptr</b>;
	    <b>_argptr</b> += <span class="d_keyword">int</span>.sizeof;
	    printf(<span class="d_string">"\t%d\n"</span>, j);
	}
	<span class="d_keyword">else</span> <span class="d_keyword">if</span> (<b>_arguments</b>[i] == <span class="d_keyword">typeid</span>(<span class="d_keyword">long</span>))
	{
	    <span class="d_keyword">long</span> j = *<span class="d_keyword">cast</span>(<span class="d_keyword">long</span> *)<b>_argptr</b>;
	    <b>_argptr</b> += <span class="d_keyword">long</span>.sizeof;
	    printf(<span class="d_string">"\t%lld\n"</span>, j);
	}
	<span class="d_keyword">else</span> <span class="d_keyword">if</span> (<b>_arguments</b>[i] == <span class="d_keyword">typeid</span>(<span class="d_keyword">double</span>))
	{
	    <span class="d_keyword">double</span> d = *<span class="d_keyword">cast</span>(<span class="d_keyword">double</span> *)<b>_argptr</b>;
	    <b>_argptr</b> += <span class="d_keyword">double</span>.sizeof;
	    printf(<span class="d_string">"\t%g\n"</span>, d);
	}
	<span class="d_keyword">else</span> <span class="d_keyword">if</span> (<b>_arguments</b>[i] == <span class="d_keyword">typeid</span>(FOO))
	{
	    FOO f = *<span class="d_keyword">cast</span>(FOO*)<b>_argptr</b>;
	    <b>_argptr</b> += FOO.sizeof;
	    printf(<span class="d_string">"\t%p\n"</span>, f);
	}
	<span class="d_keyword">else</span>
	    <span class="d_keyword">assert</span>(0);
    }
}

<span class="d_keyword">void</span> main()
{
    FOO f = <span class="d_keyword">new</span> FOO();

    printf(<span class="d_string">"%p\n"</span>, f);
    foo(1, 2, 3L, 4.5, f);
}
</pre>

	which prints:

<pre class="d_code">00870FD0
4 arguments
<span class="d_keyword">int</span>
	2
<span class="d_keyword">long</span>
	3
<span class="d_keyword">double</span>
	4.5
FOO
	00870FD0
</pre>

	To protect against the vagaries of stack layouts on different
	CPU architectures, use <b>std.stdarg</b> to access the variadic
	arguments:

<pre class="d_code"><span class="d_keyword">import</span> <b>std.stdarg</b>;

<span class="d_keyword">void</span> foo(<span class="d_keyword">int</span> x, ...)
{
    printf(<span class="d_string">"%d arguments\n"</span>, _arguments.length);
    <span class="d_keyword">for</span> (<span class="d_keyword">int</span> i = 0; i &lt; _arguments.length; i++)
    {   _arguments[i].print();

	<span class="d_keyword">if</span> (_arguments[i] == <span class="d_keyword">typeid</span>(<span class="d_keyword">int</span>))
	{
	    <span class="d_keyword">int</span> j = <b>va_arg</b>!(<span class="d_keyword">int</span>)(_argptr);
	    printf(<span class="d_string">"\t%d\n"</span>, j);
	}
	<span class="d_keyword">else</span> <span class="d_keyword">if</span> (_arguments[i] == <span class="d_keyword">typeid</span>(<span class="d_keyword">long</span>))
	{
	    <span class="d_keyword">long</span> j = <b>va_arg</b>!(<span class="d_keyword">long</span>)(_argptr);
	    printf(<span class="d_string">"\t%lld\n"</span>, j);
	}
	<span class="d_keyword">else</span> <span class="d_keyword">if</span> (_arguments[i] == <span class="d_keyword">typeid</span>(<span class="d_keyword">double</span>))
	{
	    <span class="d_keyword">double</span> d = <b>va_arg</b>!(<span class="d_keyword">double</span>)(_argptr);
	    printf(<span class="d_string">"\t%g\n"</span>, d);
	}
	<span class="d_keyword">else</span> <span class="d_keyword">if</span> (_arguments[i] == <span class="d_keyword">typeid</span>(FOO))
	{
	    FOO f = <b>va_arg</b>!(FOO)(_argptr);
	    printf(<span class="d_string">"\t%p\n"</span>, f);
	}
	<span class="d_keyword">else</span>
	    <span class="d_keyword">assert</span>(0);
    }
}
</pre>

<h3>Typesafe Variadic Functions</h3>

	Typesafe variadic functions are used when the variable argument
	portion of the arguments are used to construct an array or
	class object.
	<p>

	For arrays:

<pre class="d_code"><span class="d_keyword">int</span> test()
{
    <span class="d_keyword">return</span> sum(1, 2, 3) + sum(); <span class="d_comment">// returns 6+0
</span>}

<span class="d_keyword">int</span> func()
{
    <span class="d_keyword">static</span> <span class="d_keyword">int</span>[3] ii = [4, 5, 6];
    <span class="d_keyword">return</span> sum(ii);		<span class="d_comment">// returns 15
</span>}

<span class="d_keyword">int</span> sum(<span class="d_keyword">int</span>[] ar ...)
{
    <span class="d_keyword">int</span> s;
    <span class="d_keyword">foreach</span> (<span class="d_keyword">int</span> x; ar)
	s += x;
    <span class="d_keyword">return</span> s;
}
</pre>

	For static arrays:

<pre class="d_code"><span class="d_keyword">int</span> test()
{
    <span class="d_keyword">return</span> sum(2, 3);	<span class="d_comment">// error, need 3 values for array
</span>    <span class="d_keyword">return</span> sum(1, 2, 3); <span class="d_comment">// returns 6
</span>}

<span class="d_keyword">int</span> func()
{
    <span class="d_keyword">static</span> <span class="d_keyword">int</span>[3] ii = [4, 5, 6];
    <span class="d_keyword">int</span>[] jj = ii;
    <span class="d_keyword">return</span> sum(ii);		<span class="d_comment">// returns 15
</span>    <span class="d_keyword">return</span> sum(jj);		<span class="d_comment">// error, type mismatch
</span>}

<span class="d_keyword">int</span> sum(<span class="d_keyword">int</span>[3] ar ...)
{
    <span class="d_keyword">int</span> s;
    <span class="d_keyword">foreach</span> (<span class="d_keyword">int</span> x; ar)
	s += x;
    <span class="d_keyword">return</span> s;
}
</pre>

	For class objects:

<pre class="d_code"><span class="d_keyword">class</span> Foo { <span class="d_keyword">int</span> x; <span class="d_keyword">char</span>[] s; }

<span class="d_keyword">void</span> test(<span class="d_keyword">int</span> x, Foo f ...);

...

Foo g = <span class="d_keyword">new</span> Foo(3, <span class="d_string">"abc"</span>);
test(1, g);		<span class="d_comment">// ok, since g is an instance of Foo
</span>test(1, 4, <span class="d_string">"def"</span>);	<span class="d_comment">// ok
</span>test(1, 5);		<span class="d_comment">// error, no matching constructor for Foo
</span></pre>

	An implementation may construct the object or array instance
	on the stack. Therefore, it is an error to refer to that
	instance after the variadic function has returned:

<pre class="d_code">Foo test(Foo f ...)
{
    <span class="d_keyword">return</span> f;	<span class="d_comment">// error, f instance contents invalid after return
</span>}

<span class="d_keyword">int</span>[] test(<span class="d_keyword">int</span>[] a ...)
{
    <span class="d_keyword">return</span> a;		<span class="d_comment">// error, array contents invalid after return
</span>    <span class="d_keyword">return</span> a[0..1];	<span class="d_comment">// error, array contents invalid after return
</span>    <span class="d_keyword">return</span> a.dup;	<span class="d_comment">// ok, since copy is made
</span>}
</pre>

	For other types, the argument is built with itself, as in:

<pre class="d_code"><span class="d_keyword">int</span> test(<span class="d_keyword">int</span> i ...)
{
    <span class="d_keyword">return</span> i;
}

...
test(3);	<span class="d_comment">// returns 3
</span>test(3, 4);	<span class="d_comment">// error, too many arguments
</span><span class="d_keyword">int</span>[] x;
test(x);	<span class="d_comment">// error, type mismatch
</span></pre>

<h2>Local Variables</h2>

	It is an error to use a local variable without first assigning it a
	value. The implementation may not always be able to detect these
	cases. Other language compilers sometimes issue a warning for this,
	but since it is always a bug, it should be an error.
	<p>

	It is an error to declare a local variable that is never referred to.
	Dead variables, like anachronistic dead code, is just a source of
	confusion for maintenance programmers.
	<p>

	It is an error to declare a local variable that hides another local
	variable in the same function:

<pre class="d_code"><span class="d_keyword">void</span> func(<span class="d_keyword">int</span> x)
{   <span class="d_keyword">int</span> x;		error, hides previous definition of x
     <span class="d_keyword">double</span> y;
     ...
     {   <span class="d_keyword">char</span> y;	error, hides previous definition of y
	  <span class="d_keyword">int</span> z;
     }
     {   <span class="d_keyword">wchar</span> z;	legal, previous z <span class="d_keyword">is</span> <span class="d_keyword">out</span> of <span class="d_keyword">scope</span>
     }
}
</pre>

	While this might look unreasonable, in practice whenever
	this is done it either is a 
	bug or at least looks like a bug.
	<p>

	It is an error to return the address of or a reference to a
	local variable.
	<p>

	It is an error to have a local variable and a label with the same name.

<a name="nested"><h2>Nested Functions</h2></a>

	Functions may be nested within other functions:

<pre class="d_code"><span class="d_keyword">int</span> bar(<span class="d_keyword">int</span> a)
{
    <span class="d_keyword">int</span> foo(<span class="d_keyword">int</span> b)
    {
	<span class="d_keyword">int</span> abc() { <span class="d_keyword">return</span> 1; }

	<span class="d_keyword">return</span> b + abc();
    }
    <span class="d_keyword">return</span> foo(a);
}

<span class="d_keyword">void</span> test()
{
    <span class="d_keyword">int</span> i = bar(3);	<span class="d_comment">// i is assigned 4
</span>}
</pre>

	Nested functions can be accessed only if the name is in scope.
<pre class="d_code"><span class="d_keyword">void</span> foo()
{
   <span class="d_keyword">void</span> A()
   {
     B();   <span class="d_comment">// ok
</span>     C();   <span class="d_comment">// error, C undefined
</span>   }
   <span class="d_keyword">void</span> B()
   {
       <span class="d_keyword">void</span> C()
       {
           <span class="d_keyword">void</span> D()
           {
               A();      <span class="d_comment">// ok
</span>               B();      <span class="d_comment">// ok
</span>               C();      <span class="d_comment">// ok
</span>               D();      <span class="d_comment">// ok
</span>           }
       }
   }
   A(); <span class="d_comment">// ok
</span>   B(); <span class="d_comment">// ok
</span>   C(); <span class="d_comment">// error, C undefined
</span>}
</pre>

	and:

<pre class="d_code"><span class="d_keyword">int</span> bar(<span class="d_keyword">int</span> a)
{
    <span class="d_keyword">int</span> foo(<span class="d_keyword">int</span> b) { <span class="d_keyword">return</span> b + 1; }
    <span class="d_keyword">int</span> abc(<span class="d_keyword">int</span> b) { <span class="d_keyword">return</span> foo(b); }	<span class="d_comment">// ok
</span>    <span class="d_keyword">return</span> foo(a);
}

<span class="d_keyword">void</span> test()
{
    <span class="d_keyword">int</span> i = bar(3);	<span class="d_comment">// ok
</span>    <span class="d_keyword">int</span> j = bar.foo(3);	<span class="d_comment">// error, bar.foo not visible
</span>}
</pre>

	Nested functions have access to the variables and other symbols
	defined by the lexically enclosing function.
	This access includes both the ability to read and write them.

<pre class="d_code"><span class="d_keyword">int</span> bar(<span class="d_keyword">int</span> a)
{   <span class="d_keyword">int</span> c = 3;

    <span class="d_keyword">int</span> foo(<span class="d_keyword">int</span> b)
    {
	b += c;		<span class="d_comment">// 4 is added to b
</span>	c++;		<span class="d_comment">// bar.c is now 5
</span>	<span class="d_keyword">return</span> b + c;	<span class="d_comment">// 12 is returned
</span>    }
    c = 4;
    <span class="d_keyword">int</span> i = foo(a);	<span class="d_comment">// i is set to 12
</span>    <span class="d_keyword">return</span> i + c;	<span class="d_comment">// returns 17
</span>}

<span class="d_keyword">void</span> test()
{
    <span class="d_keyword">int</span> i = bar(3);	<span class="d_comment">// i is assigned 17
</span>}
</pre>

	This access can span multiple nesting levels:

<pre class="d_code"><span class="d_keyword">int</span> bar(<span class="d_keyword">int</span> a)
{   <span class="d_keyword">int</span> c = 3;

    <span class="d_keyword">int</span> foo(<span class="d_keyword">int</span> b)
    {
	<span class="d_keyword">int</span> abc()
	{
	    <span class="d_keyword">return</span> c;	<span class="d_comment">// access bar.c
</span>	}
	<span class="d_keyword">return</span> b + c + abc();
    }
    <span class="d_keyword">return</span> foo(3);
}
</pre>

	Static nested functions cannot access any stack variables of
	any lexically enclosing function, but can access static variables.
	This is analogous to how static member functions behave.

<pre class="d_code"><span class="d_keyword">int</span> bar(<span class="d_keyword">int</span> a)
{   <span class="d_keyword">int</span> c;
    <span class="d_keyword">static</span> <span class="d_keyword">int</span> d;

    <span class="d_keyword">static</span> <span class="d_keyword">int</span> foo(<span class="d_keyword">int</span> b)
    {
	b = d;		<span class="d_comment">// ok
</span>	b = c;		<span class="d_comment">// error, foo() cannot access frame of bar()
</span>	<span class="d_keyword">return</span> b + 1;
    }
    <span class="d_keyword">return</span> foo(a);
}
</pre>

	Functions can be nested within member functions:

<pre class="d_code"><span class="d_keyword">struct</span> Foo
{   <span class="d_keyword">int</span> a;

    <span class="d_keyword">int</span> bar()
    {   <span class="d_keyword">int</span> c;

	<span class="d_keyword">int</span> foo()
	{
	    <span class="d_keyword">return</span> c + a;
	}
    }
}
</pre>

	Member functions of nested classes and structs do not have
	access to the stack variables of the enclosing function, but
	do have access to the other symbols:

<pre class="d_code"><span class="d_keyword">void</span> test()
{   <span class="d_keyword">int</span> j;
    <span class="d_keyword">static</span> <span class="d_keyword">int</span> s;

    <span class="d_keyword">struct</span> Foo
    {   <span class="d_keyword">int</span> a;

	<span class="d_keyword">int</span> bar()
	{   <span class="d_keyword">int</span> c = s;		<span class="d_comment">// ok, s is static
</span>	    <span class="d_keyword">int</span> d = j;		<span class="d_comment">// error, no access to frame of test()
</span>
	    <span class="d_keyword">int</span> foo()
	    {
		<span class="d_keyword">int</span> e = s;	<span class="d_comment">// ok, s is static
</span>		<span class="d_keyword">int</span> f = j;	<span class="d_comment">// error, no access to frame of test()
</span>		<span class="d_keyword">return</span> c + a;	<span class="d_comment">// ok, frame of bar() is accessible,
</span>				<span class="d_comment">// so are members of Foo accessible via
</span>				<span class="d_comment">// the 'this' pointer to Foo.bar()
</span>	    }
	}
    }
}
</pre>

	Nested functions always have the D function linkage type.
	<p>

	Unlike module level declarations, declarations within function
	scope are processed in order. This means that two nested functions
	cannot mutually call each other:

<pre class="d_code"><span class="d_keyword">void</span> test()
{
    <span class="d_keyword">void</span> foo() { bar(); }	<span class="d_comment">// error, bar not defined
</span>    <span class="d_keyword">void</span> bar() { foo(); }	<span class="d_comment">// ok
</span>}
</pre>

	The solution is to use a delegate:

<pre class="d_code"><span class="d_keyword">void</span> test()
{
    <span class="d_keyword">void</span> <span class="d_keyword">delegate</span>() fp;
    <span class="d_keyword">void</span> foo() { fp(); }
    <span class="d_keyword">void</span> bar() { foo(); }
    fp = &amp;bar;
}
</pre>

	<b>Future directions:</b> This restriction may be removed.


<a name="closures"><h3>Delegates, Function Pointers, and Dynamic Closures</h3></a>

	A function pointer can point to a static nested function:

<pre class="d_code"><span class="d_keyword">int</span> <span class="d_keyword">function</span>() fp;

<span class="d_keyword">void</span> test()
{   <span class="d_keyword">static</span> <span class="d_keyword">int</span> a = 7;
    <span class="d_keyword">static</span> <span class="d_keyword">int</span> foo() { <span class="d_keyword">return</span> a + 3; }

    fp = &amp;foo;
}

<span class="d_keyword">void</span> bar()
{
    test();
    <span class="d_keyword">int</span> i = fp();	<span class="d_comment">// i is set to 10
</span>}
</pre>

	A delegate can be set to a non-static nested function:

<pre class="d_code"><span class="d_keyword">int</span> <span class="d_keyword">delegate</span>() dg;

<span class="d_keyword">void</span> test()
{   <span class="d_keyword">int</span> a = 7;
    <span class="d_keyword">int</span> foo() { <span class="d_keyword">return</span> a + 3; }

    dg = &amp;foo;
    <span class="d_keyword">int</span> i = dg();	<span class="d_comment">// i is set to 10
</span>}
</pre>

	The stack variables, however, are not valid once the function
	declaring them has exited, in the same manner that pointers to
	stack variables are not valid upon exit from a function:

<pre class="d_code"><span class="d_keyword">int</span>* bar()
{   <span class="d_keyword">int</span> b;
    test();
    <span class="d_keyword">int</span> i = dg();	<span class="d_comment">// error, test.a no longer exists
</span>    <span class="d_keyword">return</span> &amp;b;		<span class="d_comment">// error, bar.b not valid after bar() exits
</span>}
</pre>

	Delegates to non-static nested functions contain two pieces of
	data: the pointer to the stack frame of the lexically enclosing
	function (called the <i>frame pointer</i>) and the address of the
	function. This is analogous to struct/class non-static member
	function delegates consisting of a <i>this</i> pointer and
	the address of the member function.
	Both forms of delegates are interchangeable, and are actually
	the same type:

<pre class="d_code"><span class="d_keyword">struct</span> Foo
{   <span class="d_keyword">int</span> a = 7;
    <span class="d_keyword">int</span> bar() { <span class="d_keyword">return</span> a; }
}

<span class="d_keyword">int</span> foo(<span class="d_keyword">int</span> <span class="d_keyword">delegate</span>() dg)
{
    <span class="d_keyword">return</span> dg() + 1;
}

<span class="d_keyword">void</span> test()
{
    <span class="d_keyword">int</span> x = 27;
    <span class="d_keyword">int</span> abc() { <span class="d_keyword">return</span> x; }
    Foo f;
    <span class="d_keyword">int</span> i;

    i = foo(&amp;abc);	<span class="d_comment">// i is set to 28
</span>    i = foo(&amp;f.bar);	<span class="d_comment">// i is set to 8
</span>}
</pre>

	This combining of the environment and the function is called
	a <i>dynamic closure</i>.
	<p>

	<b>Future directions:</b> Function pointers and delegates may merge
	into a common syntax and be interchangeable with each other.

<h3>Anonymous Functions and Anonymous Delegates</h3>

	See <a href="expression.html#FunctionLiteral">Function Literals</a>.


<h2>main() Function</h2>

	For console programs, <tt>main()</tt> serves as the entry point.
	It gets called after all the module initializers are run, and
	after any unittests are run.
	After it returns, all the module destructors are run.
	<tt>main()</tt> must be declared using one of the following forms:

<pre class="d_code"><span class="d_keyword">void</span> main() { ... }
<span class="d_keyword">void</span> main(<span class="d_keyword">char</span>[][] args) { ... }
<span class="d_keyword">int</span> main() { ... }
<span class="d_keyword">int</span> main(<span class="d_keyword">char</span>[][] args) { ... }
</pre>


  
<br><br>
<br><br>
<!-- Google ad -->
<script type="text/javascript"><!--
/**/google_ad_client = "pub-5628673096434613";
/**/google_ad_width = 728;
/**/google_ad_height = 90;
/**/google_ad_format = "728x90_as";
/**/google_ad_channel ="3651639259";
/**/google_page_url = document.location;
//--></script>
<script type="text/javascript" src="../../../../../../../../pagead2.googlesyndication.com/pagead/show_ads.js">
</script>

</div>





<div id="copyright">
Copyright &copy; 1999-2006 by Digital Mars, All Rights Reserved |
Page generated by <a href="http://www.digitalmars.com/d/ddoc.html">Ddoc</a>. |
<a href="http://www.prowiki.org/wiki4d/wiki.cgi?DocComments/Function" title="Read/write comments and feedback">Comments</a>
</div>

</body>

<!-- Mirrored from www.shorthike.com/trac/browser/trunk/tools_win32/dmd/html/d/function.html?format=raw by HTTrack Website Copier/3.x [XR&CO'2010], Sat, 01 May 2010 04:37:26 GMT -->
<!-- Added by HTTrack --><meta http-equiv="content-type" content="text/html;charset=UTF-8"><!-- /Added by HTTrack -->
</html>

