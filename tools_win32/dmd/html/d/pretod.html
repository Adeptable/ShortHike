
<!DOCTYPE html PUBLIC "-//W3C//DTD HTML 4.01//EN" "http://www.w3.org/TR/html4/strict.dtd">
<html>

<!--
	Copyright (c) 1999-2006 by Digital Mars
	All Rights Reserved
	Written by Walter Bright
	www.digitalmars.com
  -->


<!-- Mirrored from www.shorthike.com/trac/browser/trunk/tools_win32/dmd/html/d/pretod.html?format=raw by HTTrack Website Copier/3.x [XR&CO'2010], Sat, 01 May 2010 04:37:48 GMT -->
<!-- Added by HTTrack --><meta http-equiv="content-type" content="text/html;charset=UTF-8"><!-- /Added by HTTrack -->
<head>
<meta http-equiv="content-type" content="text/html; charset=utf-8" />
<meta name="keywords" content="D programming language" />
<meta name="description" content="D Programming Language" />
<title>Digital Mars - The C Preprocessor vs D</title>
<link rel="stylesheet" type="text/css" href="style.html" />
<link rel="shortcut icon" href="favicon.html" />
</head>

<body>
<div id="heading">
	<a href="http://www.digitalmars.com/"><img src="dmlogo.html" width="270" height="53" style="border-style:none" alt="www.digitalmars.com"></a>

	<div id="headingNav">
	<ul>	<li><a href="http://www.prowiki.org/wiki4d/wiki.cgi?DocComments/PreToD" title="Read/write comments and feedback">Comments</a></li>
	<li><a href="index.html" title="D Programming Language" class="dlink">D</a></li>
	<li><a href="http://www.digitalmars.com/advancedsearch.html" title="Search Digital Mars web site">Search</a></li>
	<li><a href="download.html" title="download D">Downloads</a></li>
	<li><a href="http://www.digitalmars.com/" title="www.digitalmars.com">Home</a></li>
	</ul>
	</div>

	<div id="lastupdate">Last update Tue Jun 13 16:04:02 2006
</div>
</div>

<!-- Generated by Ddoc from pretod.d -->



<div id="navigation">
  
<div class="navblock">
<form method="get" action="http://www.google.com/search">
<div id="searchbox">
<input id="q" name="q" size="10" value="Search" onFocus='if(this.value == "Search"){this.value="";}'>
<input type="hidden" id="domains" name="domains" value="www.digitalmars.com">
<input type="hidden" id="sitesearch" name="sitesearch" value="www.digitalmars.com/d">
<input type="hidden" id="sourceid" name="sourceid" value="google-search">
<input type="submit" id="submit" name="submit" value="Go">
</div>
</form>
<div id="toctop">
    <ul>	<li><a href="index.html" title="D Programming Language">D ...</a></li>
	<li><a href="lex.html" title="D Language Specification">Language ...</a></li>
	<li><a href="phobos/phobos.html" title="D Runtime Library">Phobos ...</a></li>
	<li><a href="comparison.html" title="Language Comparisons">Comparisons ...</a></li>
    </ul>
</div>
</div>

  
    <div class="navblock">
    <ul>	<li><a href="comparison.html">D vs C/C++/C#/Java</a></li>

	<li><a href="builtin.html">   Rationale for Builtins</a></li>

	<li><a href="ctod.html">      Converting C to D</a></li>

	<li><a href="cpptod.html">    Converting C++ to D</a></li>

	<li><a href="pretod.html">The C Preprocessor vs D</a></li>

	<li><a href="cppstrings.html">D strings vs C++ std::string</a></li>

	<li><a href="cppcomplex.html">D complex vs C++ std::complex</a></li>

	<li><a href="cppdbc.html">    D Contract Programming vs C++</a></li>

    </ul>
    </div>

</div>
<div id="content">
  <h1>The C Preprocessor Versus D</h1>
  
	Back when C was invented, compiler technology was primitive.
	Installing a text
	macro preprocessor onto the front end was a straightforward
	and easy way to add many
	powerful features. The increasing size &amp; complexity of programs
	have illustrated
	that these features come with many inherent problems.
	D doesn't have a preprocessor; but
	D provides a more scalable means to solve the same problems.

<ul>
	<li><a href="#headerfiles">Header Files</a>
	<li><a href="#pragmaonce">#pragma once</a>
	<li><a href="#pragmapack">#pragma pack</a>
	<li><a href="#macros">Macros</a>
	<li><a href="#conditionalcompilation">Conditional Compilation</a>
	<li><a href="#codefactoring">Code Factoring</a>
	<li><a href="#staticassert">#error and Static Asserts</a>
	<li><a href="#mixins">Mixins</a>
</ul>

<hr><!-- -------------------------------------------- -->
<h3><a name="headerfiles">Header Files</a></h3>

<h4>The C Preprocessor Way</h4>

	C and C++ rely heavily on textual inclusion of header files.
	This frequently results in the compiler having to recompile tens of thousands
	of lines of code over and over again for every source file, an obvious
	source of slow compile times. What header files are normally used for is
	more appropriately done doing a symbolic, rather than textual, insertion.
	This is done with the import statement. Symbolic inclusion means the compiler
	just loads an already compiled symbol table. The needs for macro "wrappers" to
	prevent multiple #inclusion, funky #pragma once syntax, and incomprehensible
	fragile syntax for precompiled headers are simply unnecessary and irrelevant to 
	D.

<pre class="ccode">#include &lt;stdio.h&gt;
</pre>

<h4>The D Way</h4>

	D uses symbolic imports:

<pre class="d_code"><span class="d_keyword">import</span> std.c.stdio;
</pre>

<hr><!-- -------------------------------------------- -->
<h3><a name="pragmaonce">#pragma once</a></h3>

<h4>The C Preprocessor Way</h4>

	C header files frequently need to be protected against
	being #include'd multiple times.
	To do it, a header file will contain the line:

<pre class="ccode">#pragma once
</pre>

	or the more portable:

<pre class="ccode">#ifndef __STDIO_INCLUDE
#define __STDIO_INCLUDE
... header file contents
#endif
</pre>

<h4>The D Way</h4>

	Completely unnecessary since D does a symbolic include of import
	files; they only get imported once no matter how many times
	the import declaration appears.

<hr><!-- -------------------------------------------- -->
<h3><a name="pragmapack">#pragma pack</a></h3>

<h4>The C Preprocessor Way</h4>

	This is used in C to adjust the alignment for structs.

<h4>The D Way</h4>

	For D classes, there is no
	need to adjust the alignment  (in fact, the compiler is free to rearrange the data 
	fields to get the optimum layout, much as the compiler will rearrange local 
	variables on the stack frame). For D structs
	that get mapped onto externally defined data structures, there is a need, and
	it is handled with:

<pre class="d_code"><span class="d_keyword">struct</span> Foo
{
	<span class="d_keyword">align</span> (4):	<span class="d_comment">// use 4 byte alignment
</span>	...
}
</pre>

<hr><!-- -------------------------------------------- -->
<h3><a name="macros">Macros</a></h3>

	Preprocessor macros add powerful features and flexibility to C. But they have a
	downside:

<ul>
	<li> Macros have no concept of scope; they are valid from the point of definition
	to the end of the source. They cut a swath across .h files, nested code, etc. When
	#include'ing tens of thousands of lines of macro definitions, it becomes 
	problematical to avoid inadvertent macro expansions.

	<li> Macros are unknown to the debugger. Trying to debug a program with 
	symbolic data is undermined by the debugger only knowing about macro 
	expansions, not the macros themselves.

	<li> Macros make it impossible to tokenize source code, as an earlier macro change 
	can arbitrarily redo tokens.

	<li> The purely textual basis of macros leads to arbitrary and inconsistent usage,
	making code using macros error prone. (Some attempt to resolve this was 
	introduced with templates in C++.)

	<li> Macros are still used to make up for deficits in the language's expressive
	capability, such as for "wrappers" around header files.
</ul>


	Here's an enumeration of the common uses for macros, and the corresponding 
	feature in D:
	<p>

<ol>
	<li> Defining literal constants:

	<h4>The C Preprocessor Way</h4>

<pre class="ccode">#define VALUE	5
</pre>

	<h4>The D Way</h4>

<pre class="d_code"><span class="d_keyword">const</span> <span class="d_keyword">int</span> VALUE = 5;
</pre>

	<li> Creating a list of values or flags:

	<h4>The C Preprocessor Way</h4>

<pre class="ccode">int flags:
#define FLAG_X	0x1
#define FLAG_Y	0x2
#define FLAG_Z	0x4
...
flags |= FLAG_X;
</pre>

	<h4>The D Way</h4>

<pre class="d_code"><span class="d_keyword">enum</span> FLAGS { X = 0x1, Y = 0x2, Z = 0x4 };
FLAGS flags;
...
flags |= FLAGS.X;
</pre>

	<li> Distinguishing between ascii chars and wchar chars:

	<h4>The C Preprocessor Way</h4>

<pre class="ccode">#if UNICODE
    #define dchar	wchar_t
    #define TEXT(s)	L##s
#else
    #define dchar	char
    #define TEXT(s)	s
#endif

...
dchar h[] = TEXT("hello");
</pre>

	<h4>The D Way</h4>

<pre class="d_code"><span class="d_keyword">dchar</span>[] h = <span class="d_string">"hello"</span>;
</pre>


	D's optimizer will inline the function, and will do the conversion of the
	string constant at compile time.
	<p>

	<li> Supporting legacy compilers:

	<h4>The C Preprocessor Way</h4>

<pre class="ccode">#if PROTOTYPES
#define P(p)	p
#else
#define P(p)	()
#endif
int func P((int x, int y));
</pre>

	<h4>The D Way</h4>

	By making the D compiler open source, it will largely
	avoid the problem of syntactical backwards compatibility.

	<li> Type aliasing:

	<h4>The C Preprocessor Way</h4>

<pre class="ccode">#define INT 	int
</pre>

	<h4>The D Way</h4>

<pre class="d_code"><span class="d_keyword">alias</span> <span class="d_keyword">int</span> INT;
</pre>

	<li> Using one header file for both declaration and definition:

	<h4>The C Preprocessor Way</h4>

<pre class="ccode">#define EXTERN extern
#include "declarations.h"
#undef EXTERN
#define EXTERN
#include "declarations.h"
</pre>

	In declarations.h:

<pre class="ccode">EXTERN int foo;
</pre>


	<h4>The D Way</h4>

	The declaration and the definition are the same, so there is no need
	to muck with the storage class to generate both a declaration and a definition
	from the same source.

	<li> Lightweight inline functions:

	<h4>The C Preprocessor Way</h4>

<pre class="ccode">#define X(i)	((i) = (i) / 3)
</pre>

	<h4>The D Way</h4>

<pre class="d_code"><span class="d_keyword">int</span> X(<span class="d_keyword">inout</span> <span class="d_keyword">int</span> i) { <span class="d_keyword">return</span> i = i / 3; }
</pre>

	The compiler optimizer will inline it; no efficiency is lost.

	<li> Assert function file and line number information:

	<h4>The C Preprocessor Way</h4>

<pre class="ccode">#define assert(e)	((e) || _assert(__LINE__, __FILE__))
</pre>

	<h4>The D Way</h4>

	assert() is a built-in expression primitive. Giving the compiler
	such knowledge of assert() also enables the optimizer to know about things
	like the _assert() function never returns.

	<li> Setting function calling conventions:

	<h4>The C Preprocessor Way</h4>

<pre class="ccode">#ifndef _CRTAPI1
#define _CRTAPI1 __cdecl
#endif
#ifndef _CRTAPI2
#define _CRTAPI2 __cdecl
#endif

int _CRTAPI2 func();
</pre>

	<h4>The D Way</h4>

	Calling conventions can be specified in blocks, so there's no
	need to change it for every function:

<pre class="d_code"><span class="d_keyword">extern</span> (Windows)
{
    <span class="d_keyword">int</span> onefunc();
    <span class="d_keyword">int</span> anotherfunc();
}
</pre>

	<li> Hiding __near or __far pointer weirdness:

	<h4>The C Preprocessor Way</h4>

<pre class="ccode">#define LPSTR	char FAR *
</pre>

	<h4>The D Way</h4>

	D doesn't support 16 bit code, mixed pointer sizes, and different
	kinds of pointers, and so the problem is just
	irrelevant.

	<li> Simple generic programming:

	<h4>The C Preprocessor Way</h4>

	Selecting which function to use based on text substitution:

<pre class="ccode">#ifdef UNICODE
int getValueW(wchar_t *p);
#define getValue getValueW
#else
int getValueA(char *p);
#define getValue getValueA
#endif
</pre>

	<h4>The D Way</h4>

	D enables declarations of symbols that are <i>aliases</i> of
	other symbols:

<pre class="d_code"><span class="d_keyword">version</span> (UNICODE)
{
    <span class="d_keyword">int</span> getValueW(<span class="d_keyword">wchar</span>[] p);
    <span class="d_keyword">alias</span> getValueW getValue;
}
<span class="d_keyword">else</span>
{
    <span class="d_keyword">int</span> getValueA(<span class="d_keyword">char</span>[] p);
    <span class="d_keyword">alias</span> getValueA getValue;
}
</pre>

</ol>

<hr><!-- -------------------------------------------- -->
<h3><a name="conditionalcompilation">Conditional Compilation</a></h3>


<h4>The C Preprocessor Way</h4>

	Conditional compilation is a powerful feature of the C preprocessor,
	but it has its downside:

    <ul>
	<li> The preprocessor has no concept of scope. #if/#endif can be
	interleaved with code in a completely unstructured and disorganized
	fashion, making things difficult to follow.

	<li> Conditional compilation triggers off of macros - macros that
	can conflict with identifiers used in the program.

	<li> #if expressions are evaluated in subtly different ways than
	C expressions are.

	<li> The preprocessor language is fundamentally different in concept
	than C, for example, whitespace and line terminators mean things to
	the preprocessor that they do not in C.

    </ul>

<h4>The D Way</h4>

	D supports conditional compilation:

    <ol>
	<li> Separating version specific functionality into separate modules.

	<li> The debug statement for enabling/disabling debug harnesses,
	extra printing, etc.

	<li> The version statement for dealing with multiple versions
	of the program generated from a single set of sources.

	<li> The if (0) statement.

	<li> The /+ +/ nesting comment can be used to comment out blocks
	of code.

    </ol>

<hr><!-- -------------------------------------------- -->
<h3><a name="codefactoring">Code Factoring</a></h3>

<h4>The C Preprocessor Way</h4>

	It's common in a function to have a repetitive sequence
	of code to be executed in multiple places. Performance
	considerations preclude factoring it out into a separate
	function, so it is implemented as a macro. For example,
	consider this fragment from a byte code interpreter:

<pre class="ccode">unsigned char *ip;	// byte code instruction pointer
int *stack;
int spi;		// stack pointer
...
#define pop()		(stack[--spi])
#define push(i)		(stack[spi++] = (i))
while (1)
{
    switch (*ip++)
    {
	case ADD:
	    op1 = pop();
	    op2 = pop();
	    result = op1 + op2;
	    push(result);
	    break;

	case SUB:
	...
    }
}
</pre>

	This suffers from numerous problems:
	<ol>
	<li> The macros must evaluate to expressions and cannot declare
	any variables. Consider the difficulty of extending them to
	check for stack overflow/underflow.
	<li> The macros exist outside of the semantic symbol table, so
	remain in scope even outside of the function they are declared in.
	<li> Parameters to macros are passed textually, not by value,
	meaning that the macro implementation needs to be careful to not
	use the parameter more than once, and must protect it with ().
	<li> Macros are invisible to the debugger, which sees only the
	expanded expressions.
	</ol>

<h4>The D Way</h4>

	D neatly addresses this with nested functions:

<pre class="d_code"><span class="d_keyword">ubyte</span>* ip;		<span class="d_comment">// byte code instruction pointer
</span><span class="d_keyword">int</span>[] stack;		<span class="d_comment">// operand stack
</span><span class="d_keyword">int</span> spi;		<span class="d_comment">// stack pointer
</span>...

<span class="d_keyword">int</span> pop()        { <span class="d_keyword">return</span> stack[--spi]; }
<span class="d_keyword">void</span> push(<span class="d_keyword">int</span> i) { stack[spi++] = i; }

<span class="d_keyword">while</span> (1)
{
    <span class="d_keyword">switch</span> (*ip++)
    {
	<span class="d_keyword">case</span> ADD:
	    op1 = pop();
	    op2 = pop();
	    push(op1 + op2);
	    <span class="d_keyword">break</span>;

	<span class="d_keyword">case</span> SUB:
	...
    }
}
</pre>

	The problems addressed are:
	<ol>
	<li> The nested functions have available the full expressive
	power of D functions. The array accesses already are bounds
	checked (adjustable by compile time switch).
	<li> Nested function names are scoped just like any other name.
	<li> Parameters are passed by value, so need to worry about
	side effects in the parameter expressions.
	<li> Nested functions are visible to the debugger.
	</ol>

	Additionally, nested functions can be inlined by the implementation
	resulting in the same high performance that the C macro version
	exhibits.

<hr><!-- -------------------------------------------- -->
<h3><a name="staticassert">#error and Static Asserts</a></h3>

	Static asserts are user defined checks made at compile time;
	if the check fails the compile issues an error and fails.

<h4>The C Preprocessor Way</h4>

	The first way is to use the <tt>#error</tt> preprocessing directive:

<pre class="ccode">#if FOO || BAR
    ... code to compile ...
#else
#error "there must be either FOO or BAR"
#endif
</pre>

	This has the limitations inherent in preprocessor expressions
	(i.e. integer constant expressions only, no casts, no <tt>sizeof</tt>,
	no symbolic constants, etc.).
	<p>

	These problems can be circumvented to some extent by defining a
	<tt>static_assert</tt> macro (thanks to M. Wilson):

<pre class="ccode">#define static_assert(_x) do { typedef int ai[(_x) ? 1 : 0]; } while(0)
</pre>

	and using it like:

<pre class="ccode">void foo(T t)
{
    static_assert(sizeof(T) &lt; 4);
    ...
}
</pre>

	This works by causing a compile time semantic error if the condition
	evaluates
	to false. The limitations of this technique are a sometimes very
	confusing error message from the compiler, along with an inability
	to use a <tt>static_assert</tt> outside of a function body.

<h4>The D Way</h4>

	D has the <a href="version.html#staticassert">static assert</a>,
	which can be used anywhere a declaration
	or a statement can be used. For example:

<pre class="d_code"><span class="d_keyword">version</span> (FOO)
{
    <span class="d_keyword">class</span> Bar
    {
	<span class="d_keyword">const</span> <span class="d_keyword">int</span> x = 5;
	<span class="d_keyword">static</span> <span class="d_keyword">assert</span>(Bar.x == 5 || Bar.x == 6);

	<span class="d_keyword">void</span> foo(T t)
	{
	    <span class="d_keyword">static</span> <span class="d_keyword">assert</span>(T.sizeof &lt; 4);
	    ...
	}
    }
}
<span class="d_keyword">else</span> <span class="d_keyword">version</span> (BAR)
{
    ...
}
<span class="d_keyword">else</span>
{
    <span class="d_keyword">static</span> <span class="d_keyword">assert</span>(0);	<span class="d_comment">// unsupported version
</span>}
</pre>

<hr><!-- -------------------------------------------- -->
<h3><a name="mixins">Mixins</a></h3>

	D <a href="mixin.html">mixins</a> superficially look just
	like using C's preprocessor to insert blocks of code and
	parse them in the scope of where they are instantiated.
	But the advantages of mixins over macros are:

	<ol>
	<li> Mixins substitute in parsed declaration trees that pass muster with
	the language syntax, macros substitute in arbitrary preprocessor tokens
	that have no organization.

	<li> Mixins are in the same language. Macros are a separate and
	distinct language layered on top of C++, with its own expression rules,
	its own types, its distinct symbol table, its own scoping rules, etc. 

	<li> Mixins are selected based on partial specialization rules, macros
	have no overloading.

	<li> Mixins create a scope, macros do not.

	<li> Mixins are compatible with syntax parsing tools, macros are not.

	<li> Mixin semantic information and symbol tables are passed through to
	the debugger, macros are lost in translation.

	<li> Mixins have override conflict resolution rules, macros just
	collide.

	<li> Mixins automatically create unique identifiers as required using a
	standard algorithm, macros have to do it manually with kludgy token
	pasting.

	<li> Mixin value arguments with side effects are evaluated once, macro
	value arguments get evaluated each time they are used in the expansion
	(leading to weird bugs).

	<li> Mixin argument replacements don't need to be 'protected' with
	parentheses to avoid operator precedence regrouping.

	<li> Mixins can be typed as normal D code of arbitrary length, multiline
	macros have to be backslash line-spliced, can't use // to end of line
	comments, etc.

	<li> Mixins can define other mixins. Macros cannot create other macros.

	</ol>


  
<br><br>
<br><br>
<!-- Google ad -->
<script type="text/javascript"><!--
/**/google_ad_client = "pub-5628673096434613";
/**/google_ad_width = 728;
/**/google_ad_height = 90;
/**/google_ad_format = "728x90_as";
/**/google_ad_channel ="3651639259";
/**/google_page_url = document.location;
//--></script>
<script type="text/javascript" src="../../../../../../../../pagead2.googlesyndication.com/pagead/show_ads.js">
</script>

</div>






<div id="copyright">
Copyright &copy; 1999-2006 by Digital Mars, All Rights Reserved |
Page generated by <a href="http://www.digitalmars.com/d/ddoc.html">Ddoc</a>. |
<a href="http://www.prowiki.org/wiki4d/wiki.cgi?DocComments/PreToD" title="Read/write comments and feedback">Comments</a>
</div>

</body>

<!-- Mirrored from www.shorthike.com/trac/browser/trunk/tools_win32/dmd/html/d/pretod.html?format=raw by HTTrack Website Copier/3.x [XR&CO'2010], Sat, 01 May 2010 04:37:48 GMT -->
<!-- Added by HTTrack --><meta http-equiv="content-type" content="text/html;charset=UTF-8"><!-- /Added by HTTrack -->
</html>

