
<!DOCTYPE html PUBLIC "-//W3C//DTD HTML 4.01//EN" "http://www.w3.org/TR/html4/strict.dtd">
<html>

<!--
	Copyright (c) 1999-2006 by Digital Mars
	All Rights Reserved
	Written by Walter Bright
	www.digitalmars.com
  -->


<!-- Mirrored from www.shorthike.com/trac/browser/trunk/tools_win32/dmd/html/d/statement.html?format=raw by HTTrack Website Copier/3.x [XR&CO'2010], Sat, 01 May 2010 04:37:48 GMT -->
<!-- Added by HTTrack --><meta http-equiv="content-type" content="text/html;charset=UTF-8"><!-- /Added by HTTrack -->
<head>
<meta http-equiv="content-type" content="text/html; charset=utf-8" />
<meta name="keywords" content="D programming language" />
<meta name="description" content="D Programming Language" />
<title>D Programming Language - Statements</title>
<link rel="stylesheet" type="text/css" href="style.html" />
<link rel="shortcut icon" href="favicon.html" />
</head>

<body>
<div id="heading">
	<a href="http://www.digitalmars.com/"><img src="dmlogo.html" width="270" height="53" style="border-style:none" alt="www.digitalmars.com"></a>

	<div id="headingNav">
	<ul>	<li><a href="http://www.prowiki.org/wiki4d/wiki.cgi?DocComments/Statement" title="Read/write comments and feedback">Comments</a></li>
	<li><a href="index.html" title="D Programming Language" class="dlink">D</a></li>
	<li><a href="http://www.digitalmars.com/advancedsearch.html" title="Search Digital Mars web site">Search</a></li>
	<li><a href="download.html" title="download D">Downloads</a></li>
	<li><a href="http://www.digitalmars.com/" title="www.digitalmars.com">Home</a></li>
	</ul>
	</div>

	<div id="lastupdate">Last update Fri Jun 30 00:31:51 2006
</div>
</div>

<!-- Generated by Ddoc from statement.d -->



<div id="navigation">
  
<div class="navblock">
<form method="get" action="http://www.google.com/search">
<div id="searchbox">
<input id="q" name="q" size="10" value="Search" onFocus='if(this.value == "Search"){this.value="";}'>
<input type="hidden" id="domains" name="domains" value="www.digitalmars.com">
<input type="hidden" id="sitesearch" name="sitesearch" value="www.digitalmars.com/d">
<input type="hidden" id="sourceid" name="sourceid" value="google-search">
<input type="submit" id="submit" name="submit" value="Go">
</div>
</form>
<div id="toctop">
    <ul>	<li><a href="index.html" title="D Programming Language">D ...</a></li>
	<li><a href="lex.html" title="D Language Specification">Language ...</a></li>
	<li><a href="phobos/phobos.html" title="D Runtime Library">Phobos ...</a></li>
	<li><a href="comparison.html" title="Language Comparisons">Comparisons ...</a></li>
    </ul>
</div>
</div>

  
    <div class="navblock">
    <ul>	<li><a href="lex.html">Lexical</a></li>

	<li><a href="module.html">Modules</a></li>

	<li><a href="declaration.html">Declarations</a></li>

	<li><a href="type.html">Types</a></li>

	<li><a href="property.html">Properties</a></li>

	<li><a href="attribute.html">Attributes</a></li>

	<li><a href="pragma.html">Pragmas</a></li>

	<li><a href="expression.html">Expressions</a></li>

	<li><a href="statement.html">Statements</a></li>

	<li><a href="arrays.html">Arrays</a></li>

	<li><a href="struct.html">Structs &amp; Unions</a></li>

	<li><a href="class.html">Classes</a></li>

	<li><a href="interface.html">Interfaces</a></li>

	<li><a href="enum.html">Enums</a></li>

	<li><a href="function.html">Functions</a></li>

	<li><a href="operatoroverloading.html">Operator Overloading</a></li>

	<li><a href="template.html">Templates</a></li>

	<li><a href="mixin.html">Mixins</a></li>

	<li><a href="dbc.html">Contracts</a></li>

	<li><a href="version.html">Conditional Compilation</a></li>

	<li><a href="errors.html">Handling errors</a></li>

	<li><a href="garbage.html">Garbage Collection</a></li>

	<li><a href="float.html">Floating Point</a></li>

	<li><a href="iasm.html">Inline Assembler</a></li>

	<li><a href="ddoc.html">Documentation Comments</a></li>

	<li><a href="interfaceToC.html">Interfacing To C</a></li>

	<li><a href="portability.html">Portability Guide</a></li>

	<li><a href="html.html">Embedding D in HTML</a></li>

	<li><a href="entity.html">Named Character Entities</a></li>

	<li><a href="abi.html">Application Binary Interface</a></li>

    </ul>
    </div>

</div>
<div id="content">
  <h1>     Statements</h1>
  
C and C++ programmers will find the D statements very familiar, with a few
interesting additions.

<pre class="bnf"><i>Statement</i>:
    <a href="#label"><i>LabeledStatement</i></a>
    <a href="#block"><i>BlockStatement</i></a>
    <a href="#expression"><i>ExpressionStatement</i></a>
    <a href="#declaration"><i>DeclarationStatement</i></a>
    <a href="#if"><i>IfStatement</i></a>
    <a href="version.html"><i>DebugStatement</i></a>
    <a href="version.html"><i>VersionStatement</i></a>
    <a href="#while"><i>WhileStatement</i></a>
    <a href="#do"><i>DoWhileStatement</i></a>
    <a href="#for"><i>ForStatement</i></a>
    <a href="#foreach"><i>ForeachStatement</i></a>
    <a href="#switch"><i>SwitchStatement</i></a>
    <a href="#switch"><i>CaseStatement</i></a>
    <a href="#switch"><i>DefaultStatement</i></a>
    <a href="#continue"><i>ContinueStatement</i></a>
    <a href="#break"><i>BreakStatement</i></a>
    <a href="#return"><i>ReturnStatement</i></a>
    <a href="#goto"><i>GotoStatement</i></a>
    <a href="#with"><i>WithStatement</i></a>
    <a href="#synchronize"><i>SynchronizeStatement</i></a>
    <a href="#try"><i>TryStatement</i></a>
    <a href="#scope"><i>ScopeStatement</i></a>
    <a href="#throw"><i>ThrowStatement</i></a>
    <a href="#volatile"><i>VolatileStatement</i></a>
    <a href="#asm"><i>AsmStatement</i></a>
    <a href="pragma.html"><i>PragmaStatement</i></a>

<i>EmptyStatement</i>:
    <b>;</b>
</pre>

<h2><a name="label">Labelled Statements</a></h2>

<p>Statements can be labelled. A label is an identifier that
	precedes a statement.
</p>

<pre class="bnf"><i>LabelledStatement</i>:
    <i>Identifier</i> <b>:</b> <i>Statement</i>
    <i>Identifier</i> <b>:</b> <i>EmptyStatement</i>
</pre>

<p>	Any statement can be labelled, including empty statements,
	and so can serve as the target
	of a goto statement. Labelled statements can also serve as the
	target of a break or continue statement.
</p>
<p>	Labels are in a name space independent of declarations, variables,
	types, etc.
	Even so, labels cannot have the same name as local declarations.
	The label name space is the body of the function
	they appear in. Label name spaces do not nest, i.e. a label
	inside a block statement is accessible from outside that block.
</p>

<h2><a name="block">Block Statement</a></h2>

<pre class="bnf"><i>BlockStatement</i>:
    <b>{ }</b>
    <b>{</b> <i>StatementList</i> <b>}</b>

<i>StatementList</i>:
    <i>Statement</i>
    <i>Statement</i> <i>StatementList</i>
</pre>

<p>	A block statement is a sequence of statements enclosed
	by { }. The statements are executed in lexical order.
</p>
<p>	A block statement introduces a new scope for local
	symbols.
	Local symbol declarations cannot shadow (hide) other
	local symbol declarations in the same function.
</p>

<pre class="d_code"><span class="d_keyword">void</span> func1(<span class="d_keyword">int</span> x)
{   <span class="d_keyword">int</span> x;	<span class="d_comment">// illegal, x shadows parameter x
</span>
    <span class="d_keyword">int</span> y;

    { <span class="d_keyword">int</span> y; }	<span class="d_comment">// illegal, y shadows enclosing scope's y
</span>
    <span class="d_keyword">void</span> <span class="d_keyword">delegate</span>() dg;
    dg = { <span class="d_keyword">int</span> y; };	<span class="d_comment">// ok, this y is not in the same function
</span>
    <span class="d_keyword">struct</span> S
    {
	<span class="d_keyword">int</span> y;		<span class="d_comment">// ok, this y is a member, not a local
</span>    }

    { <span class="d_keyword">int</span> z; }
    { <span class="d_keyword">int</span> z; }	<span class="d_comment">// ok, this z is not shadowing the other z
</span>
    { <span class="d_keyword">int</span> t; }
    { t++;   }	<span class="d_comment">// illegal, t is undefined
</span>}
</pre>

<p>	The idea is to avoid bugs in complex functions caused by
	scoped declarations inadvertently hiding previous ones.
	Local names should all be unique within a function.
</p>

<h2><a name="expression">Expression Statement</a></h2>

<pre class="bnf"><i>ExpressionStatement</i>:
    <i>Expression</i> <b>;</b>
</pre>

	The expression is evaluated.
	<p>

	Expressions that have no effect, like <tt>(x + x)</tt>,
	are illegal
	in expression statements.
	If such an expression is needed, casting it to <span class="d_keyword">void</span> will
	make it legal.

<pre class="d_code"><span class="d_keyword">int</span> x;
x++;                <span class="d_comment">// ok
</span>x;                  <span class="d_comment">// illegal
</span>1+1;                <span class="d_comment">// illegal
</span><span class="d_keyword">cast</span>(<span class="d_keyword">void</span>)(x + x);  <span class="d_comment">// ok
</span></pre>

<h2><a name="declaration">Declaration Statement</a></h2>

	Declaration statements declare and initialize variables.

<pre class="bnf"><i>DeclarationStatement</i>:
	<i>Type</i> <i>IdentifierList</i> <b>;</b>

<i>IdentifierList</i>:
	<i>Variable</i>
	<i>Variable</i> <b>,</b> <i>IdentifierList</i>

<i>Variable</i>:
	<i>Identifier</i>
	<i>Identifier</i> <b>=</b> <i>Initializer</i>
</pre>

	If no <i>Initializer</i> is there to initialize the
	variable, it is initialized to the default value for its type.

<pre class="d_code"><span class="d_keyword">int</span> a;		<span class="d_comment">// declare a as type int and initialize it to 0
</span><span class="d_keyword">long</span>* c,d;	<span class="d_comment">// declare c and d as type pointer to long, initialize to null
</span><span class="d_keyword">byte</span>* e,*f;	<span class="d_comment">// illegal declaration of f
</span><span class="d_keyword">short</span> s = 3;	<span class="d_comment">// declare s as type short and initialize it to 3
</span></pre>

<h2><a name="if">If Statement</a></h2>

	If statements provide simple conditional execution of statements.

<pre class="bnf"><i>IfStatement</i>:
	<b>if (</b> <i>IfCondition</i> <b>)</b> <i>ThenStatement</i>
	<b>if (</b> <i>IfCondition</i> <b>)</b> <i>ThenStatement</i> <b>else</b> <i>ElseStatement</i>

<i>IfCondition</i>:
	<i>Expression</i>
	<b>auto</b> <i>Identifier</i> <b>=</b> <i>Expression</i>
	<i>Declarator</i> <b>=</b> <i>Expression</i>

<i>ThenStatement</i>:
	<i>Statement</i>

<i>ElseStatement</i>:
	<i>Statement</i>
</pre>

	<i>Expression</i> is evaluated and must have a type that
	can be converted to a boolean. If it's true the
	<i>ThenStatement</i> is transferred to, else the <i>ElseStatement</i>
	is transferred to.
	<p>

	The 'dangling else' parsing problem is solved by associating the
	else with the nearest if statement.
	<p>

	If an <b>auto</b> <i>Identifier</i> is provided, it is declared and
	initialized
	to the value
	and type of the <i>Expression</i>. Its scope extends from when it is
	initialized to the end of the <i>ThenStatement</i>.
	<p>

	If a <i>Declarator</i> is provided, it is declared and
	initialized
	to the value
	of the <i>Expression</i>. Its scope extends from when it is
	initialized to the end of the <i>ThenStatement</i>.

<pre class="d_code"><span class="d_keyword">import</span> std.regexp;
...
<span class="d_keyword">if</span> (<span class="d_keyword">auto</span> m = std.regexp.search(<span class="d_string">"abcdef"</span>, <span class="d_string">"b(c)d"</span>))
{
    writefln(<span class="d_string">"[%s]"</span>, m.pre);      <span class="d_comment">// prints [a]
</span>    writefln(<span class="d_string">"[%s]"</span>, m.post);     <span class="d_comment">// prints [ef]
</span>    writefln(<span class="d_string">"[%s]"</span>, m.match(0)); <span class="d_comment">// prints [bcd]
</span>    writefln(<span class="d_string">"[%s]"</span>, m.match(1)); <span class="d_comment">// prints [c]
</span>    writefln(<span class="d_string">"[%s]"</span>, m.match(2)); <span class="d_comment">// prints []
</span>}
<span class="d_keyword">else</span>
{
    writefln(m.post);    <span class="d_comment">// error, m undefined
</span>}
writefln(m.pre);         <span class="d_comment">// error, m undefined
</span></pre>

<h2><a name="while">While Statement</a></h2>

<pre class="bnf"><i>WhileStatement</i>:
    <b>while (</b> <i>Expression</i> <b>)</b> <i>Statement</i>
</pre>

	While statements implement simple loops.

	<i>Expression</i> is evaluated and must have a type that
	can be converted to a boolean. If it's true the
	<i>Statement</i> is executed. After the <i>Statement</i> is executed,
	the <i>Expression</i> is evaluated again, and if true the
	<i>Statement</i> is executed again. This continues until the
	<i>Expression</i> evaluates to false.

<pre class="d_code"><span class="d_keyword">int</span> i = 0;
<span class="d_keyword">while</span> (i &lt; 10)
{
    foo(i);
    i++;
}
</pre>

	A <a href="#break"><i>BreakStatement</i></a> will exit the loop.
	A <a href="#continue"><i>ContinueStatement</i></a>
	will transfer directly to evaluating <i>Expression</i> again.

<h2><a name="do">Do While Statement</a></h2>

<pre class="bnf"><i>DoStatement</i>:
    <b>do</b> <i>Statement</i> <b>while (</b> <i>Expression</i> <b>)</b>
</pre>

	Do while statements implement simple loops.

	<i>Statement</i> is executed. Then
	<i>Expression</i> is evaluated and must have a type that
	can be converted to a boolean. If it's true the
	loop is iterated again.
	This continues until the
	<i>Expression</i> evaluates to false.

<pre class="d_code"><span class="d_keyword">int</span> i = 0;
<span class="d_keyword">do</span>
{
    foo(i);
} <span class="d_keyword">while</span> (++i &lt; 10);
</pre>

	A <a href="#break"><i>BreakStatement</i></a> will exit the loop.
	A <a href="#continue"><i>ContinueStatement</i></a>
	will transfer directly to evaluating <i>Expression</i> again.

<h2><a name="for">For Statement</a></h2>

	For statements implement loops with initialization,
	test, and increment clauses.

<pre class="bnf"><i>ForStatement</i>:
	<b>for (</b><i>Initialize</i><b>;</b> <i>Test</i><b>;</b> <i>Increment</i><b>)</b> <i>Statement</i>

<i>Initialize</i>:
	<i>empty</i>
	<i>Expression</i>
	<i>Declaration</i>

<i>Test</i>:
	<i>empty</i>
	<i>Expression</i>

<i>Increment</i>:
	<i>empty</i>
	<i>Expression</i>
</pre>

	<i>Initializer</i> is executed.
	<i>Test</i> is evaluated and must have a type that
	can be converted to a boolean. If it's true the
	statement is executed. After the statement is executed,
	the <i>Increment</i> is executed.
	Then <i>Test</i> is evaluated again, and if true the
	statement is executed again. This continues until the
	<i>Test</i> evaluates to false.
	<p>

	A break statement will exit the loop. A continue statement
	will transfer directly to the <i>Increment</i>.
	<p>

	If <i>Initializer</i> declares a variable, that variable's scope
	extends through the end of <i>Statement</i>. For example:

<pre class="d_code"><span class="d_keyword">for</span> (<span class="d_keyword">int</span> i = 0; i &lt; 10; i++)
	foo(i);
</pre>

	is equivalent to:

<pre class="d_code">{   <span class="d_keyword">int</span> i;
    <span class="d_keyword">for</span> (i = 0; i &lt; 10; i++)
	foo(i);
}
</pre>

	Function bodies cannot be empty:

<pre class="d_code"><span class="d_keyword">for</span> (<span class="d_keyword">int</span> i = 0; i &lt; 10; i++)
	;	<span class="d_comment">// illegal
</span></pre>

	Use instead:

<pre class="d_code"><span class="d_keyword">for</span> (<span class="d_keyword">int</span> i = 0; i &lt; 10; i++)
{
}
</pre>

	The <i>Initializer</i> may be omitted. <i>Test</i> may also be
	omitted, and if so, it is treated as if it evaluated to true.

<h2><a name="foreach">Foreach Statement</a></h2>

	A foreach statement loops over the contents of an aggregate.

<pre class="bnf"><i>ForeachStatement</i>:
	<b>foreach (</b><i>ForeachTypeList</i><b>;</b> <i>Expression</i><b>)</b> <i>Statement</i>

<i>ForeachTypeList</i>:
	<i>ForeachType</i>
	<i>ForeachType</i> , <i>ForeachTypeList</i>

<i>ForeachType</i>:
	<b>inout</b> <i>Type</i> <i>Identifier</i>
	<i>Type</i> <i>Identifier</i>
	<b>inout</b> <i>Identifier</i>
	<i>Identifier</i>
</pre>

<p>	<i>Expression</i> is evaluated. It must evaluate to an aggregate
	expression
	of type static array, dynamic array, associative array,
	struct, or class.
	The <i>Statement</i> is executed, once for each element of the
	aggregate expression.
	At the start of each iteration, the variables declared by
	the <i>ForeachTypeList</i>
	are set to be a copy of the contents of the aggregate.
	If the variable is <b>inout</b>, it is a reference to the
	contents of that aggregate.
</p>
<p>	The aggregate expression must be loop invariant, meaning that
	elements to the aggregate cannot be added or removed from it
	in the <i>Statement</i>.
</p>
<p>	If the aggregate expression is a static or dynamic array, there
	can be one or two variables declared. If one, then the variable
	is said to be the <i>value</i> set to the elements of the array,
	one by one. The type of the
	variable must match the type of the array contents, except for the
	special cases outlined below.
	If there are
	two variables declared, the first is said to be the <i>index</i>
	and the second is said to be the <i>value</i>. The <i>index</i>
	must be of <b>int</b> or <b>uint</b> type, it cannot be <i>inout</i>,
	and it is set to be the index of the array element.
</p>
<pre class="d_code"><span class="d_keyword">char</span>[] a;
...
<span class="d_keyword">foreach</span> (<span class="d_keyword">int</span> i, <span class="d_keyword">char</span> c; a)
{
    printf(<span class="d_string">"a[%d] = '%c'\n"</span>, i, c);
}
</pre>

	If the aggregate expression is a static or dynamic array of
	<b>char</b>s, <b>wchar</b>s, or <b>dchar</b>s, then the <i>Type</i> of
	the <i>value</i>
	can be any of <b>char</b>, <b>wchar</b>, or <b>dchar</b>.
	In this manner any UTF array
	can be decoded into any UTF type:

<pre class="d_code"><span class="d_keyword">char</span>[] a = <span class="d_string">"\xE2\x89\xA0"</span>;	<span class="d_comment">// \u2260 encoded as 3 UTF-8 bytes
</span>
<span class="d_keyword">foreach</span> (<span class="d_keyword">dchar</span> c; a)
{
    printf(<span class="d_string">"a[] = %x\n"</span>, c);	<span class="d_comment">// prints 'a[] = 2260'
</span>}

<span class="d_keyword">dchar</span>[] b = <span class="d_string">"\u2260"</span>;

<span class="d_keyword">foreach</span> (<span class="d_keyword">char</span> c; b)
{
    printf(<span class="d_string">"%x, "</span>, c);	<span class="d_comment">// prints 'e2, 89, a0'
</span>}
</pre>


	If the aggregate expression is an associative array, there
	can be one or two variables declared. If one, then the variable
	is said to be the <i>value</i> set to the elements of the array,
	one by one. The type of the
	variable must match the type of the array contents. If there are
	two variables declared, the first is said to be the <i>index</i>
	and the second is said to be the <i>value</i>. The <i>index</i>
	must be of the same type as the indexing type of the associative
	array. It cannot be <i>inout</i>,
	and it is set to be the index of the array element.

<pre class="d_code"><span class="d_keyword">double</span>[<span class="d_keyword">char</span>[]] a;	<span class="d_comment">// <i>index</i> type is char[], <i>value</i> type is double
</span>...
<span class="d_keyword">foreach</span> (<span class="d_keyword">char</span>[] s, <span class="d_keyword">double</span> d; a)
{
    printf(<span class="d_string">"a['%.*s'] = %g\n"</span>, s, d);
}
</pre>

	If the aggregate expression is a static or dynamic array, the
	elements are iterated over starting at index 0 and continuing
	to the maximum of the array. If it is an associative array,
	the order of the elements is undefined. If it is a struct or
	class object, it is defined by the special <i>opApply</i> member function.
	<p>

	If the aggregate is a struct or a class object, that struct
	or class must have an <i>opApply</i> function with the type:

<pre class="d_code"><span class="d_keyword">int</span> <b>opApply</b>(<span class="d_keyword">int</span> <span class="d_keyword">delegate</span>(<span class="d_keyword">inout</span> <i>Type</i> [, ...]) <i>dg</i>);
</pre>

	where <i>Type</i> matches the <i>Type</i> used in the foreach
	declaration of <i>Identifier</i>. Multiple <i>ForeachType</i>s
	correspond with multiple <i>Type</i>'s in the delegate type
	passed to <b>opApply</b>.
	There can be multiple <b>opApply</b> functions, one is selected
	by matching the type of <i>dg</i> to the <i>ForeachType</i>s
	of the <i>ForeachStatement</i>.
	The body of the <i>opApply</i>
	function iterates over the elements it aggregates, passing them
	each to the <i>dg</i> function. If the <i>dg</i> returns 0, then
	<b>opApply</b> goes on to the next element.
	If the <i>dg</i> returns a nonzero value, <b>opApply</b> must cease
	iterating and return that value. Otherwise, after done iterating
	across all the elements, <b>opApply</b> will return 0.
	<p>

	For example, consider a class that is a container for two elements:

<pre class="d_code"><span class="d_keyword">class</span> Foo
{
    <span class="d_keyword">uint</span> array[2];

    <span class="d_keyword">int</span> <b>opApply</b>(<span class="d_keyword">int</span> <span class="d_keyword">delegate</span>(<span class="d_keyword">inout</span> <span class="d_keyword">uint</span>) <i>dg</i>)
    {   <span class="d_keyword">int</span> result = 0;

	<span class="d_keyword">for</span> (<span class="d_keyword">int</span> i = 0; i &lt; array.length; i++)
	{
	    result = <i>dg</i>(array[i]);
	    <span class="d_keyword">if</span> (result)
		<span class="d_keyword">break</span>;
	}
	<span class="d_keyword">return</span> result;
    }
}
</pre>

	An example using this might be:

<pre class="d_code"><span class="d_keyword">void</span> test()
{
    Foo a = <span class="d_keyword">new</span> Foo();

    a.array[0] = 73;
    a.array[1] = 82;

    <span class="d_keyword">foreach</span> (<span class="d_keyword">uint</span> u; a)
    {
	printf(<span class="d_string">"%d\n"</span>, u);
    }
}
</pre>

	which would print:

<pre class="console">73
82
</pre>

	Aggregates can be string literals, which can be accessed
	as char, wchar, or dchar arrays:

<pre class="d_code"><span class="d_keyword">void</span> test()
{
    <span class="d_keyword">foreach</span> (<span class="d_keyword">char</span> c; <span class="d_string">"ab"</span>)
    {
	printf(<span class="d_string">"'%c'\n"</span>, c);
    }
    <span class="d_keyword">foreach</span> (<span class="d_keyword">wchar</span> w; <span class="d_string">"xy"</span>)
    {
	wprintf(<span class="d_string">"'%c'\n"</span>, w);
    }
}
</pre>

	which would print:

<pre class="console">'a'
'b'
'x'
'y'
</pre>

	<b>inout</b> can be used to update the original elements:

<pre class="d_code"><span class="d_keyword">void</span> test()
{
    <span class="d_keyword">static</span> <span class="d_keyword">uint</span>[2] a = [7, 8];

    <span class="d_keyword">foreach</span> (<span class="d_keyword">inout</span> <span class="d_keyword">uint</span> u; a)
    {
	u++;
    }
    <span class="d_keyword">foreach</span> (<span class="d_keyword">uint</span> u; a)
    {
	printf(<span class="d_string">"%d\n"</span>, u);
    }
}
</pre>

	which would print:

<pre class="console">8
9
</pre>



	The aggregate itself must not be resized, reallocated, free'd,
	reassigned or destructed
	while the foreach is iterating over the elements.

<pre class="d_code"><span class="d_keyword">int</span>[] a;
<span class="d_keyword">int</span>[] b;
<span class="d_keyword">foreach</span> (<span class="d_keyword">int</span> i; a)
{
    a = <span class="d_keyword">null</span>;		<span class="d_comment">// error
</span>    a.length += 10;	<span class="d_comment">// error
</span>    a = b;		<span class="d_comment">// error
</span>}
a = <span class="d_keyword">null</span>;		<span class="d_comment">// ok
</span></pre>

	A <i>BreakStatement</i> in the body of the foreach will exit the
	foreach, a <i>ContinueStatement</i> will immediately start the
	next iteration.

<h2><a name="switch">Switch Statement</a></h2>

	A switch statement goes to one of a collection of case
	statements depending on the value of the switch
	expression.

<pre class="bnf"><i>SwitchStatement</i>:
	<b>switch (</b> <i>Expression</i> <b>)</b> <i>BlockStatement</i>

<i>CaseStatement</i>:
	<b>case</b> <i>ExpressionList</i> <b>:</b> <i>Statement</i>

<i>DefaultStatement</i>:
	<b>default:</b> <i>Statement</i>
</pre>

	<i>Expression</i> is evaluated. The result type T must be
	of integral type or char[], wchar[] or dchar[]. The result is
	compared against each of the case expressions. If there is
	a match, the corresponding case statement is transferred to.
	<p>

	The case expressions, <i>ExpressionList</i>, are a comma separated
	list of expressions.
	<p>

	If none of the case expressions match, and there is a default
	statement, the default statement is transferred to.
	<p>

	If none of the case expressions match, and there is not a default
	statement, a SwitchError is thrown. The reason for this is
	to catch the common programming error of adding a new value to
	an enum, but failing to account for the extra value in
	switch statements. This behavior is unlike C or C++.
	<p>

	The case expressions must all evaluate to a constant value
	or array, and be implicitly convertible to the type T of the
	switch <i>Expression</i>.
	<p>

	Case expressions must all evaluate to distinct values.
	There may not be two or more default statements.
	<p>

	Case statements and default statements associated with the switch
	can be nested within block statements; they do not have to be in
	the outermost block. For example, this is allowed:

<pre class="d_code">    <span class="d_keyword">switch</span> (i)
    {
	<span class="d_keyword">case</span> 1:
	{
	    <span class="d_keyword">case</span> 2:
	}
	    <span class="d_keyword">break</span>;
    }
</pre>

	Like in C and C++, case statements 'fall through' to subsequent
	case values. A break statement will exit the switch <i>BlockStatement</i>.
	For example:

<pre class="d_code"><span class="d_keyword">switch</span> (i)
{
    <span class="d_keyword">case</span> 1:
	x = 3;
    <span class="d_keyword">case</span> 2:
	x = 4;
	<span class="d_keyword">break</span>;

    <span class="d_keyword">case</span> 3,4,5:
	x = 5;
	<span class="d_keyword">break</span>;
}
</pre>

	will set x to 4 if i is 1.
	<p>

	<b>Note:</b> Unlike C and C++, strings can be used in switch
	expressions. For example:

<pre class="d_code"><span class="d_keyword">char</span>[] name;
...
<span class="d_keyword">switch</span> (name)
{
    <span class="d_keyword">case</span> <span class="d_string">"fred"</span>:
    <span class="d_keyword">case</span> <span class="d_string">"sally"</span>:
	...
}
</pre>

	For applications like command line switch processing, this
	can lead to much more straightforward code, being clearer and
	less error prone. Both ascii and wchar strings are allowed.
	<p>

	<b>Implementation Note:</b> The compiler's code generator may
	assume that the case
	statements are sorted by frequency of use, with the most frequent
	appearing first and the least frequent last. Although this is
	irrelevant as far as program correctness is concerned, it is of
	performance interest.


<h2><a name="continue">Continue Statement</a></h2>

<pre class="bnf"><i>ContinueStatement</i>:
    <b>continue;</b>
    <b>continue</b> <i>Identifier</i> <b>;</b>
</pre>

	A continue aborts the current iteration of its enclosing loop
	statement, and starts the next iteration.

	continue executes the next iteration of its innermost enclosing
	while, for, or do loop. The increment clause is executed.
	<p>

	If continue is followed by <i>Identifier</i>, the <i>Identifier</i>
	must be the label of an enclosing while, for, or do
	loop, and the next iteration of that loop is executed.
	It is an error if
	there is no such statement.
	<p>

	Any intervening finally clauses are executed, and any intervening
	synchronization objects are released.
	<p>

	<b>Note:</b> If a finally clause executes a return, throw, or goto
	out of the finally clause,
	the continue target is never reached.

<pre class="d_code"><span class="d_keyword">for</span> (i = 0; i &lt; 10; i++)
{
    <span class="d_keyword">if</span> (foo(i))
	<span class="d_keyword">continue</span>;
    bar();
}
</pre>

<h2><a name="break">Break Statement</a></h2>

<pre class="bnf"><i>BreakStatement</i>:
    <b>break;</b>
    <b>break</b> <i>Identifier</i> <b>;</b>
</pre>

	A break exits the enclosing statement.

	break exits the innermost enclosing while, for, do, or switch
	statement, resuming execution at the statement following it.
	<p>

	If break is followed by <i>Identifier</i>, the <i>Identifier</i>
	must be the label of an enclosing while, for, do or switch
	statement, and that statement is exited. It is an error if
	there is no such statement.
	<p>

	Any intervening finally clauses are executed, and any intervening
	synchronization objects are released.
	<p>

	<b>Note:</b> If a finally clause executes a return, throw, or goto
	out of the finally clause,
	the break target is never reached.

<pre class="d_code"><span class="d_keyword">for</span> (i = 0; i &lt; 10; i++)
{
    <span class="d_keyword">if</span> (foo(i))
	<span class="d_keyword">break</span>;
}
</pre>

<h2><a name="return">Return Statement</a></h2>

<pre class="bnf"><i>ReturnStatement</i>:
    <b>return;</b>
    <b>return</b> <i>Expression</i> <b>;</b>
</pre>

	A return exits the current function and supplies its return
	value.

	<i>Expression</i> is required if the function specifies
	a return type that is not void.
	The <i>Expression</i> is implicitly converted to the
	function return type.
	<p>

	At least one return statement, throw statement, or assert(0) expression
	is required if the function
	specifies a return type that is not void.
	<p>

	<i>Expression</i> is allowed even if the function specifies
	a <b>void</b> return type. The <i>Expression</i> will be evaluated,
	but nothing will be returned.
	<p>

	Before the function actually returns,
	any objects with auto storage duration are destroyed,
	any enclosing finally clauses are executed,
	any scope(exit) statements are executed,
	any scope(success) statements are executed,
	and any enclosing synchronization
	objects are released.
	<p>

	The function will not return if any enclosing finally clause
	does a return, goto or throw that exits the finally clause.
	<p>

	If there is an out postcondition
	(see <a href="dbc.html">Contract Programming</a>),
	that postcondition is executed
	after the <i>Expression</i> is evaluated and before the function
	actually returns.

<pre class="d_code"><span class="d_keyword">int</span> foo(<span class="d_keyword">int</span> x)
{
    <span class="d_keyword">return</span> x + 3;
}
</pre>

<h2><a name="goto">Goto Statement</a></h2>

<pre class="bnf"><i>GotoStatement</i>:
    <b>goto</b> <i>Identifier</i> <b>;</b>
    <b>goto</b> <b>default</b> <b>;</b>
    <b>goto</b> <b>case</b> <b>;</b>
    <b>goto</b> <b>case</b> <i>Expression</i> <b>;</b>
</pre>

	A goto transfers to the statement labelled with
	<i>Identifier</i>.

<pre class="d_code">    <span class="d_keyword">if</span> (foo)
	<span class="d_keyword">goto</span> L1;
    x = 3;
L1:
    x++;
</pre>

	The second form, <tt>goto default;</tt>, transfers to the
	innermost <i>DefaultStatement</i> of an enclosing <i>SwitchStatement</i>.
	<p>

	The third form, <tt>goto case;</tt>, transfers to the
	next <i>CaseStatement</i> of the innermost enclosing
	<i>SwitchStatement</i>.
	<p>

	The fourth form, <tt>goto case <i>Expression</i>;</tt>, transfers to the
	<i>CaseStatement</i> of the innermost enclosing <i>SwitchStatement</i>
	with a matching <i>Expression</i>.

<pre class="d_code"><span class="d_keyword">switch</span> (x)
{
    <span class="d_keyword">case</span> 3:
	<span class="d_keyword">goto</span> <span class="d_keyword">case</span>;
    <span class="d_keyword">case</span> 4:
	<span class="d_keyword">goto</span> <span class="d_keyword">default</span>;
    <span class="d_keyword">case</span> 5:
	<span class="d_keyword">goto</span> <span class="d_keyword">case</span> 4;
    <span class="d_keyword">default</span>:
	x = 4;
	<span class="d_keyword">break</span>;
}
</pre>
	Any intervening finally clauses are executed, along with
	releasing any intervening synchronization mutexes.
	<p>

	It is illegal for a <i>GotoStatement</i> to be used to skip
	initializations.

<h2><a name="with">With Statement</a></h2>

	The with statement is a way to simplify repeated references
	to the same object.

<pre class="bnf"><i>WithStatement</i>:
	<b>with</b> <b>(</b> <i>Expression</i> <b>)</b> <i>BlockStatement</i>
	<b>with</b> <b>(</b> <i>Symbol</i> <b>)</b> <i>BlockStatement</i>
	<b>with</b> <b>(</b> <i>TemplateInstance</i> <b>)</b> <i>BlockStatement</i>
</pre>

	where <i>Expression</i> evaluates to a class reference or struct
	instance.
	Within the with body the referenced object is searched first for
	identifier symbols. The <i>WithStatement</i>

<pre class="d_code"><b><span class="d_keyword">with</span></b> (expression)
{
    ...
    ident;
}
</pre>

	is semantically equivalent to:

<pre class="d_code">{
    Object tmp;
    tmp = expression;
    ...
    tmp.ident;
}
</pre>

	Note that <tt>expression</tt> only gets evaluated once.
	The with statement does not change what <b>this</b> or
	<b>super</b> refer to.
	<p>

	For <i>Symbol</i> which is a scope or <i>TemplateInstance</i>,
	the corresponding scope is searched when looking up symbols.
	For example:

<pre class="d_code"><span class="d_keyword">struct</span> Foo
{
    <span class="d_keyword">typedef</span> <span class="d_keyword">int</span> Y;
}
...
Y y;		<span class="d_comment">// error, Y undefined
</span><span class="d_keyword">with</span> (Foo)
{
    Y y;	<span class="d_comment">// same as Foo.Y y;
</span>}
</pre>

<h2><a name="synchronize">Synchronize Statement</a></h2>

	The synchronize statement wraps a statement with
	critical section to synchronize access among multiple threads.

<pre class="bnf"><i>SynchronizeStatement</i>:
	<b>synchronized</b> <i>Statement</i>
	<b>synchronized (</b> <i>Expression</i> <b>)</b> <i>Statement</i>
</pre>

	synchronized allows only one thread at a time to execute <i>Statement</i>.
	<p>

	synchronized (<i>Expression</i>), where <i>Expression</i> evaluates to an
	Object reference, allows only one thread at a time to use
	that Object to execute the <i>Statement</i>.
	If <i>Expression</i> is an instance of an <i>Interface</i>, it is
	cast to an <i>Object</i>.
	<p>

	The synchronization gets released even if <i>Statement</i> terminates
	with an exception, goto, or return.
	<p>

	Example:

<pre class="d_code"><span class="d_keyword">synchronized</span> { ... }
</pre>

	This implements a standard critical section.

<h2><a name="try">Try Statement</a></h2>

	Exception handling is done with the try-catch-finally statement.

<pre class="bnf"><i>TryStatement</i>:
	<b>try</b> <i>BlockStatement</i> <i>Catches</i>
	<b>try</b> <i>BlockStatement</i> <i>Catches</i> <i>FinallyStatement</i>
	<b>try</b> <i>BlockStatement</i> <i>FinallyStatement</i>

<i>Catches</i>:
	<i>LastCatch</i>
	<i>Catch</i>
	<i>Catch</i> <i>Catches</i>

<i>LastCatch</i>:
	<b>catch</b> <i>BlockStatement</i>

<i>Catch</i>:
	<b>catch (</b> <i>CatchParameter</i> <b>)</b> <i>BlockStatement</i>

<i>FinallyStatement</i>:
	<b>finally</b> <i>BlockStatement</i>
</pre>

	<i>CatchParameter</i> declares a variable v of type T, where T is Object
	or derived from Object. v is initialized by the throw expression if
	T is of the same type or a base class of the throw expression.
	The catch clause will be executed if the exception object is of
	type T or derived from T.
	<p>

	If just type T is given and no variable v, then the catch clause
	is still executed.
	<p>

	It is an error if any <i>CatchParameter</i> type T1 hides
	a subsequent <i>Catch</i> with type T2, i.e. it is an error if
	T1 is the same type as or a base class of T2.
	<p>

	<i>LastCatch</i> catches all exceptions.
	<p>

	The <i>FinallyStatement</i> is always executed, whether
	the <b>try</b> <i>BlockStatement</i> exits with a goto, break,
	continue, return, exception, or fall-through.
	<p>

	If an exception is raised in the <i>FinallyStatement</i> and
	is not caught before the <i>FinallyStatement</i> is executed,
	the new exception replaces any existing exception:

<pre class="d_code"><span class="d_keyword">int</span> main()
{
    <span class="d_keyword">try</span>
    {
	<span class="d_keyword">try</span>
	{
	    <span class="d_keyword">throw</span> <span class="d_keyword">new</span> Exception(<span class="d_string">"first"</span>);
	}
	<span class="d_keyword">finally</span>
	{
	    printf(<span class="d_string">"finally\n"</span>);
	    <span class="d_keyword">throw</span> <span class="d_keyword">new</span> Exception(<span class="d_string">"second"</span>);
	}
    }
    <span class="d_keyword">catch</span>(Exception e)
    {
	printf(<span class="d_string">"catch %.*s\n"</span>, e.msg);
    }
    printf(<span class="d_string">"done\n"</span>);
}
</pre>

    prints:

<pre class="console">finally
catch second
done
</pre>

	A <i>FinallyStatement</i> may not exit with a throw, goto, break,
	continue, or return; nor may it be entered with a goto.
	<p>

	A <i>FinallyStatement</i> may not contain any <i>Catches</i>.
	This restriction may be relaxed in future versions.

<h2><a name="throw">Throw Statement</a></h2>

	Throw an exception.

<pre class="bnf"><i>ThrowStatement</i>:
	<b>throw</b> <i>Expression</i> <b>;</b>
</pre>

	<i>Expression</i> is evaluated and must be an Object reference.
	The Object reference is thrown as an exception.

<pre class="d_code"><span class="d_keyword">throw</span> <span class="d_keyword">new</span> Exception(<span class="d_string">"message"</span>);
</pre>

<h2><a name="scope">Scope Statement</a></h2>

<pre class="bnf"><i>ScopeStatement</i>:
	<b>scope(exit)</b> <i>Statement</i>
	<b>scope(success)</b> <i>Statement</i>
	<b>scope(failure)</b> <i>Statement</i>
</pre>

	The <i>ScopeStatement</i> executes <i>Statement</i> at the close
	of the current scope, rather than at the point where the
	<i>ScopeStatement</i> appears.
	<b>scope(exit)</b> executes <i>Statement</i> when the scope
	exits normally or when it exits due to exception unwinding.
	<b>scope(failure)</b> executes <i>Statement</i> when the scope
	exits due to exception unwinding.
	<b>scope(success)</b> executes <i>Statement</i> when the scope
	exits normally.
	<p>

	If there are multiple <i>ScopeStatement</i>s in a scope, they
	are executed in the reverse lexical order in which they appear.
	If any auto instances are to be destructed upon the close of the
	scope, they also are interleaved with the <i>ScopeStatement</i>s
	in the reverse lexical order in which they appear.

<pre class="d_code">writef(<span class="d_string">"1"</span>);
{
    writef(<span class="d_string">"2"</span>);
    <span class="d_keyword">scope</span>(exit) writef(<span class="d_string">"3"</span>);
    <span class="d_keyword">scope</span>(exit) writef(<span class="d_string">"4"</span>);
    writef(<span class="d_string">"5"</span>);
}
writefln();
</pre>

	writes:

<pre class="console">12543
</pre>

<pre class="d_code">{
    <span class="d_keyword">scope</span>(exit) writef(<span class="d_string">"1"</span>);
    <span class="d_keyword">scope</span>(success) writef(<span class="d_string">"2"</span>);
    <span class="d_keyword">scope</span>(exit) writef(<span class="d_string">"3"</span>);
    <span class="d_keyword">scope</span>(success) writef(<span class="d_string">"4"</span>);
}
writefln();
</pre>

	writes:

<pre class="console">4321
</pre>

<pre class="d_code"><span class="d_keyword">class</span> Foo
{
    <span class="d_keyword">this</span>() { writef(<span class="d_string">"0"</span>); }
    ~<span class="d_keyword">this</span>() { writef(<span class="d_string">"1"</span>); }
}

<span class="d_keyword">try</span>
{
    <span class="d_keyword">scope</span>(exit) writef(<span class="d_string">"2"</span>);
    <span class="d_keyword">scope</span>(success) writef(<span class="d_string">"3"</span>);
    <span class="d_keyword">auto</span> Foo f = <span class="d_keyword">new</span> Foo();
    <span class="d_keyword">scope</span>(failure) writef(<span class="d_string">"4"</span>);
    <span class="d_keyword">throw</span> <span class="d_keyword">new</span> Exception(<span class="d_string">"msg"</span>);
    <span class="d_keyword">scope</span>(exit) writef(<span class="d_string">"5"</span>);
    <span class="d_keyword">scope</span>(success) writef(<span class="d_string">"6"</span>);
    <span class="d_keyword">scope</span>(failure) writef(<span class="d_string">"7"</span>);
}
<span class="d_keyword">catch</span> (Exception e)
{
}
writefln();
</pre>

	writes:

<pre class="console">0412
</pre>

	A <b>scope(exit)</b> or <b>scope(success)</b> statement
	may not exit with a throw, goto, break, continue, or
	return; nor may it be entered with a goto.

<h2><a name="volatile">Volatile Statement</a></h2>

	No code motion occurs across volatile statement boundaries.

<pre class="bnf"><i>VolatileStatement</i>:
	<b>volatile</b> <i>Statement</i>
</pre>

	<i>Statement</i> is evaluated.
	Memory writes occurring before the <i>Statement</i> are
	performed before any reads within or after the <i>Statement</i>.
	Memory reads occurring after the <i>Statement</i> occur after
	any writes before or within <i>Statement</i> are completed.
	<p>

	A volatile statement does not guarantee atomicity. For that,
	use synchronized statements.

<h2><a name="asm">Asm Statement</a></h2>

	Inline assembler is supported with the asm statement:

<pre class="bnf"><i>AsmStatement</i>:
	<b>asm { }</b>
	<b>asm {</b> <i>AsmInstructionList</i> <b>}</b>

<i>AsmInstructionList</i>:
	<i>AsmInstruction</i> <b>;</b>
	<i>AsmInstruction</i> <b>;</b> <i>AsmInstructionList</i>
</pre>

	An asm statement enables the direct use of assembly language
	instructions. This makes it easy to obtain direct access to special
	CPU features without resorting to an external assembler. The
	D compiler will take care of the function calling conventions,
	stack setup, etc.
	<p>

	The format of the instructions is, of course, highly dependent
	on the native instruction set of the target CPU, and so is
	<a href="iasm.html">implementation defined</a>.
	But, the format will follow the following
	conventions:

	<ul>
	<li> It must use the same tokens as the D language uses.
	<li> The comment form must match the D language comments.
	<li> Asm instructions are terminated by a ;, not by an
	end of line.
	</ul>

	These rules exist to ensure that D source code can be tokenized
	independently of syntactic or semantic analysis.
	<p>

	For example, for the Intel Pentium:

<pre class="d_code"><span class="d_keyword">int</span> x = 3;
<span class="d_keyword">asm</span>
{
    mov	EAX,x;		<span class="d_comment">// load x and put it in register EAX
</span>}
</pre>

	Inline assembler can be used to access hardware directly:

<pre class="d_code"><span class="d_keyword">int</span> gethardware()
{
    <span class="d_keyword">asm</span>
    {
	    mov	EAX, dword ptr 0x1234;
    }
}
</pre>

	For some D implementations, such as a translator from D to C, an
	inline assembler makes no sense, and need not be implemented.
	The version statement can be used to account for this:

<pre class="d_code"><span class="d_keyword">version</span> (D_InlineAsm_X86)
{
    <span class="d_keyword">asm</span>
    {
	...
    }
}
<span class="d_keyword">else</span>
{
    <span class="d_comment">/* ... some workaround ... */</span>
}
</pre>


  
<br><br>
<br><br>
<!-- Google ad -->
<script type="text/javascript"><!--
/**/google_ad_client = "pub-5628673096434613";
/**/google_ad_width = 728;
/**/google_ad_height = 90;
/**/google_ad_format = "728x90_as";
/**/google_ad_channel ="3651639259";
/**/google_page_url = document.location;
//--></script>
<script type="text/javascript" src="../../../../../../../../pagead2.googlesyndication.com/pagead/show_ads.js">
</script>

</div>





<div id="copyright">
Copyright &copy; 1999-2006 by Digital Mars, All Rights Reserved |
Page generated by <a href="http://www.digitalmars.com/d/ddoc.html">Ddoc</a>. |
<a href="http://www.prowiki.org/wiki4d/wiki.cgi?DocComments/Statement" title="Read/write comments and feedback">Comments</a>
</div>

</body>

<!-- Mirrored from www.shorthike.com/trac/browser/trunk/tools_win32/dmd/html/d/statement.html?format=raw by HTTrack Website Copier/3.x [XR&CO'2010], Sat, 01 May 2010 04:37:48 GMT -->
<!-- Added by HTTrack --><meta http-equiv="content-type" content="text/html;charset=UTF-8"><!-- /Added by HTTrack -->
</html>

