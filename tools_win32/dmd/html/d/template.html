
<!DOCTYPE html PUBLIC "-//W3C//DTD HTML 4.01//EN" "http://www.w3.org/TR/html4/strict.dtd">
<html>

<!--
	Copyright (c) 1999-2006 by Digital Mars
	All Rights Reserved
	Written by Walter Bright
	www.digitalmars.com
  -->


<!-- Mirrored from www.shorthike.com/trac/browser/trunk/tools_win32/dmd/html/d/template.html?format=raw by HTTrack Website Copier/3.x [XR&CO'2010], Sat, 01 May 2010 04:37:49 GMT -->
<!-- Added by HTTrack --><meta http-equiv="content-type" content="text/html;charset=UTF-8"><!-- /Added by HTTrack -->
<head>
<meta http-equiv="content-type" content="text/html; charset=utf-8" />
<meta name="keywords" content="D programming language" />
<meta name="description" content="D Programming Language" />
<title>D Programming Language - Templates</title>
<link rel="stylesheet" type="text/css" href="style.html" />
<link rel="shortcut icon" href="favicon.html" />
</head>

<body>
<div id="heading">
	<a href="http://www.digitalmars.com/"><img src="dmlogo.html" width="270" height="53" style="border-style:none" alt="www.digitalmars.com"></a>

	<div id="headingNav">
	<ul>	<li><a href="http://www.prowiki.org/wiki4d/wiki.cgi?DocComments/Template" title="Read/write comments and feedback">Comments</a></li>
	<li><a href="index.html" title="D Programming Language" class="dlink">D</a></li>
	<li><a href="http://www.digitalmars.com/advancedsearch.html" title="Search Digital Mars web site">Search</a></li>
	<li><a href="download.html" title="download D">Downloads</a></li>
	<li><a href="http://www.digitalmars.com/" title="www.digitalmars.com">Home</a></li>
	</ul>
	</div>

	<div id="lastupdate">Last update Mon Jun 19 18:30:22 2006
</div>
</div>

<!-- Generated by Ddoc from template.d -->



<div id="navigation">
  
<div class="navblock">
<form method="get" action="http://www.google.com/search">
<div id="searchbox">
<input id="q" name="q" size="10" value="Search" onFocus='if(this.value == "Search"){this.value="";}'>
<input type="hidden" id="domains" name="domains" value="www.digitalmars.com">
<input type="hidden" id="sitesearch" name="sitesearch" value="www.digitalmars.com/d">
<input type="hidden" id="sourceid" name="sourceid" value="google-search">
<input type="submit" id="submit" name="submit" value="Go">
</div>
</form>
<div id="toctop">
    <ul>	<li><a href="index.html" title="D Programming Language">D ...</a></li>
	<li><a href="lex.html" title="D Language Specification">Language ...</a></li>
	<li><a href="phobos/phobos.html" title="D Runtime Library">Phobos ...</a></li>
	<li><a href="comparison.html" title="Language Comparisons">Comparisons ...</a></li>
    </ul>
</div>
</div>

  
    <div class="navblock">
    <ul>	<li><a href="lex.html">Lexical</a></li>

	<li><a href="module.html">Modules</a></li>

	<li><a href="declaration.html">Declarations</a></li>

	<li><a href="type.html">Types</a></li>

	<li><a href="property.html">Properties</a></li>

	<li><a href="attribute.html">Attributes</a></li>

	<li><a href="pragma.html">Pragmas</a></li>

	<li><a href="expression.html">Expressions</a></li>

	<li><a href="statement.html">Statements</a></li>

	<li><a href="arrays.html">Arrays</a></li>

	<li><a href="struct.html">Structs &amp; Unions</a></li>

	<li><a href="class.html">Classes</a></li>

	<li><a href="interface.html">Interfaces</a></li>

	<li><a href="enum.html">Enums</a></li>

	<li><a href="function.html">Functions</a></li>

	<li><a href="operatoroverloading.html">Operator Overloading</a></li>

	<li><a href="template.html">Templates</a></li>

	<li><a href="mixin.html">Mixins</a></li>

	<li><a href="dbc.html">Contracts</a></li>

	<li><a href="version.html">Conditional Compilation</a></li>

	<li><a href="errors.html">Handling errors</a></li>

	<li><a href="garbage.html">Garbage Collection</a></li>

	<li><a href="float.html">Floating Point</a></li>

	<li><a href="iasm.html">Inline Assembler</a></li>

	<li><a href="ddoc.html">Documentation Comments</a></li>

	<li><a href="interfaceToC.html">Interfacing To C</a></li>

	<li><a href="portability.html">Portability Guide</a></li>

	<li><a href="html.html">Embedding D in HTML</a></li>

	<li><a href="entity.html">Named Character Entities</a></li>

	<li><a href="abi.html">Application Binary Interface</a></li>

    </ul>
    </div>

</div>
<div id="content">
  <h1>     Templates</h1>
  
<blockquote><p>
I think that I can safely say that nobody understands template mechanics. -- Richard Deyman
</p></blockquote>


<p>Templates are D's approach to generic programming.
	Templates are defined with a <i>TemplateDeclaration</i>:
</p>

<pre class="bnf"><i>TemplateDeclaration</i>:
	<b>template</b> <i>TemplateIdentifier</i> <b>(</b> <i>TemplateParameterList</i> <b>)</b>
		<b>{</b> DeclDefs <b>}</b>

<i>TemplateIdentifier</i>:
	<i>Identifier</i>

<i>TemplateParameterList</i>
	<i>TemplateParameter</i>
	<i>TemplateParameter</i> , <i>TemplateParameterList</i>

<i>TemplateParameter</i>:
	<i>TypeParameter</i>
	<i>ValueParameter</i>
	<i>AliasParameter</i>

<i>TemplateTypeParameter</i>:
	<i>Identifier</i>
	<i>Identifier</i> <i>TemplateTypeParameterSpecialization</i>
	<i>Identifier</i> <i>TemplateTypeParameterDefault</i>
	<i>Identifier</i> <i>TemplateTypeParameterSpecialization</i> <i>TemplateTypeParameterDefault</i>

<i>TemplateTypeParameterSpecialization</i>:
	 <b>:</b> <i>Type</i>

<i>TemplateTypeParameterDefault</i>:
	 <b>=</b> <i>Type</i>

<i>TemplateValueParameter</i>:
	<i>Declaration</i>
	<i>Declaration</i> <i>TemplateValueParameterSpecialization</i>
	<i>Declaration</i> <i>TemplateValueParameterDefault</i>
	<i>Declaration</i> <i>TemplateValueParameterSpecialization</i> <i>TemplateValueParameterDefault</i>

<i>TemplateValueParameterSpecialization</i>:
	 <b>:</b> <i>ConditionalExpression</i>

<i>TemplateValueParameterDefault</i>:
	 <b>=</b> <i>ConditionalExpression</i>

<i>TemplateAliasParameter</i>:
	<b>alias</b> <i>Identifier</i>
	<b>alias</b> <i>Identifier</i> <i>TemplateAliasParameterSpecialization</i>
	<b>alias</b> <i>Identifier</i> <i>TemplateAliasParameterDefault</i>
	<b>alias</b> <i>Identifier</i> <i>TemplateAliasParameterSpecialization</i> <i>TemplateAliasParameterDefault</i>

<i>TemplateAliasParameterSpecialization</i>:
	 <b>:</b> <i>Type</i>

<i>TemplateAliasParameterDefault</i>:
	 <b>=</b> <i>Type</i>
</pre>

<p>The body of the <i>TemplateDeclaration</i> must be syntactically correct
	even if never instantiated. Semantic analysis is not done until
	instantiated. A template forms its own scope, and the template
	body can contain classes, structs, types, enums, variables,
	functions, and other templates.
</p>
<p>	Template parameters can be types, values, or symbols.
	Types can be any type.
	Value parameters must be of an integral type, floating point
	type, or string type and
	specializations for them must resolve to an integral constant,
	floating point constant, null, or a string literal.
	Symbols can be any non-local symbol.
</p>
<p>	Template parameter specializations
	constrain the values or types the <i>TemplateParameter</i> can
	accept.
</p>
<p>	Template parameter defaults are the value or type to use for the
	<i>TemplateParameter</i> in case one is not supplied.
</p>

<h2>Explicit Template Instantiation</h2>

<p>	Templates are explicitly instantiated with:
</p>

<pre class="bnf"><i>TemplateInstance</i>:
	<i>TemplateIdentifer</i> <b>!(</b> <i>TemplateArgumentList</i> <b>)</b>

<i>TemplateArgumentList</i>:
	<i>TemplateArgument</i>
	<i>TemplateArgument</i> , <i>TemplateArgumentList</i>

<i>TemplateArgument</i>:
	<i>Type</i>
	<i>AssignExpression</i>
	<i>Symbol</i>
</pre>

<p>	Once instantiated, the declarations inside the template, called
	the template members, are in the scope
	of the <i>TemplateInstance</i>:
</p>

<pre class="d_code"><span class="d_keyword">template</span> TFoo(T) { <span class="d_keyword">alias</span> T* t; }
...
TFoo!(<span class="d_keyword">int</span>).t x;	<span class="d_comment">// declare x to be of type int*
</span></pre>

<p>	A template instantiation can be aliased:
</p>

<pre class="d_code"><span class="d_keyword">template</span> TFoo(T) { <span class="d_keyword">alias</span> T* t; }
<span class="d_keyword">alias</span> TFoo!(<span class="d_keyword">int</span>) abc;
abc.t x;	<span class="d_comment">// declare x to be of type int*
</span></pre>

<p>	Multiple instantiations of a <i>TemplateDeclaration</i> with the same
	<i>TemplateParameterList</i> all will refer to the same instantiation.
	For example:
</p>

<pre class="d_code"><span class="d_keyword">template</span> TFoo(T) { T f; }
<span class="d_keyword">alias</span> TFoo!(<span class="d_keyword">int</span>) a;
<span class="d_keyword">alias</span> TFoo!(<span class="d_keyword">int</span>) b;
...
a.f = 3;
<span class="d_keyword">assert</span>(b.f == 3);	<span class="d_comment">// a and b refer to the same instance of TFoo
</span></pre>

<p>	This is true even if the <i>TemplateInstance</i>s are done in
	different modules.
</p>
<p>	If multiple templates with the same <i>TemplateIdentifier</i> are
	declared, they are distinct if they have a different number of
	arguments or are differently specialized.
</p>
<p>	For example, a simple generic copy template would be:
</p>

<pre class="d_code"><span class="d_keyword">template</span> TCopy(T)
{
    <span class="d_keyword">void</span> copy(<span class="d_keyword">out</span> T to, T from)
    {
	to = from;
    }
}
</pre>

<p>	To use the template, it must first be instantiated with a specific
	type:
</p>

<pre class="d_code"><span class="d_keyword">int</span> i;
TCopy!(<span class="d_keyword">int</span>).copy(i, 3);
</pre>
<!--
	Templates are instantiated with:

<pre class="bnf"><i>TemplateInstance</i>:
	<b>instance</b> <i>TemplateIdentifer</i> <b>(</b> <i>TemplateArgumentList</i> <b>)</b>

<i>TemplateAliasDeclaration</i>:
	<i>TemplateInstance</i> <i>AliasIdentifier</i>;

<i>AliasIdentifier</i>:
	<i>Identifier</i>

<i>TemplateArgumentList</i>:
	<i>TemplateArgument</i>
	<i>TemplateArgument</i> , <i>TemplateArgumentList</i>

<i>TemplateArgument</i>:
	<i>Type</i>
	<i>AssignExpression</i>
	<i>Symbol</i>
</pre>

	Once instantiated, the declarations inside the template, called
	the template members, are in the scope
	of the <i>AliasIdentifier</i>:

------
template TFoo(T) { alias T* t; }
instance TFoo(int) abc;
...
abc.t x;	// declare x to be of type int
------

	Template members can also
	be accessed directly from the <i>TemplateInstance</i>:

------
template TFoo(T) { alias T* t; }
instance TFoo(int).t x;	// declare x to be of type int
------

	Multiple instantiations of a <i>TemplateDeclaration</i> with the same
	<i>TemplateParameterList</i> all will refer to the same instantiation.
	For example:
------
template TFoo(T) { T f; }
instance TFoo(int) a;
instance TFoo(int) b;
...
a.f = 3;
assert(b.f == 3);	// a and b refer to the same instance of TFoo
------

	This is true even if the <i>TemplateInstance</i>s are done in
	different modules.
	<p>

	If multiple templates with the same <i>TemplateIdentifier</i> are
	declared, they are distinct if they have a different number of
	arguments or are differently specialized.
	<p>

	For example, a simple generic copy template would be:

------
template TCopy(T)
{
    void copy(out T to, T from)
    {
	to = from;
    }
}
------

	To use the template, it must first be instantiated with a specific
	type:

------
instance TCopy(int) copyint;
------

	And then the instance can be called:

------
int i;
copyint.copy(i, 3);
------
-->

<h2>Instantiation Scope</h2>

<p>	<i>TemplateInstantance</i>s are always performed in the scope of where
	the <i>TemplateDeclaration</i> is declared, with the addition of the
	template parameters being declared as aliases for their deduced types.
</p>
<p>	For example:
</p>

<br><br>
<u>module a</u>
<pre class="d_code"><span class="d_keyword">template</span> TFoo(T) { <span class="d_keyword">void</span> bar() { func(); } }
</pre>

<u>module b</u>
<pre class="d_code"><span class="d_keyword">import</span> a;

<span class="d_keyword">void</span> func() { }
<span class="d_keyword">alias</span> TFoo!(<span class="d_keyword">int</span>) f;	<span class="d_comment">// error: func not defined in module a
</span></pre>

<p>	and:
</p>

<br><br>
<u>module a</u>
<pre class="d_code"><span class="d_keyword">template</span> TFoo(T) { <span class="d_keyword">void</span> bar() { func(1); } }
<span class="d_keyword">void</span> func(<span class="d_keyword">double</span> d) { }
</pre>

<u>module b</u>
<pre class="d_code"><span class="d_keyword">import</span> a;

<span class="d_keyword">void</span> func(<span class="d_keyword">int</span> i) { }
<span class="d_keyword">alias</span> TFoo!(<span class="d_keyword">int</span>) f;
...
f.bar();	<span class="d_comment">// will call a.func(double)
</span></pre>

<p>	<i>TemplateParameter</i> specializations and default
	values are evaluated in the scope of the <i>TemplateDeclaration</i>.
</p>

<h2>Argument Deduction</h2>

	The types of template parameters are deduced for a particular
	template instantiation by comparing the template argument with
	the corresponding template parameter.
	<p>

	For each template parameter, the following rules are applied in
	order until a type is deduced for each parameter:

	<ol>
	<li> If there is no type specialization for the parameter,
	the type of the parameter is set to the template argument.

	<li> If the type specialization is dependent on a type parameter,
	the type of that parameter is set to be the corresponding part
	of the type argument.

	<li> If after all the type arguments are examined there are any
	type parameters left with no type assigned, they are assigned
	types corresponding to the template argument in the same position
	in the <i>TemplateArgumentList</i>.

	<li> If applying the above rules does not result in exactly one
	type for each template parameter, then it is an error.
	</ol>

	For example:

<pre class="d_code"><span class="d_keyword">template</span> TFoo(T) { }
<span class="d_keyword">alias</span> TFoo!(<span class="d_keyword">int</span>) Foo1;		<span class="d_comment">// (1) T is deduced to be int
</span><span class="d_keyword">alias</span> TFoo!(<span class="d_keyword">char</span>*) Foo2;	<span class="d_comment">// (1) T is deduced to be char*
</span>
<span class="d_keyword">template</span> TFoo(T : T*) { }
<span class="d_keyword">alias</span> TFoo!(<span class="d_keyword">char</span>*) Foo3;	<span class="d_comment">// (2) T is deduced to be char
</span>
<span class="d_keyword">template</span> TBar(D, U : D[]) { }
<span class="d_keyword">alias</span> TBar!(<span class="d_keyword">int</span>, <span class="d_keyword">int</span>[]) Bar1;	<span class="d_comment">// (2) D is deduced to be int, U is int[]
</span><span class="d_keyword">alias</span> TBar!(<span class="d_keyword">char</span>, <span class="d_keyword">int</span>[]) Bar2;	<span class="d_comment">// (4) error, D is both char and int
</span>
<span class="d_keyword">template</span> TBar(D : E*, E) { }
<span class="d_keyword">alias</span> TBar!(<span class="d_keyword">int</span>*, <span class="d_keyword">int</span>) Bar3;	<span class="d_comment">// (1) E is int
</span>				<span class="d_comment">// (3) D is int*
</span></pre>

	When considering matches, a class is
	considered to be a match for any super classes or interfaces:

<pre class="d_code"><span class="d_keyword">class</span> A { }
<span class="d_keyword">class</span> B : A { }

<span class="d_keyword">template</span> TFoo(T : A) { }
<span class="d_keyword">alias</span> TFoo!(B) Foo4;		<span class="d_comment">// (3) T is B
</span>
<span class="d_keyword">template</span> TBar(T : U*, U : A) { }
<span class="d_keyword">alias</span> TBar!(B*, B) Foo5;	<span class="d_comment">// (2) T is B*
</span>				<span class="d_comment">// (3) U is B
</span></pre>

<h2>Value Parameters</h2>

	This example of template foo has a value parameter that
	is specialized for 10:

<pre class="d_code"><span class="d_keyword">template</span> foo(U : <span class="d_keyword">int</span>, <span class="d_keyword">int</span> T : 10)
{
    U x = T;
}

<span class="d_keyword">void</span> main()
{
    <span class="d_keyword">assert</span>(foo!(<span class="d_keyword">int</span>, 10).x == 10);
}
</pre>


<h2>Specialization</h2>

	Templates may be specialized for particular types of arguments
	by following the template parameter identifier with a : and the
	specialized type.
	For example:

<pre class="d_code"><span class="d_keyword">template</span> TFoo(T)        { ... } <span class="d_comment">// #1
</span><span class="d_keyword">template</span> TFoo(T : T[])  { ... } <span class="d_comment">// #2
</span><span class="d_keyword">template</span> TFoo(T : <span class="d_keyword">char</span>) { ... } <span class="d_comment">// #3
</span><span class="d_keyword">template</span> TFoo(T,U,V)    { ... } <span class="d_comment">// #4
</span>
<span class="d_keyword">alias</span> TFoo!(<span class="d_keyword">int</span>) foo1;	       <span class="d_comment">// instantiates #1
</span><span class="d_keyword">alias</span> TFoo!(<span class="d_keyword">double</span>[]) foo2;    <span class="d_comment">// instantiates #2 with T being double
</span><span class="d_keyword">alias</span> TFoo!(<span class="d_keyword">char</span>) foo3;        <span class="d_comment">// instantiates #3
</span><span class="d_keyword">alias</span> TFoo!(<span class="d_keyword">char</span>, <span class="d_keyword">int</span>) fooe;   <span class="d_comment">// error, number of arguments mismatch
</span><span class="d_keyword">alias</span> TFoo!(<span class="d_keyword">char</span>, <span class="d_keyword">int</span>, <span class="d_keyword">int</span>) foo4; <span class="d_comment">// instantiates #4
</span></pre>

	The template picked to instantiate is the one that is most specialized
	that fits the types of the <i>TemplateArgumentList</i>.
	Determine which is more specialized is done the same way as the
	C++ partial ordering rules.
	If the result is ambiguous, it is an error.

<a name="aliasparameters"><h2>Alias Parameters</h2></a>

	Alias parameters enable templates to be parameterized with
	any type of D symbol, including global names, type names,
	module names, template names, and template instance names.
	Local names may not be used as alias parameters.
	It is a superset of the uses of template template parameters in C++.

	<ul>
	<li> Global names

<pre class="d_code"><span class="d_keyword">int</span> x;

<span class="d_keyword">template</span> Foo(<span class="d_keyword">alias</span> X)
{
    <span class="d_keyword">static</span> <span class="d_keyword">int</span>* p = &amp;X;
}

<span class="d_keyword">void</span> test()
{
    <span class="d_keyword">alias</span> Foo!(x) bar;
    *bar.p = 3;		<span class="d_comment">// set x to 3
</span>    <span class="d_keyword">int</span> y;
    <span class="d_keyword">alias</span> Foo!(y) abc; <span class="d_comment">// error, y is local name
</span>}
</pre>

	<li> Type names

<pre class="d_code"><span class="d_keyword">class</span> Foo
{
    <span class="d_keyword">static</span> <span class="d_keyword">int</span> p;
}

<span class="d_keyword">template</span> Bar(<span class="d_keyword">alias</span> T)
{
    <span class="d_keyword">alias</span> T.p q;
}

<span class="d_keyword">void</span> test()
{
    <span class="d_keyword">alias</span> Bar!(Foo) bar;
    bar.q = 3;	<span class="d_comment">// sets Foo.p to 3
</span>}
</pre>

	<li> Module names

<pre class="d_code"><span class="d_keyword">import</span> std.string;

<span class="d_keyword">template</span> Foo(<span class="d_keyword">alias</span> X)
{
	<span class="d_keyword">alias</span> X.toString y;
}

<span class="d_keyword">void</span> test()
{
    <span class="d_keyword">alias</span> Foo!(std.string) bar;
    bar.y(3);	<span class="d_comment">// calls std.string.toString(3)
</span>}
</pre>

	<li> Template names

<pre class="d_code"><span class="d_keyword">int</span> x;

<span class="d_keyword">template</span> Foo(<span class="d_keyword">alias</span> X)
{
    <span class="d_keyword">static</span> <span class="d_keyword">int</span>* p = &amp;X;
}

<span class="d_keyword">template</span> Bar(<span class="d_keyword">alias</span> T)
{
    <span class="d_keyword">alias</span> T!(x) abc;
}

<span class="d_keyword">void</span> test()
{
    <span class="d_keyword">alias</span> Bar!(Foo) bar;
    *bar.abc.p = 3;	<span class="d_comment">// sets x to 3
</span>}
</pre>

	<li> Template alias names

<pre class="d_code"><span class="d_keyword">int</span> x;

<span class="d_keyword">template</span> Foo(<span class="d_keyword">alias</span> X)
{
    <span class="d_keyword">static</span> <span class="d_keyword">int</span>* p = &amp;X;
}

<span class="d_keyword">template</span> Bar(<span class="d_keyword">alias</span> T)
{
    <span class="d_keyword">alias</span> T.p q;
}

<span class="d_keyword">void</span> test()
{
    <span class="d_keyword">alias</span> Foo!(x) foo;
    <span class="d_keyword">alias</span> Bar!(foo) bar;
    *bar.q = 3;		<span class="d_comment">// sets x to 3
</span>}
</pre>

	</ul>

<h2>Template Parameter Default Values</h2>

	Trailing template parameters can be given default values:

<pre class="d_code"><span class="d_keyword">template</span> Foo(T, U = <span class="d_keyword">int</span>) { ... }
Foo!(<span class="d_keyword">uint</span>,<span class="d_keyword">long</span>); <span class="d_comment">// instantiate Foo with T as uint, and U as long
</span>Foo!(<span class="d_keyword">uint</span>);	 <span class="d_comment">// instantiate Foo with T as uint, and U as int
</span>
<span class="d_keyword">template</span> Foo(T, U = T*) { ... }
Foo!(<span class="d_keyword">uint</span>);	 <span class="d_comment">// instantiate Foo with T as uint, and U as uint*
</span></pre>

<h2>Implicit Template Properties</h2>

	If a template has exactly one member in it, and the name of that
	member is the same as the template name, that member is assumed
	to be referred to in a template instantiation:

<pre class="d_code"><span class="d_keyword">template</span> <b>Foo</b>(T)
{
    T <b>Foo</b>;	<span class="d_comment">// declare variable Foo of type T
</span>}

<span class="d_keyword">void</span> test()
{
    <b>Foo</b>!(<span class="d_keyword">int</span>) = 6;	<span class="d_comment">// instead of Foo!(int).Foo
</span>}
</pre>

<h2>Class Templates</h2>

<pre class="bnf"><i>ClassTemplateDeclaration</i>:
    <b>class</b> <i>Identifier</i> <b>(</b> <i>TemplateParameterList</i> <b>)</b> [<i>SuperClass</i> {<b>,</b> <i>InterfaceClass</i> }] <i>ClassBody</i>
</pre>

	If a template declares exactly one member, and that member is a class
	with the same name as the template:

<pre class="d_code"><span class="d_keyword">template</span> <b>Bar</b>(T)
{
    <span class="d_keyword">class</span> <b>Bar</b>
    {
	T member;
    }
}
</pre>

	then the semantic equivalent, called a <i>ClassTemplateDeclaration</i>
	can be written as:

<pre class="d_code"><span class="d_keyword">class</span> <b>Bar</b>(T)
{
    T member;
}
</pre>

<h2>Function Templates</h2>

	If a template declares exactly one member, and that member is a function
	with the same name as the template:

<pre class="bnf"><i>FunctionTemplateDeclaration</i>:
    <i>Type</i> <i>Identifier</i> <b>(</b> <i>TemplateParameterList</i> <b>)</b> <b>(</b> <i>FunctionParameterList</i> <b>)</b> <i>FunctionBody</i>
</pre>

	<p>A function template to compute the square of type <i>T</i> is:
	</p>
<pre class="d_code">T <b>Square</b>(T)(T t)
{
    <span class="d_keyword">return</span> t * t;
}
</pre>

	Function templates can be explicitly instantiated with a
	!(<i>TemplateArgumentList</i>):

<pre class="d_code">writefln(<span class="d_string">"The square of %s is %s"</span>, 3, Square!(<span class="d_keyword">int</span>)(3));
</pre>

	or implicitly, where the <i>TemplateArgumentList</i> is deduced
	from the types of the function arguments:

<pre class="d_code">writefln(<span class="d_string">"The square of %s is %s"</span>, 3, Square(3));  <span class="d_comment">// T is deduced to be int
</span></pre>

	Function template type parameters that are to be implicitly
	deduced may not have specializations:


<pre class="d_code"><span class="d_keyword">void</span> <b>Foo</b>(T : T*)(T t) { ... }

<span class="d_keyword">int</span> x,y;
Foo!(<span class="d_keyword">int</span>*)(&amp;x);  <span class="d_comment">// ok, T is not deduced from function argument
</span>Foo(&amp;y);         <span class="d_comment">// error, T has specialization
</span></pre>

	Template arguments not implicitly deduced can have default values:

<pre class="d_code"><span class="d_keyword">void</span> <b>Foo</b>(T, U=T*)(T t) { U p; ... }

<span class="d_keyword">int</span> x;
Foo(&amp;x);    <span class="d_comment">// T is int, U is int*
</span></pre>


<h2>Recursive Templates</h2>

	Template features can be combined to produce some interesting
	effects, such as compile time evaluation of non-trivial functions.
	For example, a factorial template can be written:

<pre class="d_code"><span class="d_keyword">template</span> factorial(<span class="d_keyword">int</span> n : 1)
{
    <span class="d_keyword">enum</span> { factorial = 1 }
}

<span class="d_keyword">template</span> factorial(<span class="d_keyword">int</span> n)
{
    <span class="d_keyword">enum</span> { factorial = n* factorial!(n-1) }
}

<span class="d_keyword">void</span> test()
{
    writefln(<span class="d_string">"%s"</span>, factorial!(4));	<span class="d_comment">// prints 24
</span>}
</pre>

<h2>Limitations</h2>

	Templates cannot be used to add non-static members or functions
	to classes.
	For example:

<pre class="d_code"><span class="d_keyword">class</span> Foo
{
    <span class="d_keyword">template</span> TBar(T)
    {
	T xx;			<span class="d_comment">// Error
</span>	<span class="d_keyword">int</span> func(T) { ... }	<span class="d_comment">// Error
</span>
	<span class="d_keyword">static</span> T yy;				<span class="d_comment">// Ok
</span>	<span class="d_keyword">static</span> <span class="d_keyword">int</span> func(T t, <span class="d_keyword">int</span> y) { ... } 	<span class="d_comment">// Ok
</span>    }
}
</pre>

	Templates cannot be declared inside functions.


  
<br><br>
<br><br>
<!-- Google ad -->
<script type="text/javascript"><!--
/**/google_ad_client = "pub-5628673096434613";
/**/google_ad_width = 728;
/**/google_ad_height = 90;
/**/google_ad_format = "728x90_as";
/**/google_ad_channel ="3651639259";
/**/google_page_url = document.location;
//--></script>
<script type="text/javascript" src="../../../../../../../../pagead2.googlesyndication.com/pagead/show_ads.js">
</script>

</div>





<div id="copyright">
Copyright &copy; 1999-2006 by Digital Mars, All Rights Reserved |
Page generated by <a href="http://www.digitalmars.com/d/ddoc.html">Ddoc</a>. |
<a href="http://www.prowiki.org/wiki4d/wiki.cgi?DocComments/Template" title="Read/write comments and feedback">Comments</a>
</div>

</body>

<!-- Mirrored from www.shorthike.com/trac/browser/trunk/tools_win32/dmd/html/d/template.html?format=raw by HTTrack Website Copier/3.x [XR&CO'2010], Sat, 01 May 2010 04:37:49 GMT -->
<!-- Added by HTTrack --><meta http-equiv="content-type" content="text/html;charset=UTF-8"><!-- /Added by HTTrack -->
</html>

